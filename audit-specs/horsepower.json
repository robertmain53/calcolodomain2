{
  "slug": "horsepower",
  "title": "Horsepower Calculator | Mechanical Engineering Tool",
  "canonical": "https://calcdomain.com/horsepower",
  "version": "0.1.0-draft",
  "lastCodeUpdateISO": "2026-01-19",
  "verifiedByName": "Ugo Candido",
  "verifiedProfileUrl": "https://calcdomain.com/ugocandido",
  "verifiedLinkedInUrl": "https://www.linkedin.com/in/ugocandido92821/",
  "formulas": [
    {
      "title": "Formula (extracted LaTeX)",
      "latex": "','",
      "raw": "','"
    },
    {
      "title": "Formula (extracted LaTeX)",
      "latex": "= (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel)); const clamp = (v, min, max) => Math.min(Math.max(v, min), max); const round2 = v => (isFinite(v) ? Math.round(v * 100) / 100 : 0); // Unit constants (precise) const KG_TO_LB = 2.2046226218487757; const KMH_TO_MPH = 1 / 1.609344; const NM_TO_LBFT = 0.7375621492772656; const HP_TO_KW = 0.7456998715822702; // mechanical hp to kW // DOM elements const methodRadios =",
      "raw": "= (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel)); const clamp = (v, min, max) => Math.min(Math.max(v, min), max); const round2 = v => (isFinite(v) ? Math.round(v * 100) / 100 : 0); // Unit constants (precise) const KG_TO_LB = 2.2046226218487757; const KMH_TO_MPH = 1 / 1.609344; const NM_TO_LBFT = 0.7375621492772656; const HP_TO_KW = 0.7456998715822702; // mechanical hp to kW // DOM elements const methodRadios ="
    },
    {
      "title": "Formula (extracted LaTeX)",
      "latex": "('input[name=\"tqUnit\"]'), weightTrap: $('#weightTrap'), weightTrapUnit:",
      "raw": "('input[name=\"tqUnit\"]'), weightTrap: $('#weightTrap'), weightTrapUnit:"
    },
    {
      "title": "Formula (extracted LaTeX)",
      "latex": "('input[name=\"vUnit\"]'), weightET: $('#weightET'), weightETUnit:",
      "raw": "('input[name=\"vUnit\"]'), weightET: $('#weightET'), weightETUnit:"
    },
    {
      "title": "Formula (extracted LaTeX)",
      "latex": "('input[name=\"dt\"]'), dtPct: $('#dtPct') }; const errors = { torque: $('#torque-err'), rpm: $('#rpm-err'), weightTrap: $('#weightTrap-err'), speed: $('#speed-err'), weightET: $('#weightET-err'), et: $('#et-err'), dt: $('#dt-err') }; const results = { crankHP: $('#resCrankHP'), kW: $('#resKW'), wheelHP: $('#resWheelHP'), pwr: $('#resPWR'), hint: $('#results-hint') }; const calcBtn = $('#calcBtn'); const resetBtn = $('#resetBtn'); // Tooltip toggles function setupTooltip(btnId, panelId){ const btn = document.getElementById(btnId); const panel = document.getElementById(panelId); if(!btn || !panel) return; btn.addEventListener('click', () => { const open = btn.getAttribute('aria-expanded') === 'true'; btn.setAttribute('aria-expanded', String(!open)); panel.hidden = open; }); btn.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && btn.getAttribute('aria-expanded') === 'true'){ btn.setAttribute('aria-expanded','false'); panel.hidden = true; btn.focus(); } }); } setupTooltip('tip-torque-btn', 'tip-torque'); setupTooltip('tip-weight-btn', 'tip-weight'); // Method switching function showPanel(method){ Object.keys(panels).forEach(key=>{ if(key === method){ panels[key].hidden = false; panels[key].setAttribute('aria-hidden','false'); } else { panels[key].hidden = true; panels[key].setAttribute('aria-hidden','true'); } }); validateAll(); computeAndRender(); } methodRadios.forEach(r=>r.addEventListener('change', ()=>showPanel(r.value))); // initial showPanel('tq'); // Validation helpers function setError(inputEl, errEl, msg){ inputEl?.setAttribute('aria-invalid','true'); if(errEl){ errEl.textContent = msg || ''; } } function clearError(inputEl, errEl){ inputEl?.setAttribute('aria-invalid','false'); if(errEl){ errEl.textContent = ''; } } function requiredPositive(inputEl, errEl, label){ const val = parseFloat(inputEl.value); if(isNaN(val)){ setError(inputEl, errEl, `${label} is required. Please enter a number.`); return null; } if(val <= 0){ setError(inputEl, errEl, `${label} must be greater than 0.`); return null; } clearError(inputEl, errEl); return val; } // On-blur validation [ [inputs.torque, errors.torque, 'Torque'], [inputs.rpm, errors.rpm, 'RPM'], [inputs.weightTrap, errors.weightTrap, 'Vehicle weight'], [inputs.speed, errors.speed, 'Trap speed'], [inputs.weightET, errors.weightET, 'Vehicle weight'], [inputs.et, errors.et, 'ET'] ].forEach(([el, err, label])=>{ el?.addEventListener('blur', ()=>{ requiredPositive(el, err, label); }); }); // Drivetrain loss behavior function currentDtLoss(){ const selected = inputs.dtGroup.find(r=>r.checked); if(!selected) return 0; if(selected.value === 'custom'){ const v = parseFloat(inputs.dtPct.value); if(isNaN(v)) { return 0; } return clamp(v, 0, 50); } return clamp(parseFloat(selected.value)||0, 0, 50); } function onDtChange(){ const sel = inputs.dtGroup.find(r=>r.checked)?.value; if(sel === 'custom'){ inputs.dtPct.disabled = false; inputs.dtPct.setAttribute('aria-required','true'); } else { inputs.dtPct.disabled = true; inputs.dtPct.removeAttribute('aria-required'); clearError(inputs.dtPct, errors.dt); } computeAndRender(); } inputs.dtGroup.forEach(r=>r.addEventListener('change', onDtChange)); inputs.dtPct.addEventListener('blur', ()=>{ if(inputs.dtGroup.find(r=>r.checked)?.value === 'custom'){ const v = parseFloat(inputs.dtPct.value); if(isNaN(v)) setError(inputs.dtPct, errors.dt, 'Enter a percentage between 0 and 50.'); else if(v<0 || v>50) setError(inputs.dtPct, errors.dt, 'Custom loss must be between 0% and 50%.'); else clearError(inputs.dtPct, errors.dt); } }); // Compute functions function hpFromTorqueRPM(){ const tq = requiredPositive(inputs.torque, errors.torque, 'Torque'); const rpm = requiredPositive(inputs.rpm, errors.rpm, 'RPM'); if(tq===null || rpm===null) return null; const unit = inputs.torqueUnit.find(r=>r.checked)?.value || 'lbft'; let hp; if(unit === 'lbft'){ hp = (tq * rpm) / 5252; } else { // N·m // direct constant to mechanical hp hp = (tq * rpm) / 7127; } return Math.max(hp, 0); } function hpFromTrap(){ let w = requiredPositive(inputs.weightTrap, errors.weightTrap, 'Vehicle weight'); let v = requiredPositive(inputs.speed, errors.speed, 'Trap speed'); if(w===null || v===null) return null; const wUnit = inputs.weightTrapUnit.find(r=>r.checked)?.value || 'lb'; const vUnit = inputs.speedUnit.find(r=>r.checked)?.value || 'mph'; if(wUnit === 'kg') w = w * KG_TO_LB; if(vUnit === 'kmh') v = v * KMH_TO_MPH; const hp = w * Math.pow(v/234, 3); return Math.max(hp, 0); } function hpFromET(){ let w = requiredPositive(inputs.weightET, errors.weightET, 'Vehicle weight'); const et = requiredPositive(inputs.et, errors.et, 'ET'); if(w===null || et===null) return null; const wUnit = inputs.weightETUnit.find(r=>r.checked)?.value || 'lb'; if(wUnit === 'kg') w = w * KG_TO_LB; const hp = w / Math.pow(et/5.825, 3); return Math.max(hp, 0); } function currentWeightForPWR(){ const method = methodRadios.find(r=>r.checked)?.value; let w = null; if(method==='trap'){ w = parseFloat(inputs.weightTrap.value); if(isNaN(w) || w<=0) return null; const u = inputs.weightTrapUnit.find(r=>r.checked)?.value || 'lb'; if(u==='kg') w = w * KG_TO_LB; } else if(method==='et'){ w = parseFloat(inputs.weightET.value); if(isNaN(w) || w<=0) return null; const u = inputs.weightETUnit.find(r=>r.checked)?.value || 'lb'; if(u==='kg') w = w * KG_TO_LB; } return w; } function validateAll(){ const method = methodRadios.find(r=>r.checked)?.value; if(method==='tq'){ requiredPositive(inputs.torque, errors.torque, 'Torque'); requiredPositive(inputs.rpm, errors.rpm, 'RPM'); } else if(method==='trap'){ requiredPositive(inputs.weightTrap, errors.weightTrap, 'Vehicle weight'); requiredPositive(inputs.speed, errors.speed, 'Trap speed'); } else { requiredPositive(inputs.weightET, errors.weightET, 'Vehicle weight'); requiredPositive(inputs.et, errors.et, 'ET'); } } function computeAndRender(){ let hp = 0; const method = methodRadios.find(r=>r.checked)?.value; if(method==='tq'){ const res = hpFromTorqueRPM(); if(res===null){ renderResults(null); return; } hp = res; } else if(method==='trap'){ const res = hpFromTrap(); if(res===null){ renderResults(null); return; } hp = res; } else { const res = hpFromET(); if(res===null){ renderResults(null); return; } hp = res; } renderResults(hp); } function renderResults(hp){ if(hp===null || !isFinite(hp) || hp<=0){ results.crankHP.textContent = '0.00 hp'; results.kW.textContent = '0.00 kW'; results.wheelHP.textContent = '—'; results.pwr.textContent = '—'; return; } const kW = hp * HP_TO_KW; results.crankHP.textContent = `${round2(hp).toFixed(2)} hp`; results.kW.textContent = `${round2(kW).toFixed(2)} kW`; const dt = currentDtLoss(); if(dt>0){ const whp = hp * (1 - dt/100); results.wheelHP.textContent = `${round2(whp).toFixed(2)} whp`; } else { results.wheelHP.textContent = '—'; } // Power-to-weight (hp per metric ton and per lb) const wLb = currentWeightForPWR(); if(wLb && wLb>0){ const hpPerTon = hp / (wLb/2204.6226218); // per metric ton results.pwr.textContent = `${round2(hpPerTon).toFixed(2)} hp/ton`; } else { results.pwr.textContent = '—'; } } // Live update [ inputs.torque, inputs.rpm, inputs.weightTrap, inputs.speed, inputs.weightET, inputs.et, inputs.dtPct ].forEach(el=>{ el && el.addEventListener('input', computeAndRender); }); [...inputs.torqueUnit, ...inputs.weightTrapUnit, ...inputs.speedUnit, ...inputs.weightETUnit].forEach(r=>{ r.addEventListener('change', computeAndRender); }); // Buttons calcBtn.addEventListener('click', ()=>{ validateAll(); computeAndRender(); }); resetBtn.addEventListener('click', ()=>{ // Reset all inputs $('#m-tq').checked = true; showPanel('tq'); inputs.torque.value = ''; $('#u-lbft').checked = true; inputs.rpm.value = ''; inputs.weightTrap.value = ''; $('#w-lb').checked = true; inputs.speed.value = ''; $('#v-mph').checked = true; inputs.weightET.value = ''; $('#we-lb').checked = true; inputs.et.value = ''; $('#dt-none').checked = true; inputs.dtPct.value = ''; inputs.dtPct.disabled = true; // Clear errors Object.values(errors).forEach(el=>{ if(el) el.textContent=''; });",
      "raw": "('input[name=\"dt\"]'), dtPct: $('#dtPct') }; const errors = { torque: $('#torque-err'), rpm: $('#rpm-err'), weightTrap: $('#weightTrap-err'), speed: $('#speed-err'), weightET: $('#weightET-err'), et: $('#et-err'), dt: $('#dt-err') }; const results = { crankHP: $('#resCrankHP'), kW: $('#resKW'), wheelHP: $('#resWheelHP'), pwr: $('#resPWR'), hint: $('#results-hint') }; const calcBtn = $('#calcBtn'); const resetBtn = $('#resetBtn'); // Tooltip toggles function setupTooltip(btnId, panelId){ const btn = document.getElementById(btnId); const panel = document.getElementById(panelId); if(!btn || !panel) return; btn.addEventListener('click', () => { const open = btn.getAttribute('aria-expanded') === 'true'; btn.setAttribute('aria-expanded', String(!open)); panel.hidden = open; }); btn.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && btn.getAttribute('aria-expanded') === 'true'){ btn.setAttribute('aria-expanded','false'); panel.hidden = true; btn.focus(); } }); } setupTooltip('tip-torque-btn', 'tip-torque'); setupTooltip('tip-weight-btn', 'tip-weight'); // Method switching function showPanel(method){ Object.keys(panels).forEach(key=>{ if(key === method){ panels[key].hidden = false; panels[key].setAttribute('aria-hidden','false'); } else { panels[key].hidden = true; panels[key].setAttribute('aria-hidden','true'); } }); validateAll(); computeAndRender(); } methodRadios.forEach(r=>r.addEventListener('change', ()=>showPanel(r.value))); // initial showPanel('tq'); // Validation helpers function setError(inputEl, errEl, msg){ inputEl?.setAttribute('aria-invalid','true'); if(errEl){ errEl.textContent = msg || ''; } } function clearError(inputEl, errEl){ inputEl?.setAttribute('aria-invalid','false'); if(errEl){ errEl.textContent = ''; } } function requiredPositive(inputEl, errEl, label){ const val = parseFloat(inputEl.value); if(isNaN(val)){ setError(inputEl, errEl, `${label} is required. Please enter a number.`); return null; } if(val <= 0){ setError(inputEl, errEl, `${label} must be greater than 0.`); return null; } clearError(inputEl, errEl); return val; } // On-blur validation [ [inputs.torque, errors.torque, 'Torque'], [inputs.rpm, errors.rpm, 'RPM'], [inputs.weightTrap, errors.weightTrap, 'Vehicle weight'], [inputs.speed, errors.speed, 'Trap speed'], [inputs.weightET, errors.weightET, 'Vehicle weight'], [inputs.et, errors.et, 'ET'] ].forEach(([el, err, label])=>{ el?.addEventListener('blur', ()=>{ requiredPositive(el, err, label); }); }); // Drivetrain loss behavior function currentDtLoss(){ const selected = inputs.dtGroup.find(r=>r.checked); if(!selected) return 0; if(selected.value === 'custom'){ const v = parseFloat(inputs.dtPct.value); if(isNaN(v)) { return 0; } return clamp(v, 0, 50); } return clamp(parseFloat(selected.value)||0, 0, 50); } function onDtChange(){ const sel = inputs.dtGroup.find(r=>r.checked)?.value; if(sel === 'custom'){ inputs.dtPct.disabled = false; inputs.dtPct.setAttribute('aria-required','true'); } else { inputs.dtPct.disabled = true; inputs.dtPct.removeAttribute('aria-required'); clearError(inputs.dtPct, errors.dt); } computeAndRender(); } inputs.dtGroup.forEach(r=>r.addEventListener('change', onDtChange)); inputs.dtPct.addEventListener('blur', ()=>{ if(inputs.dtGroup.find(r=>r.checked)?.value === 'custom'){ const v = parseFloat(inputs.dtPct.value); if(isNaN(v)) setError(inputs.dtPct, errors.dt, 'Enter a percentage between 0 and 50.'); else if(v<0 || v>50) setError(inputs.dtPct, errors.dt, 'Custom loss must be between 0% and 50%.'); else clearError(inputs.dtPct, errors.dt); } }); // Compute functions function hpFromTorqueRPM(){ const tq = requiredPositive(inputs.torque, errors.torque, 'Torque'); const rpm = requiredPositive(inputs.rpm, errors.rpm, 'RPM'); if(tq===null || rpm===null) return null; const unit = inputs.torqueUnit.find(r=>r.checked)?.value || 'lbft'; let hp; if(unit === 'lbft'){ hp = (tq * rpm) / 5252; } else { // N·m // direct constant to mechanical hp hp = (tq * rpm) / 7127; } return Math.max(hp, 0); } function hpFromTrap(){ let w = requiredPositive(inputs.weightTrap, errors.weightTrap, 'Vehicle weight'); let v = requiredPositive(inputs.speed, errors.speed, 'Trap speed'); if(w===null || v===null) return null; const wUnit = inputs.weightTrapUnit.find(r=>r.checked)?.value || 'lb'; const vUnit = inputs.speedUnit.find(r=>r.checked)?.value || 'mph'; if(wUnit === 'kg') w = w * KG_TO_LB; if(vUnit === 'kmh') v = v * KMH_TO_MPH; const hp = w * Math.pow(v/234, 3); return Math.max(hp, 0); } function hpFromET(){ let w = requiredPositive(inputs.weightET, errors.weightET, 'Vehicle weight'); const et = requiredPositive(inputs.et, errors.et, 'ET'); if(w===null || et===null) return null; const wUnit = inputs.weightETUnit.find(r=>r.checked)?.value || 'lb'; if(wUnit === 'kg') w = w * KG_TO_LB; const hp = w / Math.pow(et/5.825, 3); return Math.max(hp, 0); } function currentWeightForPWR(){ const method = methodRadios.find(r=>r.checked)?.value; let w = null; if(method==='trap'){ w = parseFloat(inputs.weightTrap.value); if(isNaN(w) || w<=0) return null; const u = inputs.weightTrapUnit.find(r=>r.checked)?.value || 'lb'; if(u==='kg') w = w * KG_TO_LB; } else if(method==='et'){ w = parseFloat(inputs.weightET.value); if(isNaN(w) || w<=0) return null; const u = inputs.weightETUnit.find(r=>r.checked)?.value || 'lb'; if(u==='kg') w = w * KG_TO_LB; } return w; } function validateAll(){ const method = methodRadios.find(r=>r.checked)?.value; if(method==='tq'){ requiredPositive(inputs.torque, errors.torque, 'Torque'); requiredPositive(inputs.rpm, errors.rpm, 'RPM'); } else if(method==='trap'){ requiredPositive(inputs.weightTrap, errors.weightTrap, 'Vehicle weight'); requiredPositive(inputs.speed, errors.speed, 'Trap speed'); } else { requiredPositive(inputs.weightET, errors.weightET, 'Vehicle weight'); requiredPositive(inputs.et, errors.et, 'ET'); } } function computeAndRender(){ let hp = 0; const method = methodRadios.find(r=>r.checked)?.value; if(method==='tq'){ const res = hpFromTorqueRPM(); if(res===null){ renderResults(null); return; } hp = res; } else if(method==='trap'){ const res = hpFromTrap(); if(res===null){ renderResults(null); return; } hp = res; } else { const res = hpFromET(); if(res===null){ renderResults(null); return; } hp = res; } renderResults(hp); } function renderResults(hp){ if(hp===null || !isFinite(hp) || hp<=0){ results.crankHP.textContent = '0.00 hp'; results.kW.textContent = '0.00 kW'; results.wheelHP.textContent = '—'; results.pwr.textContent = '—'; return; } const kW = hp * HP_TO_KW; results.crankHP.textContent = `${round2(hp).toFixed(2)} hp`; results.kW.textContent = `${round2(kW).toFixed(2)} kW`; const dt = currentDtLoss(); if(dt>0){ const whp = hp * (1 - dt/100); results.wheelHP.textContent = `${round2(whp).toFixed(2)} whp`; } else { results.wheelHP.textContent = '—'; } // Power-to-weight (hp per metric ton and per lb) const wLb = currentWeightForPWR(); if(wLb && wLb>0){ const hpPerTon = hp / (wLb/2204.6226218); // per metric ton results.pwr.textContent = `${round2(hpPerTon).toFixed(2)} hp/ton`; } else { results.pwr.textContent = '—'; } } // Live update [ inputs.torque, inputs.rpm, inputs.weightTrap, inputs.speed, inputs.weightET, inputs.et, inputs.dtPct ].forEach(el=>{ el && el.addEventListener('input', computeAndRender); }); [...inputs.torqueUnit, ...inputs.weightTrapUnit, ...inputs.speedUnit, ...inputs.weightETUnit].forEach(r=>{ r.addEventListener('change', computeAndRender); }); // Buttons calcBtn.addEventListener('click', ()=>{ validateAll(); computeAndRender(); }); resetBtn.addEventListener('click', ()=>{ // Reset all inputs $('#m-tq').checked = true; showPanel('tq'); inputs.torque.value = ''; $('#u-lbft').checked = true; inputs.rpm.value = ''; inputs.weightTrap.value = ''; $('#w-lb').checked = true; inputs.speed.value = ''; $('#v-mph').checked = true; inputs.weightET.value = ''; $('#we-lb').checked = true; inputs.et.value = ''; $('#dt-none').checked = true; inputs.dtPct.value = ''; inputs.dtPct.disabled = true; // Clear errors Object.values(errors).forEach(el=>{ if(el) el.textContent=''; });"
    },
    {
      "title": "Formula (extracted text)",
      "latex": "",
      "raw": "1) Torque and RPM to horsepower (imperial): \\( \\mathrm{HP} \\;=\\; \\dfrac{T_{\\mathrm{lb\\cdot ft}} \\times \\mathrm{RPM}}{5252} \\) 2) Torque and RPM to horsepower (SI, direct to mechanical hp): \\( \\mathrm{HP} \\;\\approx\\; \\dfrac{T_{\\mathrm{N\\cdot m}} \\times \\mathrm{RPM}}{7127} \\) 3) Torque and RPM to kilowatts (SI): \\( \\mathrm{kW} \\;=\\; \\dfrac{T_{\\mathrm{N\\cdot m}} \\times \\mathrm{RPM}}{9549} \\) 4) Trap speed estimate (crank horsepower): \\( \\mathrm{HP} \\;=\\; W_{\\mathrm{lb}} \\left(\\dfrac{V_{\\mathrm{mph}}}{234}\\right)^{3} \\) 5) ET estimate (crank horsepower): \\( \\mathrm{HP} \\;=\\; \\dfrac{W_{\\mathrm{lb}}}{\\left(\\dfrac{\\mathrm{ET}}{5.825}\\right)^3} \\) 6) Wheel horsepower given drivetrain loss fraction \\( \\lambda \\): \\( \\mathrm{whp} \\;=\\; \\mathrm{HP} \\times (1 - \\lambda) \\)"
    }
  ],
  "variables": [],
  "sources": [
    {
      "label": "https://www.nist.gov/pml/special-publication-811",
      "publisher": "nist.gov",
      "url": "https://www.nist.gov/pml/special-publication-811",
      "accessedISO": "2026-01-19"
    },
    {
      "label": "Engineering",
      "publisher": "calcdomain.com",
      "url": "https://calcdomain.com/engineering",
      "accessedISO": "2026-01-19"
    },
    {
      "label": "https://www.sae.org/standards/content/j1349_201106/",
      "publisher": "sae.org",
      "url": "https://www.sae.org/standards/content/j1349_201106/",
      "accessedISO": "2026-01-19"
    }
  ],
  "changelog": [
    {
      "dateISO": "2026-01-19",
      "version": "0.1.0-draft",
      "changes": [
        "Initial audit spec draft generated from HTML extraction (review required).",
        "Verify formulas match the calculator engine and convert any text-only formulas to LaTeX.",
        "Confirm sources are authoritative and relevant to the calculator methodology."
      ]
    }
  ]
}
