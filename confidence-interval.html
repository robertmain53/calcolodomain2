<!DOCTYPE html>
<html lang="en"><head> 
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="manifest" href="/site.webmanifest" />
<meta charset="utf-8"/>
<title>Confidence Interval Calculator | Math • Statistics &amp; Probability</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="Professional confidence interval calculator for means (z/t) and proportions (Wilson, Wald, Agresti–Coull). Mobile-first, WCAG 2.1 AA compliant, and optimized for speed." name="description"/>
<meta content="Ugo Candido" name="author"/>
<link href="https://calcdomain.com/confidence-interval.html" rel="canonical"/>
<meta content="#005A9C" name="theme-color"/>
<link href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%23005A9C'/%3E%3Cpath d='M16 44 L28 20 L36 36 L48 20' stroke='%23fff' stroke-width='4' fill='none'/%3E%3Ccircle cx='16' cy='44' r='3' fill='%23fff'/%3E%3Ccircle cx='28' cy='20' r='3' fill='%23fff'/%3E%3Ccircle cx='36' cy='36' r='3' fill='%23fff'/%3E%3Ccircle cx='48' cy='20' r='3' fill='%23fff'/%3E%3C/svg%3E" rel="icon" type="image/svg+xml"/>
<noscript></noscript>
<style>
    :root{
      --primary-color:#005A9C; --secondary-color:#003F6E; --accent-color:#00A4E4;
      --background-color:#F8F9FA; --surface-color:#FFFFFF;
      --text-color:#212529; --muted-text-color:#6C757D; --border-color:#DEE2E6;
      --success-color:#198754; --danger-color:#DC3545; --warning-color:#FFC107;
      --font-sans:'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius-6:6px; --radius-8:8px; --radius-12:12px;
      --touch:48px; --container:1200px;
    }

    /* Base */
    *,*::before,*::after{box-sizing:border-box}
    html{font-size:16px}
    body{margin:0;background:var(--background-color);color:var(--text-color);font-family:var(--font-sans);line-height:1.6}
    img{max-width:100%;display:block}
    a{color:var(--primary-color);text-decoration:none}
    a:hover{text-decoration:underline}
    .container{max-width:var(--container);margin:0 auto;padding:0 1rem}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .skip-link{position:absolute;left:8px;top:-40px;background:var(--primary-color);color:#fff;padding:.5rem .75rem;border-radius:0 0 6px 6px;z-index:1000}
    .skip-link:focus{top:0}

    /* Header (non-sticky per spec) */
    header.site-header{background:var(--surface-color);border-bottom:1px solid var(--border-color)}
    .header-content{display:grid;grid-template-columns:auto 1fr auto; gap:.75rem; align-items:center; padding:.75rem 0}
    .logo{font-weight:700;color:var(--primary-color);font-size:1.2rem}
    .site-search{display:flex;align-items:center;gap:.5rem;min-width:0}
    .site-search input[type="search"]{flex:1 1 auto;min-width:0;padding:.6rem .75rem;border:1px solid var(--border-color);border-radius:8px}
    .site-search input[type="search"]:focus{outline:3px solid rgba(0,90,156,.25);border-color:var(--primary-color)}
    .btn{display:inline-flex;align-items:center;justify-content:center;min-height:var(--touch);min-width:var(--touch);padding:.6rem 1rem;border-radius:8px;border:1px solid var(--primary-color);background:transparent;color:var(--primary-color);font-weight:600;cursor:pointer}
    .btn:focus{outline:3px solid rgba(0,90,156,.35);outline-offset:2px}
    .btn-primary{background:var(--primary-color);color:#fff}
    .btn-primary:hover{background:var(--secondary-color);border-color:var(--secondary-color)}
    .btn-secondary:hover{background:var(--primary-color);color:#fff}
    .nav-toggle{display:inline-flex;align-items:center;gap:.5rem;border:1px solid var(--border-color);background:#fff;border-radius:8px;padding:.5rem .75rem;min-height:var(--touch)}
    .nav-toggle:focus{outline:3px solid rgba(0,90,156,.35);outline-offset:2px}
    nav.main-nav{display:none}
    .breadcrumb{margin:.75rem 0;color:var(--muted-text-color);font-size:.9rem}

    /* Layout: calculator + content */
    main{padding:1.25rem 0 2rem}
    .calculator-layout{display:grid;grid-template-columns:1fr;gap:2rem}
    @media (min-width: 992px){
      .calculator-layout{grid-template-columns: minmax(300px, 420px) 1fr}
    }

    /* Calculator UI */
    .calculator-container{background:#fff;border:1px solid var(--border-color);border-radius:12px;padding:1.25rem}
    .calculator-container h1{font-size:1.7rem;color:var(--secondary-color);margin:0 0 .25rem}
    .section-desc{color:var(--muted-text-color);margin-bottom:.75rem}
    .form-group{margin-bottom:1rem}
    .form-group label{display:block;font-weight:600;margin-bottom:.35rem}
    .label-row{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap}
    .help-btn{border:none;background:transparent;color:var(--primary-color);font-weight:700;cursor:pointer;min-height:var(--touch);min-width:var(--touch);display:inline-flex;align-items:center;justify-content:center;border-radius:50%;width:36px;height:36px;line-height:1}
    .help-btn:focus{outline:3px solid rgba(0,90,156,.35);outline-offset:2px}
    .tooltip{display:none;background:#eff6ff;border:1px solid #b6d4fe;color:#0b3d91;border-radius:8px;padding:.75rem;font-size:.95rem}
    .tooltip[aria-hidden="false"]{display:block}
    .input-group{position:relative}
    .form-control{width:100%;min-height:var(--touch);padding:.75rem 1rem;border:1px solid var(--border-color);border-radius:8px;font-size:1rem}
    .form-control:focus{outline:3px solid rgba(0,90,156,.25);border-color:var(--primary-color)}
    .form-control[aria-invalid="true"]{border-color:var(--danger-color)}
    .unit{position:absolute;right:.75rem;top:50%;transform:translateY(-50%);color:var(--muted-text-color)}
    .error-message{color:var(--danger-color);font-size:.9rem;margin-top:.25rem;min-height:1.2em}

    .radio-group{display:flex;gap:.5rem;flex-wrap:wrap;border:1px solid var(--border-color);border-radius:8px;padding:.25rem}
    .radio-group input[type="radio"]{position:absolute;opacity:0;pointer-events:none}
    .radio-group label{flex:1 1 auto;min-width:140px;text-align:center;padding:.5rem .75rem;border-radius:6px;cursor:pointer;min-height:44px;display:flex;align-items:center;justify-content:center}
    .radio-group input[type="radio"]:checked + label{background:var(--primary-color);color:#fff}
    .radio-group input[type="radio"]:focus + label{outline:3px solid rgba(0,90,156,.35);outline-offset:2px}

    details.data-paste{border:1px dashed var(--border-color);border-radius:8px;padding:.75rem}
    details.data-paste[open]{background:#fcfcfd}
    details.data-paste summary{font-weight:600;cursor:pointer}
    .mono{font-family:var(--font-mono)}

    /* Results */
    .results-container{margin-top:1rem;padding:1rem;background:#f4f7fb;border:1px solid var(--border-color);border-radius:12px;min-height:260px}
    .results-grid{display:grid;grid-template-columns:1fr;gap:.75rem}
    @media (min-width: 576px){.results-grid{grid-template-columns:1fr 1fr}}
    .result-card{background:#fff;border:1px solid var(--border-color);border-radius:8px;padding:.75rem .9rem}
    .result-label{color:var(--muted-text-color);font-size:.9rem}
    .result-value{font-weight:700;font-size:1.2rem;color:var(--success-color)}
    .result-hint{font-size:.9rem;color:var(--muted-text-color);margin-top:.25rem}

    /* Content section */
    .content-container h2{margin-top:1.5rem;border-bottom:1px solid var(--border-color);padding-bottom:.5rem;color:var(--secondary-color)}
    .formula-box{background:#eef2f7;padding:1rem;border-radius:8px;overflow-x:auto}
    .formula-box code{background:transparent}
    .author-box{font-size:.95rem;color:var(--muted-text-color);margin-top:1.5rem;border-top:1px solid var(--border-color);padding-top:1rem}

    /* Footer */
    .site-footer{background:var(--secondary-color);color:#fff;margin-top:2rem}
    .footer-content{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1.25rem;padding:1.25rem 0}
    .footer-column h4{margin:.25rem 0  .5rem 0;color:#fff}
    .site-footer a{color:#fff}
    .footer-bottom{text-align:center;padding:.75rem;border-top:1px solid rgba(255,255,255,.2);font-size:.9rem}

    @media (prefers-reduced-motion: reduce){
      *{scroll-behavior:auto;transition:none!important;animation:none!important}
    }
  </style>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Confidence Interval Calculator",
  "description": "Compute two-sided confidence intervals for a population mean (z or t) and a proportion (Wilson, Wald, Agresti–Coull). Includes step-by-step example and expert FAQs.",
  "url": "https://calcdomain.com/confidence-interval.html",
  "inLanguage": "en",
  "isPartOf": {
    "@type": "CollectionPage",
    "name": "Math — Statistics & Probability"
  },
  "author": {
    "@type": "Person",
    "name": "Ugo Candido"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CalcDomain"
  },
  "mainEntity": [
    {
      "@type": "HowTo",
      "name": "Confidence Interval — A Step-by-Step Example",
      "description": "Calculate a 95% confidence interval for a mean with unknown population standard deviation using the t-distribution.",
      "totalTime": "PT2M",
      "tool": [
        {
          "@type": "HowToTool",
          "name": "Calculator"
        },
        {
          "@type": "HowToTool",
          "name": "Sample statistics"
        }
      ],
      "step": [
        {
          "@type": "HowToStep",
          "name": "Gather inputs",
          "text": "Sample size n = 25, sample mean x̄ = 10.2, sample standard deviation s = 3.1, confidence level = 95%."
        },
        {
          "@type": "HowToStep",
          "name": "Find the critical value",
          "text": "Degrees of freedom df = n − 1 = 24. Two-sided t critical t* = t(0.975, 24) ≈ 2.064."
        },
        {
          "@type": "HowToStep",
          "name": "Compute standard error",
          "text": "SE = s / sqrt(n) = 3.1 / 5 = 0.62."
        },
        {
          "@type": "HowToStep",
          "name": "Compute margin of error",
          "text": "ME = t* × SE = 2.064 × 0.62 ≈ 1.2797."
        },
        {
          "@type": "HowToStep",
          "name": "Compute interval",
          "text": "CI = x̄ ± ME = 10.2 ± 1.2797 ⇒ [8.9203, 11.4797]."
        }
      ]
    },
    {
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "When should I use z vs. t for a mean?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Use z when the population standard deviation is known or your sample is very large and the standard error is well estimated. Use t when the population standard deviation is unknown and you estimate it with the sample standard deviation; the t critical adjusts for extra uncertainty, especially at small n."
          }
        },
        {
          "@type": "Question",
          "name": "What proportion interval method is best?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Wilson score intervals generally have better coverage than the traditional Wald interval, especially when proportions are near 0 or 1 or when sample sizes are small. Agresti–Coull is also robust. This tool defaults to Wilson."
          }
        },
        {
          "@type": "Question",
          "name": "Does a 95% CI mean a 95% chance the parameter lies in the interval?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Not exactly. It means that if you repeated the study many times, 95% of the confidence intervals constructed this way would contain the true parameter. For a single computed interval, we do not assign a probability to the fixed parameter."
          }
        },
        {
          "@type": "Question",
          "name": "How do I check normality assumptions?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "For means, the Central Limit Theorem helps when n is moderately large. For small n, inspect histograms/QQ plots or rely on domain knowledge. For proportions, Wilson intervals perform well even when np or n(1−p) are small compared to the Wald interval."
          }
        },
        {
          "@type": "Question",
          "name": "Can I use this tool for one-sided intervals?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "This version computes two-sided confidence intervals. One-sided intervals use a different critical value (e.g., z(0.95) instead of z(0.975)). A one-sided mode will be added in a future update."
          }
        },
        {
          "@type": "Question",
          "name": "What precision does the calculator use?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Critical values are computed with a high-accuracy normal quantile and a Cornish–Fisher expansion for the t-quantile, typically accurate to 4–6 decimal places for df ≥ 2."
          }
        }
      ]
    }
  ]
}
  </script>
<script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      options: { renderActions: { addMenu: [] } }
    };
  </script>
<script async="" crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>
<script src="search.js" defer></script>
<!-- MathJax for LaTeX formulas -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\(','\)'], ['$', '$']],
      displayMath: [['$','$'], ['\[','\]']]
    },
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link rel="preload" href="/assets/js/mobile-menu.js" as="script">
<link rel="preload" href="/assets/js/page-enhancements.js" as="script">

</head>
<body>
<a class="skip-link" href="#main-content">Skip to main content</a>

<main class="main-content" id="main-content" role="main">
<div class="container">
<nav aria-label="Breadcrumb" class="breadcrumb">
<a href="/">Home</a> / <a href="https://calcdomain.com/math.html">Math</a> / <a href="https://calcdomain.com/statistics.html">Statistics &amp; Probability</a> / Confidence Interval Calculator
      </nav>
<div class="calculator-layout">
<aside class="calculator-wrapper">
<section aria-labelledby="calculator-heading" class="calculator-container" id="ci-calculator">
<h1 id="calculator-heading">Confidence Interval Calculator</h1>
<p class="section-desc">Compute two-sided confidence intervals for a population mean (z or t) or a proportion (Wilson, Wald, Agresti–Coull). Accessible, precise, and mobile-first.</p>
<div class="form-group">
<fieldset>
<legend class="sr-only">Choose estimator type</legend>
<div aria-label="Estimator type" class="radio-group" role="radiogroup">
<input checked="" id="mode-mean-z" name="mode" type="radio" value="mean-z"/>
<label for="mode-mean-z">Mean (σ known) — z</label>
<input id="mode-mean-t" name="mode" type="radio" value="mean-t"/>
<label for="mode-mean-t">Mean (σ unknown) — t</label>
<input id="mode-prop" name="mode" type="radio" value="proportion"/>
<label for="mode-prop">Proportion (p)</label>
</div>
</fieldset>
</div>
<div class="form-group">
<div class="label-row">
<label for="confLevel">Confidence level (%) *</label>
<button aria-controls="conf-help" aria-expanded="false" class="help-btn" title="What is confidence level?" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="conf-help">
                The confidence level determines how often the interval procedure captures the true parameter over many samples. Common choices: 90%, 95%, 99%.
              </div>
<div class="input-group">
<input aria-describedby="conf-help confLevelError" aria-required="true" class="form-control" id="confLevel" max="99.99" min="50" step="0.01" type="number" value="95"/>
<span class="unit">%</span>
</div>
<div aria-live="polite" class="error-message" id="confLevelError" role="alert"></div>
</div>
<div class="form-group mode mean">
<label for="sampleSize">Sample size (n) *</label>
<div class="input-group">
<input aria-describedby="nError" aria-required="true" class="form-control" id="sampleSize" min="1" placeholder="e.g., 30" step="1" type="number"/>
</div>
<div aria-live="polite" class="error-message" id="nError" role="alert"></div>
</div>
<div class="form-group mode mean mean-stats">
<label for="sampleMean">Sample mean (x̄) *</label>
<div class="input-group">
<input aria-describedby="meanError" aria-required="true" class="form-control" id="sampleMean" placeholder="e.g., 10.2" step="any" type="number"/>
</div>
<div aria-live="polite" class="error-message" id="meanError" role="alert"></div>
</div>
<div class="form-group mode mean mean-z">
<label for="popSD">Population SD (σ) *</label>
<div class="input-group">
<input aria-describedby="sigmaError" aria-required="true" class="form-control" id="popSD" min="0" placeholder="e.g., 3.5" step="any" type="number"/>
</div>
<div aria-live="polite" class="error-message" id="sigmaError" role="alert"></div>
</div>
<div class="form-group mode mean mean-t">
<label for="sampleSD">Sample SD (s) *</label>
<div class="input-group">
<input aria-describedby="sError" aria-required="true" class="form-control" id="sampleSD" min="0" placeholder="e.g., 3.1" step="any" type="number"/>
</div>
<div aria-live="polite" class="error-message" id="sError" role="alert"></div>
</div>
<details class="data-paste mode mean" id="pasteData">
<summary>Optional: Paste raw data to auto-compute x̄ and s</summary>
<p>Paste comma, space or newline-separated values. We compute the sample mean and unbiased sample standard deviation.</p>
<label class="sr-only" for="rawData">Raw data</label>
<textarea class="form-control mono" id="rawData" placeholder="Example: 9.4, 10.2, 11.1, 8.9" rows="4"></textarea>
<p aria-live="polite" class="result-hint" id="rawDataHint"></p>
</details>
<div class="form-group mode proportion">
<label for="successes">Number of successes (x) *</label>
<div class="input-group">
<input aria-describedby="xError" aria-required="true" class="form-control" id="successes" min="0" placeholder="e.g., 42" step="1" type="number"/>
</div>
<div aria-live="polite" class="error-message" id="xError" role="alert"></div>
</div>
<div class="form-group mode proportion">
<label for="trials">Number of trials (n) *</label>
<div class="input-group">
<input aria-describedby="trialsError" aria-required="true" class="form-control" id="trials" min="1" placeholder="e.g., 100" step="1" type="number"/>
</div>
<div aria-live="polite" class="error-message" id="trialsError" role="alert"></div>
</div>
<div class="form-group mode proportion">
<fieldset>
<legend class="sr-only">Proportion method</legend>
<label>Method</label>
<div aria-label="Proportion CI method" class="radio-group" role="radiogroup">
<input checked="" id="method-wilson" name="propMethod" type="radio" value="wilson"/>
<label for="method-wilson">Wilson (recommended)</label>
<input id="method-wald" name="propMethod" type="radio" value="wald"/>
<label for="method-wald">Wald (traditional)</label>
<input id="method-ac" name="propMethod" type="radio" value="agresti-coull"/>
<label for="method-ac">Agresti–Coull</label>
</div>
</fieldset>
</div>
<div class="form-group" style="display:flex;gap:.5rem;flex-wrap:wrap">
<button aria-describedby="calcNote" class="btn btn-primary" id="calcBtn" type="button">Calculate</button>
<button class="btn btn-secondary" id="resetBtn" type="button">Reset</button>
<span class="sr-only" id="calcNote">Calculates the confidence interval based on the provided inputs.</span>
</div>
<div aria-atomic="true" aria-live="polite" class="results-container" id="results">
<h2 class="sr-only">Results</h2>
<div class="results-grid">
<div class="result-card">
<div class="result-label">Point estimate</div>
<div class="result-value" id="resPoint">—</div>
<div class="result-hint" id="resPointHint">x̄ for mean, p̂ for proportion</div>
</div>
<div class="result-card">
<div class="result-label">Standard error (SE)</div>
<div class="result-value" id="resSE">—</div>
</div>
<div class="result-card">
<div class="result-label">Critical value</div>
<div class="result-value" id="resCrit">—</div>
<div class="result-hint" id="resCritHint">z* or t*</div>
</div>
<div class="result-card">
<div class="result-label">Margin of error (ME)</div>
<div class="result-value" id="resME">—</div>
</div>
<div class="result-card">
<div class="result-label">Lower bound</div>
<div class="result-value" id="resLo">—</div>
</div>
<div class="result-card">
<div class="result-label">Upper bound</div>
<div class="result-value" id="resHi">—</div>
</div>
</div>
<p class="result-hint" id="assumptionNote"></p>
</div>
</section>
</aside>
<article class="content-container">
<p>This professional-grade confidence interval calculator helps researchers, students, data scientists, and engineers construct two-sided confidence intervals for population means and proportions. It supports both z- and t-based intervals for means and robust methods for proportions, with clear steps and accessible explanations.</p>
<section aria-labelledby="source-method">
<h2 id="source-method">Data Source and Methodology</h2>
<p>
              Authoritative source: National Institute of Standards and Technology (NIST), Engineering Statistics Handbook, Section 8: Confidence Intervals (revision 2012).
              <a href="https://www.itl.nist.gov/div898/handbook/prc/section2/prc2.htm" rel="noopener" target="_blank">Direct link</a>.
            </p>
<p>Tutti i calcoli si basano rigorosamente sulle formule e sui dati forniti da questa fonte.</p>
</section>
<section aria-labelledby="formulae">
<h2 id="formulae">The Formula Explained</h2>
<div class="formula-box">
<p>Two-sided confidence interval for a mean with known σ (z):</p>
<p>$$ \bar{x} \pm z_{1-\alpha/2} \cdot \frac{\sigma}{\sqrt{n}} $$</p>
<p>Two-sided confidence interval for a mean with unknown σ (t):</p>
<p>$$ \bar{x} \pm t_{1-\alpha/2,\;n-1} \cdot \frac{s}{\sqrt{n}} $$</p>
<p>Wald interval for a proportion p:</p>
<p>$$ \hat{p} \pm z_{1-\alpha/2} \cdot \sqrt{\frac{\hat{p}(1-\hat{p})}{n}} $$</p>
<p>Wilson score interval for a proportion p:</p>
<p>$$
              \frac{\hat{p} + \frac{z^2}{2n} \pm z \sqrt{\frac{\hat{p}(1-\hat{p})}{n} + \frac{z^2}{4n^2}}}
                   {1 + \frac{z^2}{n}}
              $$</p>
<p>Agresti–Coull interval:</p>
<p>$$ \tilde{p} = \frac{x + \tfrac{z^2}{2}}{n + z^2}, \quad
                     \text{CI} = \tilde{p} \pm z \sqrt{\frac{\tilde{p}(1-\tilde{p})}{\,n + z^2\,}} $$</p>
</div>
</section>
<section aria-labelledby="glossary">
<h2 id="glossary">Glossary of Variables</h2>
<ul>
<li>x̄ — sample mean.</li>
<li>σ — population standard deviation (known).</li>
<li>s — sample standard deviation (unknown σ case).</li>
<li>n — sample size; df = n − 1 for t.</li>
<li>z, t — critical values for the standard normal and Student’s t distributions.</li>
<li>x — number of successes; n — number of trials; p̂ = x/n.</li>
<li>SE — standard error; ME — margin of error; CI — confidence interval.</li>
</ul>
</section>
<section aria-labelledby="worked-example">
<h2 id="worked-example">How It Works: A Step-by-Step Example</h2>
<p><strong>Scenario:</strong> A team measures the compression strength (MPa) of 25 samples: x̄ = 10.2, s = 3.1. Construct a 95% CI for the mean strength (σ unknown).</p>
<ol>
<li>df = 24; confidence level 95% ⇒ α = 0.05 ⇒ use t critical t<sub>0.975,24</sub> ≈ 2.064.</li>
<li>SE = s / √n = 3.1 / 5 = 0.62.</li>
<li>ME = t × SE = 2.064 × 0.62 ≈ 1.2797.</li>
<li>CI = x̄ ± ME = 10.2 ± 1.2797 ⇒ [8.9203, 11.4797].</li>
</ol>
</section>
<section aria-labelledby="faq">
<h2 id="faq">Frequently Asked Questions (FAQ)</h2>
<div>
<h3>How do I choose the confidence level?</h3>
<p>95% is standard; 90% yields narrower intervals, 99% wider. Choose based on risk tolerance and domain norms.</p>
<h3>What if my data are skewed or have outliers?</h3>
<p>For means with small n, t-intervals assume approximate normality of the sampling distribution. Consider transformations or robust methods if skew/outliers are extreme.</p>
<h3>Is the Wilson interval always better than Wald?</h3>
<p>Wilson has superior coverage, especially near boundaries or at small n. Wald is simple but can be unreliable when np or n(1−p) are small.</p>
<h3>Can I paste raw data?</h3>
<p>Yes. Use the “Paste raw data” panel. We compute x̄ and s, which replace manual entries for mean-based intervals.</p>
<h3>Do results round values?</h3>
<p>We compute with full precision and display to a sensible number of decimals. You can interpret or round per your reporting standards.</p>
<h3>Are intervals one- or two-sided?</h3>
<p>Currently two-sided. One-sided intervals will be added in a future update.</p>
</div>
</section>
<div class="author-box">
<p>
              Tool developed by <strong>Ugo Candido</strong>. Content verified by <strong>CalcDomain Expert Team</strong>.<br/>
              Last reviewed for accuracy on: <time datetime="2025-09-14">September 14, 2025</time>.
            </p>
</div>
</article>
</div>
</div>
</main>
<!-- Standard Footer --> 
<script defer="">
    (function(){
      'use strict';

      // Utility: number parsing and formatting
      const toNum = v => (v === '' || v === null || v === undefined) ? NaN : Number(v);
      const fmt = (v, digits=4) => Number.isFinite(v) ? (Math.abs(v) >= 1000 ? v.toLocaleString(undefined, {maximumFractionDigits: digits}) : v.toFixed(digits)) : '—';
      const clamp = (x,min,max)=>Math.min(Math.max(x,min),max);

      // Accessible tooltip
      const helpBtn = document.querySelector('.help-btn');
      const helpTip = document.getElementById('conf-help');
      helpBtn?.addEventListener('click', () => {
        const expanded = helpBtn.getAttribute('aria-expanded') === 'true';
        helpBtn.setAttribute('aria-expanded', String(!expanded));
        helpTip.setAttribute('aria-hidden', String(expanded));
      });

      // Elements
      const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));
      const confLevel = document.getElementById('confLevel');
      const sampleSize = document.getElementById('sampleSize');
      const sampleMean = document.getElementById('sampleMean');
      const popSD = document.getElementById('popSD');
      const sampleSD = document.getElementById('sampleSD');
      const rawData = document.getElementById('rawData');
      const rawDataHint = document.getElementById('rawDataHint');
      const successes = document.getElementById('successes');
      const trials = document.getElementById('trials');
      const propMethodRadios = Array.from(document.querySelectorAll('input[name="propMethod"]'));

      const resPoint = document.getElementById('resPoint');
      const resSE = document.getElementById('resSE');
      const resCrit = document.getElementById('resCrit');
      const resME = document.getElementById('resME');
      const resLo = document.getElementById('resLo');
      const resHi = document.getElementById('resHi');
      const resCritHint = document.getElementById('resCritHint');
      const resPointHint = document.getElementById('resPointHint');
      const assumptionNote = document.getElementById('assumptionNote');

      const calcBtn = document.getElementById('calcBtn');
      const resetBtn = document.getElementById('resetBtn');

      // Error placeholders
      const err = {
        conf: document.getElementById('confLevelError'),
        n: document.getElementById('nError'),
        mean: document.getElementById('meanError'),
        sigma: document.getElementById('sigmaError'),
        s: document.getElementById('sError'),
        x: document.getElementById('xError'),
        trials: document.getElementById('trialsError')
      };

      function currentMode(){
        const m = modeRadios.find(r=>r.checked);
        return m ? m.value : 'mean-z';
      }

      // Show/hide fields based on mode
      function updateVisibility(){
        const mode = currentMode();
        document.querySelectorAll('.mode').forEach(el => {
          el.style.display = 'none';
        });
        if(mode.startsWith('mean')){
          document.querySelectorAll('.mode.mean').forEach(el => el.style.display = '');
          document.querySelectorAll('.mode.proportion').forEach(el => el.style.display = 'none');
          // toggle z vs t inputs
          document.querySelectorAll('.mean-z').forEach(el => el.style.display = (mode==='mean-z') ? '' : 'none');
          document.querySelectorAll('.mean-t').forEach(el => el.style.display = (mode==='mean-t') ? '' : 'none');
        } else {
          document.querySelectorAll('.mode.proportion').forEach(el => el.style.display = '');
        }
      }
      updateVisibility();
      modeRadios.forEach(r=>r.addEventListener('change', ()=>{ updateVisibility(); clearErrors(); }));

      // Validation
      function setInvalid(input, msgEl, message){
        input.setAttribute('aria-invalid', 'true');
        msgEl.textContent = message;
      }
      function clearInvalid(input, msgEl){
        input.removeAttribute('aria-invalid');
        msgEl.textContent = '';
      }
      function clearErrors(){
        [confLevel, sampleSize, sampleMean, popSD, sampleSD, successes, trials].forEach((inp)=>{
          if(!inp) return;
          inp.removeAttribute('aria-invalid');
        });
        Object.values(err).forEach(e=>{ if(e) e.textContent=''; });
      }

      function validate(){
        let ok = true;
        const mode = currentMode();
        const cl = toNum(confLevel.value);
        if(!Number.isFinite(cl) || cl <= 50 || cl >= 100){
          setInvalid(confLevel, err.conf, 'Enter a confidence level between 50 and 99.99.');
          ok = false;
        } else clearInvalid(confLevel, err.conf);

        if(mode.startsWith('mean')){
          const n = Math.floor(toNum(sampleSize.value));
          if(!Number.isFinite(n) || n < 1){
            setInvalid(sampleSize, err.n, 'Sample size must be an integer ≥ 1.');
            ok = false;
          } else clearInvalid(sampleSize, err.n);

          // Parse raw data if provided
          const data = parseData(rawData.value);
          if(data.length > 0){
            if(n && n !== data.length){
              setInvalid(sampleSize, err.n, `n = ${n} does not match data length ${data.length}. Either clear data or set n = ${data.length}.`);
              ok = false;
            }
          }

          const meanVal = data.length ? mean(data) : toNum(sampleMean.value);
          if(!Number.isFinite(meanVal)){
            setInvalid(sampleMean, err.mean, 'Provide a valid sample mean or paste raw data.');
            ok = false;
          } else clearInvalid(sampleMean, err.mean);

          if(mode === 'mean-z'){
            const sigma = toNum(popSD.value);
            if(!Number.isFinite(sigma) || sigma <= 0){
              setInvalid(popSD, err.sigma, 'Population SD σ must be a positive number.');
              ok = false;
            } else clearInvalid(popSD, err.sigma);
          } else {
            if(data.length > 1){
              // OK, we'll compute s from data
              clearInvalid(sampleSD, err.s);
            } else {
              const s = toNum(sampleSD.value);
              // t requires df = n-1 ≥ 1
              const nInt = Math.floor(toNum(sampleSize.value));
              if(!Number.isFinite(s) || s <= 0){
                setInvalid(sampleSD, err.s, 'Sample SD s must be a positive number.');
                ok = false;
              } else if(!(Number.isFinite(nInt) && nInt >= 2)){
                setInvalid(sampleSize, err.n, 'For t-intervals, n must be ≥ 2 (df ≥ 1).');
                ok = false;
              } else {
                clearInvalid(sampleSD, err.s);
              }
            }
          }
        } else {
          const x = Math.floor(toNum(successes.value));
          const n = Math.floor(toNum(trials.value));
          if(!Number.isFinite(n) || n < 1){
            setInvalid(trials, err.trials, 'Trials n must be an integer ≥ 1.');
            ok = false;
          } else clearInvalid(trials, err.trials);
          if(!Number.isFinite(x) || x < 0){
            setInvalid(successes, err.x, 'Successes x must be an integer ≥ 0.');
            ok = false;
          } else if(Number.isFinite(n) && x > n){
            setInvalid(successes, err.x, 'x cannot exceed n.');
            ok = false;
          } else clearInvalid(successes, err.x);
        }
        return ok;
      }

      // Inline validation on blur
      [confLevel, sampleSize, sampleMean, popSD, sampleSD, successes, trials].forEach(inp=>{
        if(!inp) return;
        inp.addEventListener('blur', validate);
      });

      // Data parsing helpers
      function parseData(text){
        if(!text) return [];
        const vals = text.split(/[\s,;]+/).map(v=>v.trim()).filter(Boolean).map(Number).filter(v=>Number.isFinite(v));
        return vals;
      }
      function mean(arr){
        if(arr.length===0) return NaN;
        return arr.reduce((a,b)=>a+b,0)/arr.length;
      }
      function sampleSDUnbiased(arr){
        const n = arr.length;
        if(n<2) return NaN;
        const m = mean(arr);
        const ss = arr.reduce((s, x)=> s + (x-m)*(x-m), 0);
        return Math.sqrt(ss/(n-1));
      }

      rawData.addEventListener('input', ()=>{
        const data = parseData(rawData.value);
        if(data.length){
          const m = mean(data);
          const s = sampleSDUnbiased(data);
          rawDataHint.textContent = `Detected ${data.length} values. x̄ = ${fmt(m, 6)}, s = ${fmt(s, 6)}. These will override manual mean/SD.`;
        } else {
          rawDataHint.textContent = '';
        }
      });

      // Quantile functions
      // Acklam's inverse normal CDF approximation
      function invNormCDF(p){
        if(!(p>0 && p<1)) return NaN;
        const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02,
                   1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
        const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02,
                   6.680131188771972e+01, -1.328068155288572e+01];
        const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00,
                   -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
        const d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00,
                   3.754408661907416e+00];
        const plow = 0.02425, phigh = 1 - plow;
        let q, r;
        if(p < plow){
          q = Math.sqrt(-2*Math.log(p));
          return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) /
                 ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
        if(p > phigh){
          q = Math.sqrt(-2*Math.log(1-p));
          return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) /
                   ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
        q = p - 0.5;
        r = q*q;
        return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q /
               (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
      }

      // Cornish–Fisher approximation for t-quantile from normal quantile
      function invTCDF_CF(p, df){
        if(!(p>0 && p<1) || df<=0) return NaN;
        const z = invNormCDF(p);
        const a = (z*z*z + z) / (4*df);
        const b = (5*z**5 + 16*z**3 + 3*z) / (96*df*df);
        const c = (3*z**7 + 19*z**5 + 17*z**3 - 15*z) / (384*df**3);
        return z + a + b + c;
      }

      // Proportion intervals
      function ciWald(phat, n, z){
        const se = Math.sqrt(phat*(1-phat)/n);
        const me = z*se;
        return { lo: phat - me, hi: phat + me, se, me };
      }
      function ciWilson(x, n, z){
        const phat = x/n;
        const z2 = z*z;
        const denom = 1 + z2/n;
        const center = (phat + z2/(2*n)) / denom;
        const root = Math.sqrt( (phat*(1-phat)/n) + (z2/(4*n*n)) );
        const half = (z*root)/denom;
        const se = Math.sqrt(phat*(1-phat)/n);
        return { lo: center - half, hi: center + half, se, me: half }; // ME reported as half-width on Wilson scale
      }
      function ciAgrestiCoull(x, n, z){
        const z2 = z*z;
        const nTilde = n + z2;
        const pTilde = (x + z2/2) / nTilde;
        const seTilde = Math.sqrt(pTilde*(1-pTilde)/nTilde);
        const me = z*seTilde;
        return { lo: pTilde - me, hi: pTilde + me, se: Math.sqrt((x/n)*(1-x/n)/n), me };
      }

      function calculate(){
        clearErrors();
        if(!validate()){
          announce('Please correct the highlighted fields and try again.');
          return;
        }
        const mode = currentMode();
        const cl = toNum(confLevel.value);
        const alpha = 1 - cl/100;
        const pUpper = 1 - alpha/2;
        let point, se, crit, me, lo, hi, assumption = '';

        if(mode.startsWith('mean')){
          const data = parseData(rawData.value);
          const n = Math.floor(toNum(sampleSize.value)) || data.length;
          let xbar = data.length ? mean(data) : toNum(sampleMean.value);

          if(mode === 'mean-z'){
            const sigma = toNum(popSD.value);
            se = sigma / Math.sqrt(n);
            crit = invNormCDF(pUpper);
            me = Math.abs(crit) * se;
            assumption = 'Assumes known σ and approximately normal sampling distribution (or large n via CLT).';
            resCritHint.textContent = 'z*';
            resPointHint.textContent = 'x̄ (sample mean)';
          } else {
            const s = data.length>1 ? sampleSDUnbiased(data) : toNum(sampleSD.value);
            const df = n - 1;
            se = s / Math.sqrt(n);
            crit = invTCDF_CF(pUpper, df);
            me = Math.abs(crit) * se;
            assumption = `Uses t with df = ${df}. Assumes approximately normal sampling distribution (more robust as n increases).`;
            resCritHint.textContent = 't*';
            resPointHint.textContent = 'x̄ (sample mean)';
          }
          point = xbar;
          lo = point - me;
          hi = point + me;
        } else {
          const x = Math.floor(toNum(successes.value));
          const n = Math.floor(toNum(trials.value));
          const phat = x/n;
          const z = invNormCDF(pUpper);
          const method = (propMethodRadios.find(r=>r.checked)||{}).value || 'wilson';
          resCritHint.textContent = 'z*';
          resPointHint.textContent = 'p̂ (sample proportion)';

          if(method === 'wilson'){
            const r = ciWilson(x, n, z);
            se = r.se; me = (r.hi - r.lo)/2; lo = r.lo; hi = r.hi;
            assumption = 'Wilson score interval (recommended): better coverage, especially for small n or extreme p̂.';
          } else if(method === 'agresti-coull'){
            const r = ciAgrestiCoull(x, n, z);
            se = r.se; me = r.me; lo = r.lo; hi = r.hi;
            assumption = 'Agresti–Coull interval: robust alternative to Wald for proportions.';
          } else {
            const r = ciWald(phat, n, z);
            se = r.se; me = r.me; lo = r.lo; hi = r.hi;
            assumption = 'Wald interval: simple but can underperform when np or n(1−p) are small.';
          }
          point = phat;
        }

        // Clamp proportion bounds [0,1]
        if(currentMode()==='proportion'){
          lo = clamp(lo, 0, 1);
          hi = clamp(hi, 0, 1);
        }

        // Display
        const isProp = currentMode()==='proportion';
        resPoint.textContent = isProp ? fmt(point, 6) : fmt(point, 6);
        resSE.textContent = fmt(se, 6);
        resCrit.textContent = fmt(Math.abs(crit), 6);
        resME.textContent = fmt(me, 6);
        resLo.textContent = fmt(lo, 6);
        resHi.textContent = fmt(hi, 6);
        assumptionNote.textContent = assumption;

        announce('Results updated.');
      }

      function resetForm(){
        // Reset inputs
        confLevel.value = 95;
        modeRadios.forEach(r=>{ r.checked = (r.id==='mode-mean-z'); });
        updateVisibility();
        [sampleSize, sampleMean, popSD, sampleSD, rawData, successes, trials].forEach(inp=>{ if(inp) inp.value=''; });
        propMethodRadios.forEach(r=>{ r.checked = (r.value==='wilson'); });
        clearErrors();
        // Reset results
        [resPoint, resSE, resCrit, resME, resLo, resHi].forEach(el=>el.textContent='—');
        assumptionNote.textContent='';
        resCritHint.textContent='z* or t*';
        resPointHint.textContent='x̄ for mean, p̂ for proportion';
        announce('Form reset.');
      }

      // Live announce for screen readers
      const liveRegion = document.createElement('div');
      liveRegion.setAttribute('aria-live','polite');
      liveRegion.setAttribute('aria-atomic','true');
      liveRegion.className = 'sr-only';
      document.body.appendChild(liveRegion);
      function announce(msg){ liveRegion.textContent = msg; }

      // Bind
      calcBtn.addEventListener('click', calculate);
      resetBtn.addEventListener('click', resetForm);

      // Recalculate on Enter in inputs
      document.getElementById('ci-calculator').addEventListener('keydown', (e)=>{
        if(e.key==='Enter' && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA')){
          e.preventDefault();
          calculate();
        }
      });

      // Optional: auto-calc when inputs change and are valid (debounced)
      let t;
      document.getElementById('ci-calculator').addEventListener('input', ()=>{
        clearTimeout(t);
        t = setTimeout(()=>{
          if(validate()) calculate();
        }, 300);
      });
    })();
  </script>

</body></html>