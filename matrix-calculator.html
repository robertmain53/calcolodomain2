<!DOCTYPE html>
<html lang="en">
<head>
<link rel="canonical" href="https://calcdomain.com/matrix-calculator.html">





  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matrix Calculator — Add, Multiply, Inverse, Determinant & Rank</title>
  <meta name="description" content="Professional matrix calculator for addition, multiplication, determinant, inverse, rank, trace, transpose, and solving linear systems Ax=b. Built for accuracy, speed, and accessibility." />
  

  <!-- Icons (safe fallbacks if not present on the domain) -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />

  <!-- Tailwind (CDN for rapid prototyping; consider self-hosting for production budgets) -->
  <script src="https://cdn.tailwindcss.com" defer></script>
  <!-- Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&display=swap" rel="stylesheet" />
  <!-- MathJax for LaTeX rendering -->
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
          integrity="sha384-vrBq9c8nQxYtO8s7mYv0k1Cz3l9m0c8l4oZp7Nw+zvL7k0aQxtJw9Zqz0PjQKQ2r" crossorigin="anonymous"></script>

  <style>
    :root { --focus: #1d4ed8; }
    html, body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; }
    /* Visible custom focus, WCAG AA */
    :is(button, a, select, input, textarea):focus {
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }
    /* Prose helpers */
    .prose h2 { font-size: 1.375rem; font-weight: 700; margin-top: 1.5rem; margin-bottom: .75rem; }
    .prose h3 { font-size: 1.125rem; font-weight: 700; margin-top: 1rem; margin-bottom: .5rem; }
    .prose p  { margin-bottom: .75rem; line-height: 1.65; }
    .formula-box { background:#f3f4f6; border:1px solid #e5e7eb; border-radius: .75rem; padding: 1rem; overflow:auto; }
    /* Reserve space for results to prevent CLS */
    #results { min-height: 260px; }
    /* Touch targets */
    .touch-target { min-height: 48px; min-width: 48px; }
    /* Matrix table */
    .mx-table { border-collapse: collapse; }
    .mx-table td { border: 1px solid #e5e7eb; padding: .35rem; }
    .mx-bracket::before, .mx-bracket::after {
      content: ""; display: block; position: absolute; top: 0; bottom: 0; width: 6px; border: 2px solid #111827;
    }
    .mx-bracket::before { left: -10px; border-right: 0; }
    .mx-bracket::after  { right: -10px; border-left: 0; }
    @media print {
      header, footer, #aside, #faq-schema, #howto-schema { display: none !important; }
      #print-section { position: absolute; inset: 0; }
    }
  </style>

  <!-- JSON-LD: WebPage + SoftwareApplication (Calculator) -->
  <script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Matrix Calculator",
  "url": "https://calcdomain.com/matrix-calculator.html",
  "inLanguage": "en",
  "description": "Professional matrix calculator for addition, multiplication, determinant, inverse, rank, trace, transpose, and solving linear systems Ax=b.",
  "author": {
    "@type": "Person",
    "name": "Ugo Candido"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CalcDomain"
  },
  "breadcrumb": {
    "@type": "BreadcrumbList",
    "itemListElement": [
      {
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": "https://calcdomain.com/"
      },
      {
        "@type": "ListItem",
        "position": 2,
        "name": "Math & Conversions",
        "item": "https://calcdomain.com/math-conversions.html"
      },
      {
        "@type": "ListItem",
        "position": 3,
        "name": "Algebra",
        "item": "https://calcdomain.com/subcategories/core-math-algebra.html"
      },
      {
        "@type": "ListItem",
        "position": 4,
        "name": "Matrix Calculator",
        "item": "https://calcdomain.com/matrix-calculator.html"
      }
    ]
  },
  "mainEntity": {
    "@type": "SoftwareApplication",
    "name": "Matrix Calculator",
    "applicationCategory": "Calculator",
    "operatingSystem": "Any",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    }
  }
}</script>

  <!-- JSON-LD: FAQPage (will mirror the FAQ below) -->
  <script id="faq-schema" type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      { "@type": "Question", "name": "Which matrix operations does this calculator support?",
        "acceptedAnswer": { "@type": "Answer", "text": "Addition, subtraction, scalar multiplication, transpose, determinant, inverse, rank, trace, matrix multiplication, and solving linear systems Ax=b." } },
      { "@type": "Question", "name": "How do I enter the system Ax=b?",
        "acceptedAnswer": { "@type": "Answer", "text": "Select 'Solve Ax=b', set rows and columns of A, then enter the right-hand side vector b in the dedicated field with the same number of rows as A." } },
      { "@type": "Question", "name": "What if the matrix is singular or nearly singular?",
        "acceptedAnswer": { "@type": "Answer", "text": "The calculator checks the determinant and uses a numerical tolerance. If |det(A)| is below tolerance, the inverse is not computed and a clear error is shown." } },
      { "@type": "Question", "name": "What numeric precision is used?",
        "acceptedAnswer": { "@type": "Answer", "text": "Results are displayed to a configurable number of decimal places (default 6). Internal calculations use double-precision floats." } },
      { "@type": "Question", "name": "Can I multiply non-conformable matrices?",
        "acceptedAnswer": { "@type": "Answer", "text": "No. For A×B to be valid, the columns of A must equal the rows of B. The UI enforces this and provides an explanatory error if not satisfied." } },
      { "@type": "Question", "name": "How is rank computed?",
        "acceptedAnswer": { "@type": "Answer", "text": "Rank is computed via row-reduced echelon form (RREF) with a numerical tolerance to count non-zero pivots." } },
      { "@type": "Question", "name": "Do you support complex numbers?",
        "acceptedAnswer": { "@type": "Answer", "text": "This version supports real numbers. Complex support is on our roadmap." } }
    ]
  }
  </script>

  <!-- JSON-LD: HowTo (step-by-step example) -->
  <script id="howto-schema" type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "HowTo",
    "name": "How to multiply two matrices",
    "description": "Step-by-step example computing C = A×B for 2×2 matrices.",
    "step": [
      {"@type":"HowToStep","name":"Set sizes","text":"Choose operation 'Multiply', set A rows x cols and B rows x cols so that cols(A)=rows(B)."},
      {"@type":"HowToStep","name":"Enter values","text":"Fill the input grids for A and B with numbers."},
      {"@type":"HowToStep","name":"Compute","text":"Press Calculate to get the product C with each entry c_ij = sum_k a_ik b_kj."}
    ]
  }
  </script>
</head>
<body class="bg-gray-50 text-gray-900">
  <!-- Header (non-sticky per requirements) -->
  <header class="bg-white border-b">
    <div class="container mx-auto px-4 lg:px-6 py-4">
      <div class="flex items-center justify-between">
        <a href="index.html" class="text-2xl font-extrabold text-blue-600">CalcDomain</a>
        <nav class="hidden md:flex gap-6 text-sm">
          <a href="search.html" class="hover:text-blue-600">Advanced Search</a>
          Categories
        </nav>
        <button id="mobileMenuBtn" class="md:hidden touch-target p-2" aria-expanded="false" aria-controls="mobileNav" aria-label="Open menu">
          <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
        </button>
      </div>
      <div id="mobileNav" class="hidden md:hidden mt-3">
        <a href="search.html" class="block py-2 hover:text-blue-600">Advanced Search</a>
        Categories
      </div>
    </div>
  </header>

  <main class="container mx-auto px-4 lg:px-6 py-8">
    <!-- Breadcrumb -->
    <nav class="text-sm text-gray-600 mb-4" aria-label="Breadcrumb">
      <a href="index.html" class="hover:text-blue-600">Home</a> &raquo;
      <a href="math.html" class="hover:text-blue-600">Math</a> &raquo;
      <a href="subcategories/core-math-algebra.html" class="hover:text-blue-600">Algebra</a> &raquo;
      <span class="text-gray-900">Matrix Calculator</span>
    </nav>

    <div class="flex flex-col lg:flex-row gap-8">
      <section class="w-full lg:w-2/3">
        <!-- 1) H1 -->
        <h1 class="text-3xl font-extrabold mb-2">Matrix Calculator</h1>

        <!-- 2) Intro -->
        <p class="text-gray-700 mb-6">
          A fast, professional-grade matrix calculator for linear algebra tasks: add, subtract, multiply, compute determinant, inverse, rank, trace, transpose, and solve systems \(A\mathbf{x}=\mathbf{b}\).
          Designed for students, engineers, analysts, and instructors who need accurate results with accessible, mobile-first UX.
        </p>

        <!-- 3) Calculator UI -->
        <section aria-labelledby="calc-title" class="bg-white p-6 rounded-lg shadow-sm" id="print-section">
          <h2 id="calc-title" class="text-xl font-bold mb-4">Calculator</h2>

          <!-- Operation & precision -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div>
              <label for="operation" class="block text-sm font-medium text-gray-800">Operation <span aria-hidden="true" class="text-red-600">*</span></label>
              <div class="flex items-center gap-2">
                <select id="operation" class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                        aria-required="true" aria-describedby="operationHelp operationError">
                  <option value="add">A + B (Addition)</option>
                  <option value="sub">A − B (Subtraction)</option>
                  <option value="scalar">k · A (Scalar Multiply)</option>
                  <option value="transpose">Transpose(A)</option>
                  <option value="det">det(A)</option>
                  <option value="inv">A⁻¹ (Inverse)</option>
                  <option value="rank">rank(A)</option>
                  <option value="trace">trace(A)</option>
                  <option value="mul">A × B (Matrix Multiply)</option>
                  <option value="solve">Solve A·x = b</option>
                </select>
                <button type="button" class="touch-target p-2 rounded border" aria-expanded="false"
                        aria-controls="operationHelp" id="opHelpBtn" title="What does each operation do?">?</button>
              </div>
              <p id="operationHelp" class="text-sm text-gray-600 mt-1 hidden">
                Choose the linear-algebra operation to perform. Binary operations require both A and B. Scalar multiply uses k and A. Solve expects A and a right-hand side vector b.
              </p>
              <p id="operationError" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
            </div>

            <div>
              <label for="precision" class="block text-sm font-medium text-gray-800">Decimal Precision</label>
              <input id="precision" type="number" min="0" max="12" value="6"
                     class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                     aria-describedby="precisionHelp" />
              <p id="precisionHelp" class="text-sm text-gray-600 mt-1">Number of decimal places in displayed results.</p>
            </div>
          </div>

          <!-- Sizes -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <fieldset class="border border-gray-200 rounded-md p-4">
              <legend class="font-semibold">Matrix A size</legend>
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label for="rowsA" class="block text-sm font-medium text-gray-800">Rows (m) <span class="text-red-600" aria-hidden="true">*</span></label>
                  <input id="rowsA" type="number" min="1" max="8" value="2" class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                         aria-required="true" aria-describedby="rowsAErr" />
                  <p id="rowsAErr" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
                </div>
                <div>
                  <label for="colsA" class="block text-sm font-medium text-gray-800">Cols (n) <span class="text-red-600" aria-hidden="true">*</span></label>
                  <input id="colsA" type="number" min="1" max="8" value="2" class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                         aria-required="true" aria-describedby="colsAErr" />
                  <p id="colsAErr" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
                </div>
              </div>
            </fieldset>

            <fieldset class="border border-gray-200 rounded-md p-4" id="sizeBGroup">
              <legend class="font-semibold">Matrix B size (only if needed)</legend>
              <div class="grid grid-cols-2 gap-4">
                <div>
                  <label for="rowsB" class="block text-sm font-medium text-gray-800">Rows</label>
                  <input id="rowsB" type="number" min="1" max="8" value="2" class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                         aria-describedby="rowsBErr" />
                  <p id="rowsBErr" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
                </div>
                <div>
                  <label for="colsB" class="block text-sm font-medium text-gray-800">Cols</label>
                  <input id="colsB" type="number" min="1" max="8" value="2" class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                         aria-describedby="colsBErr" />
                  <p id="colsBErr" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
                </div>
              </div>
            </fieldset>
          </div>

          <!-- Scalar k & RHS b -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div id="scalarGroup" class="hidden">
              <label for="scalarK" class="block text-sm font-medium text-gray-800">Scalar k</label>
              <input id="scalarK" type="number" value="2" step="any"
                     class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                     aria-describedby="scalarHelp scalarErr" />
              <p id="scalarHelp" class="text-sm text-gray-600 mt-1">Used only in k · A.</p>
              <p id="scalarErr" class="text-sm text-red-700 mt-1"></p>
            </div>

            <div id="rhsGroup" class="hidden">
              <label for="rhsB" class="block text-sm font-medium text-gray-800">Right-hand side vector b (Solve A·x=b)</label>
              <textarea id="rhsB" rows="3" placeholder="Enter m numbers (one per line or space-separated)"
                        class="mt-1 w-full border border-gray-300 rounded-md px-3 py-2 touch-target"
                        aria-describedby="rhsHelp rhsErr"></textarea>
              <p id="rhsHelp" class="text-sm text-gray-600 mt-1">Provide as m entries matching A's rows, separated by spaces or newlines.</p>
              <p id="rhsErr" class="text-sm text-red-700 mt-1"></p>
            </div>
          </div>

          <!-- Grids -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
            <div>
              <div class="flex items-center justify-between">
                <label class="block text-sm font-medium text-gray-800">Matrix A values <span class="text-red-600" aria-hidden="true">*</span></label>
                <div class="flex gap-2">
                  <button type="button" class="touch-target px-3 py-1 border rounded" id="fillAId">Identity</button>
                  <button type="button" class="touch-target px-3 py-1 border rounded" id="fillARand">Random</button>
                  <button type="button" class="touch-target px-3 py-1 border rounded" id="clearA">Clear</button>
                </div>
              </div>
              <div id="gridA" class="mt-2 overflow-x-auto"></div>
              <p id="gridAErr" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
            </div>

            <div id="gridBWrapper">
              <div class="flex items-center justify-between">
                <label class="block text-sm font-medium text-gray-800">Matrix B values</label>
                <div class="flex gap-2">
                  <button type="button" class="touch-target px-3 py-1 border rounded" id="fillBId">Identity</button>
                  <button type="button" class="touch-target px-3 py-1 border rounded" id="fillBRand">Random</button>
                  <button type="button" class="touch-target px-3 py-1 border rounded" id="clearB">Clear</button>
                </div>
              </div>
              <div id="gridB" class="mt-2 overflow-x-auto"></div>
              <p id="gridBErr" class="text-sm text-red-700 mt-1" aria-live="polite"></p>
            </div>
          </div>

          <!-- Actions -->
          <div class="flex flex-wrap gap-3">
            <button id="computeBtn" class="touch-target px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Calculate</button>
            <button id="swapBtn" class="touch-target px-4 py-2 border rounded">Swap A ↔ B</button>
            <button id="resetBtn" class="touch-target px-4 py-2 border rounded">Reset</button>
            <button id="copyBtn" class="touch-target px-4 py-2 border rounded">Copy result as LaTeX</button>
          </div>
        </section>

        <!-- 4) Results -->
        <section class="mt-6 bg-blue-50 border border-blue-100 rounded-lg p-6" id="results" aria-live="polite">
          <h2 class="text-xl font-bold mb-2">Results</h2>
          <div id="resultSummary" class="text-gray-800"></div>
          <div id="resultMatrices" class="mt-3 grid grid-cols-1 md:grid-cols-2 gap-6"></div>
          <pre id="resultLatex" class="mt-4 whitespace-pre-wrap text-sm text-gray-700 hidden"></pre>
        </section>

        <!-- 5) Authoritative Content Ecosystem -->
        <section class="bg-white p-6 rounded-lg shadow-sm mt-8 prose">
          <h2>Data Source and Methodology</h2>
          <p>
            Authoritative reference: <strong>Gilbert Strang, <em>Introduction to Linear Algebra</em></strong> (MIT),
            and MIT OpenCourseWare 18.06 <em>Linear Algebra</em> lecture notes.
            All computational methods (Gaussian elimination, RREF for rank, LU-compatible steps, standard definitions for det/trace/transpose)
            follow these sources. <a href="https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/" rel="noopener">MIT OCW 18.06</a>.
          </p>
          <p><em>All calculations strictly follow the formulas and definitions provided by these sources.</em></p>

          <h2>The Formula Explained</h2>
          <div class="formula-box">
            <p><strong>Matrix product</strong>: \( (A B)_{ij} = \sum_{k=1}^{n} a_{ik} b_{kj} \).</p>
            <p><strong>Determinant (Laplace / elimination)</strong>: for \(A \in \mathbb{R}^{n\times n}\), \(\det(A)\) equals the product of pivots in LU (with sign adjustments for row swaps).</p>
            <p><strong>Inverse</strong>: \( A^{-1} \) exists iff \( \det(A) \neq 0 \). Compute via augmented matrix \([A\,|\,I]\) and row-reduce to \([I\,|\,A^{-1}]\).</p>
            <p><strong>Rank</strong>: number of pivots in the RREF of \(A\).</p>
            <p><strong>Trace</strong>: \( \mathrm{tr}(A) = \sum_{i=1}^{n} a_{ii} \).</p>
            <p><strong>Solving \(A\mathbf{x}=\mathbf{b}\)</strong>: perform elimination on \([A\,|\,\mathbf{b}]\) to obtain a solution if consistent; uniqueness if \(\mathrm{rank}(A)=n\).</p>
          </div>

          <h2>Glossary of Variables</h2>
          <ul>
            <li><strong>A, B</strong>: input matrices.</li>
            <li><strong>m, n, p</strong>: matrix dimensions (rows, cols).</li>
            <li><strong>k</strong>: scalar multiplier.</li>
            <li><strong>\(\det(A)\)</strong>: determinant of square matrix \(A\).</li>
            <li><strong>\(A^{-1}\)</strong>: inverse of \(A\), when it exists.</li>
            <li><strong>\(\mathrm{rank}(A)\)</strong>: number of linearly independent rows/columns.</li>
            <li><strong>\(\mathrm{tr}(A)\)</strong>: sum of diagonal entries of \(A\).</li>
            <li><strong>\(\mathbf{b}\)</strong>: right-hand side vector in \(A\mathbf{x}=\mathbf{b}\).</li>
          </ul>

          <h2 id="worked-example">How It Works: A Step-by-Step Example</h2>
          <p>Compute \(C=A\times B\) with \(A=\begin{bmatrix}1&2\\3&4\end{bmatrix}\) and \(B=\begin{bmatrix}5&6\\7&8\end{bmatrix}\).</p>
          <p>For \(c_{11}\): \(1\cdot5 + 2\cdot7 = 19\). Similarly, \(c_{12}=1\cdot6+2\cdot8=22\), \(c_{21}=3\cdot5+4\cdot7=43\), \(c_{22}=3\cdot6+4\cdot8=50\).</p>
          <p>Therefore, \(C=\begin{bmatrix}19&22\\43&50\end{bmatrix}\).</p>

          <h2>Frequently Asked Questions</h2>
          <details><summary>Which operations are supported?</summary><p>Addition, subtraction, scalar multiply, transpose, determinant, inverse, rank, trace, multiplication, and solving \(A\mathbf{x}=\mathbf{b}\).</p></details>
          <details><summary>How do I enter \(b\) for \(A\mathbf{x}=\mathbf{b}\)?</summary><p>Choose “Solve A·x=b”, set A’s size, then paste the vector \(b\) with exactly \(m\) numbers (one per line or space-separated).</p></details>
          <details><summary>Why can’t I invert my matrix?</summary><p>If \(|\det(A)|\) is below tolerance, \(A\) is singular or nearly singular, so we don’t compute the inverse to avoid unstable results.</p></details>
          <details><summary>What tolerance is used?</summary><p>By default \(10^{-10}\) for pivot/zero checks; you can still view results rounded to your chosen display precision.</p></details>
          <details><summary>Do you support complex numbers?</summary><p>Currently real numbers only; complex support is planned.</p></details>

          <div class="mt-6 p-4 bg-gray-50 border border-gray-200 rounded-lg text-sm text-gray-700">
            <p><strong>Tool developed by Ugo Candido.</strong> Content verified by CalcDomain Editorial Board.<br>
            Last accuracy review: <time datetime="2025-10-25">October 25, 2025</time></p>
          </div>
        </section>
      </section>

      <!-- Aside -->
      <aside id="aside" class="w-full lg:w-1/3">
        <div class="sticky top-6 space-y-6">
          <div class="bg-white rounded-lg shadow-sm p-6">
            <h3 class="font-bold text-lg mb-3">Why this matrix calculator</h3>
            <ul class="list-disc list-inside text-sm text-gray-700 space-y-2">
              <li>Accurate elimination-based algorithms with numerical tolerances.</li>
              <li>Mobile-first grid editor with accessible validation.</li>
              <li>Copy results as LaTeX for reports or homework.</li>
            </ul>
          </div>
          <div class="bg-gray-200 h-64 rounded-lg flex items-center justify-center text-gray-500">Ad Placement (300×250)</div>
        </div>
      </aside>
    </div>
  </main>

  <footer class="bg-white border-t">
    <div class="container mx-auto px-4 lg:px-6 py-8 text-center text-gray-600 text-sm">
      <p>&copy; 2025 CalcDomain. All Rights Reserved.</p>
      <div class="mt-3 space-x-4">
        <a href="about.html" class="hover:text-blue-600">About</a>
        <a href="contact.html" class="hover:text-blue-600">Contact</a>
        <a href="privacy.html" class="hover:text-blue-600">Privacy</a>
        <a href="terms.html" class="hover:text-blue-600">Terms</a>
      </div>
    </div>
  </footer>

  <!-- Calculator Logic (all scripts deferred and placed before </body>) -->
  <script defer>
  (function () {
    // Utility
    const $ = (id) => document.getElementById(id);
    const opSel = $('operation');
    const opHelpBtn = $('opHelpBtn');
    const mobileMenuBtn = $('mobileMenuBtn');
    const mobileNav = $('mobileNav');

    const rowsA = $('rowsA'), colsA = $('colsA'), rowsB = $('rowsB'), colsB = $('colsB');
    const gridA = $('gridA'), gridB = $('gridB'), gridBWrapper = $('gridBWrapper');
    const sizeBGroup = $('sizeBGroup'), scalarGroup = $('scalarGroup'), rhsGroup = $('rhsGroup');
    const scalarK = $('scalarK'), rhsB = $('rhsB');

    const precisionEl = $('precision');
    const computeBtn = $('computeBtn'), swapBtn = $('swapBtn'), resetBtn = $('resetBtn'), copyBtn = $('copyBtn');

    const resultSummary = $('resultSummary'), resultMatrices = $('resultMatrices'), resultLatex = $('resultLatex');

    const gridAErr = $('gridAErr'), gridBErr = $('gridBErr');
    const rowsAErr = $('rowsAErr'), colsAErr = $('colsAErr'), rowsBErr = $('rowsBErr'), colsBErr = $('colsBErr');
    const operationError = $('operationError'), scalarErr = $('scalarErr'), rhsErr = $('rhsErr');

    const fillAId = $('fillAId'), fillARand = $('fillARand'), clearA = $('clearA');
    const fillBId = $('fillBId'), fillBRand = $('fillBRand'), clearB = $('clearB');

    // Accessibility toggles
    mobileMenuBtn?.addEventListener('click', () => {
      const open = mobileNav.classList.toggle('hidden') ? 'false' : 'true';
      mobileMenuBtn.setAttribute('aria-expanded', open);
    });
    opHelpBtn?.addEventListener('click', () => {
      const help = $('operationHelp');
      const nowOpen = help.classList.toggle('hidden') ? 'false' : 'true';
      opHelpBtn.setAttribute('aria-expanded', nowOpen);
    });

    // Matrix grid generation
    function buildGrid(container, r, c, namePrefix) {
      container.innerHTML = '';
      const table = document.createElement('table');
      table.className = 'mx-table relative mx-auto';
      const tbody = document.createElement('tbody');
      for (let i = 0; i < r; i++) {
        const tr = document.createElement('tr');
        for (let j = 0; j < c; j++) {
          const td = document.createElement('td');
          const input = document.createElement('input');
          input.type = 'number'; input.step = 'any';
          input.className = 'w-20 md:w-24 px-2 py-2 border border-gray-300 rounded touch-target';
          input.id = `${namePrefix}_${i}_${j}`;
          input.setAttribute('aria-label', `${namePrefix} row ${i+1} col ${j+1}`);
          input.addEventListener('blur', () => { /* inline validation placeholder: numeric enforced by type=number */ });
          td.appendChild(input);
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      const wrap = document.createElement('div');
      wrap.className = 'relative inline-block p-4';
      wrap.appendChild(table);
      // decorative brackets
      const bracket = document.createElement('div');
      bracket.className = 'mx-bracket absolute inset-y-4 left-0 right-0 pointer-events-none';
      wrap.appendChild(bracket);
      container.appendChild(wrap);
    }

    function parseGrid(container, r, c, prefix, errEl) {
      const M = new Array(r).fill(0).map(() => new Array(c).fill(0));
      for (let i = 0; i < r; i++) {
        for (let j = 0; j < c; j++) {
          const el = $(`${prefix}_${i}_${j}`);
          const v = el && el.value !== '' ? Number(el.value) : 0;
          if (Number.isNaN(v)) {
            errEl.textContent = `Entry (${i+1}, ${j+1}) is not a valid number.`;
            el?.focus();
            return null;
          }
          M[i][j] = v;
        }
      }
      errEl.textContent = '';
      return M;
    }

    function setGrid(M, container, prefix) {
      const r = M.length, c = M[0].length;
      buildGrid(container, r, c, prefix);
      for (let i = 0; i < r; i++) for (let j = 0; j < c; j++) {
        $(`${prefix}_${i}_${j}`).value = M[i][j];
      }
    }

    function eye(n) {
      const I = Array.from({length: n}, (_, i) =>
        Array.from({length: n}, (_, j) => i===j ? 1 : 0));
      return I;
    }

    function rand(r, c) {
      return Array.from({length: r}, () =>
        Array.from({length: c}, () => +(Math.random()*4 - 2).toFixed(2)));
    }

    // Linear algebra helpers
    const tol = 1e-10;

    function clone(M){ return M.map(row => row.slice()); }

    function transpose(A) {
      const m = A.length, n = A[0].length;
      const T = Array.from({length: n}, () => Array(m).fill(0));
      for (let i=0;i<m;i++) for (let j=0;j<n;j++) T[j][i] = A[i][j];
      return T;
    }

    function add(A,B,sgn=1){
      const m=A.length,n=A[0].length; const C=Array.from({length:m},()=>Array(n).fill(0));
      for (let i=0;i<m;i++) for (let j=0;j<n;j++) C[i][j]=A[i][j]+sgn*B[i][j];
      return C;
    }

    function scalarMul(k,A){ return A.map(r=>r.map(x=>k*x)); }

    function mul(A,B){
      const m=A.length, n=A[0].length, p=B[0].length;
      const C=Array.from({length:m},()=>Array(p).fill(0));
      for(let i=0;i<m;i++){
        for(let k=0;k<n;k++){
          const aik=A[i][k];
          for(let j=0;j<p;j++) C[i][j]+=aik*B[k][j];
        }
      }
      return C;
    }

    function trace(A){ let s=0; for (let i=0;i<Math.min(A.length,A[0].length);i++) s+=A[i][i]; return s; }

    function det(A) {
      // LU via partial pivoting (returns det and U; modifies a clone)
      const n=A.length; let M=clone(A); let sign=1; let det=1;
      for(let k=0;k<n;k++){
        // pivot
        let piv=k;
        for(let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[piv][k])) piv=i;
        if (Math.abs(M[piv][k])<tol) return 0;
        if (piv!==k){ [M[piv],M[k]]=[M[k],M[piv]]; sign*=-1; }
        const pivot=M[k][k];
        det*=pivot;
        for(let i=k+1;i<n;i++){
          const f=M[i][k]/pivot;
          for(let j=k;j<n;j++) M[i][j]-=f*M[k][j];
        }
      }
      return sign*det;
    }

    function inverse(A){
      const n=A.length; let M=clone(A);
      let I=eye(n);
      // Gauss-Jordan
      for(let k=0;k<n;k++){
        // pivot
        let piv=k;
        for(let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[piv][k])) piv=i;
        if (Math.abs(M[piv][k])<tol) return null;
        if (piv!==k){ [M[piv],M[k]]=[M[k],M[piv]]; [I[piv],I[k]]=[I[k],I[piv]]; }
        // normalize row
        const pivot=M[k][k];
        for(let j=0;j<n;j++){ M[k][j]/=pivot; I[k][j]/=pivot; }
        // eliminate others
        for(let i=0;i<n;i++){
          if(i===k) continue;
          const f=M[i][k];
          if (Math.abs(f)<tol) continue;
          for(let j=0;j<n;j++){ M[i][j]-=f*M[k][j]; I[i][j]-=f*I[k][j]; }
        }
      }
      return I;
    }

    function rref(Min) {
      let M = clone(Min);
      const m=M.length, n=M[0].length;
      let lead=0, rank=0;
      for(let r=0;r<m;r++){
        if (lead>=n) return {R:M, rank};
        let i=r;
        while (Math.abs(M[i][lead])<tol){
          i++; if (i===m){ i=r; lead++; if (lead===n) return {R:M, rank}; }
        }
        // swap
        [M[i],M[r]]=[M[r],M[i]];
        // normalize
        const lv=M[r][lead];
        for(let j=0;j<n;j++) M[r][j]/=lv;
        // eliminate
        for(let i2=0;i2<m;i2++){
          if(i2!==r){
            const lv2=M[i2][lead];
            for(let j=0;j<n;j++) M[i2][j]-=lv2*M[r][j];
          }
        }
        rank++;
        lead++;
      }
      return {R:M, rank};
    }

    function solve(A,b){
      // Solve via Gauss elimination on augmented [A|b]
      const m=A.length, n=A[0].length;
      let M = A.map((row,i)=> row.concat([b[i]]));
      // forward elimination
      let r=0;
      for (let c=0;c<n && r<m;c++){
        // pivot
        let piv=r;
        for(let i=r+1;i<m;i++) if (Math.abs(M[i][c])>Math.abs(M[piv][c])) piv=i;
        if (Math.abs(M[piv][c])<tol) continue;
        if (piv!==r) [M[piv],M[r]]=[M[r],M[piv]];
        // normalize
        const pv=M[r][c];
        for(let j=c;j<=n;j++) M[r][j]/=pv;
        // eliminate
        for(let i=0;i<m;i++){
          if (i===r) continue;
          const f=M[i][c];
          for(let j=c;j<=n;j++) M[i][j]-=f*M[r][j];
        }
        r++;
      }
      // check consistency and read solution
      // if unique solution: last n columns is identity
      const x=new Array(n).fill(0);
      for(let i=0;i<m;i++){
        let leadIdx = M[i].findIndex(v=>Math.abs(v)>tol);
        if (leadIdx===-1) continue; // zero row
        if (leadIdx===n){ return { status:'inconsistent', x:null, R:M }; } // 0 ... | nonzero
      }
      // unique solution if rank==n
      const rankA = rref(A).rank, rankAb = rref(M.map(row=>row.slice(0,n))).rank; // quick ranks
      if (rankA < n) {
        return { status:'underdetermined', x:null, R:M };
      }
      // read x from reduced form
      for(let i=0;i<n;i++){
        // Find row with pivot in column i
        let row = M.find(row => Math.abs(row[i]-1)<1e-7 && row.slice(0,n).filter((v,idx)=>idx!==i && Math.abs(v)>1e-7).length===0);
        if (!row) { // fallback: search
          for (let r2=0;r2<m;r2++) if (Math.abs(M[r2][i])>0.5 && Math.abs(M[r2][i]-1)<1e-6) { row = M[r2]; break; }
        }
        x[i]= row ? row[n] : 0;
      }
      return { status:'ok', x, R:M };
    }

    // UI State management
    function updateVisibility() {
      const op = opSel.value;
      const needsB = (op==='add' || op==='sub' || op==='mul');
      sizeBGroup.classList.toggle('hidden', !needsB);
      gridBWrapper.classList.toggle('hidden', !needsB);
      scalarGroup.classList.toggle('hidden', op!=='scalar');
      rhsGroup.classList.toggle('hidden', op!=='solve');
    }

    function syncConformability() {
      if (opSel.value==='mul') {
        rowsB.value = colsA.value;
      }
      if (opSel.value==='add' || opSel.value==='sub') {
        rowsB.value = rowsA.value; colsB.value = colsA.value;
      }
      rebuildGrids();
    }

    function rebuildGrids() {
      const mA = clampInt(rowsA.value,1,8), nA = clampInt(colsA.value,1,8);
      rowsA.value = mA; colsA.value = nA;
      buildGrid(gridA, mA, nA, 'A');

      const mB = clampInt(rowsB.value,1,8), nB = clampInt(colsB.value,1,8);
      rowsB.value = mB; colsB.value = nB;
      buildGrid(gridB, mB, nB, 'B');
    }

    function clampInt(v,min,max){ v = parseInt(v||min,10); return Math.max(min, Math.min(max, v)); }

    // Inline validation on blur for size fields
    [rowsA, colsA, rowsB, colsB].forEach(inp => {
      inp.addEventListener('blur', () => {
        const v = parseInt(inp.value,10);
        const errEl = ({rowsA:rowsAErr, colsA:colsAErr, rowsB:rowsBErr, colsB:colsBErr})[inp.id];
        if (Number.isNaN(v) || v<1 || v>8) {
          errEl.textContent = 'Enter an integer between 1 and 8.';
        } else {
          errEl.textContent = '';
        }
      });
      inp.addEventListener('change', syncConformability);
    });

    opSel.addEventListener('change', () => { updateVisibility(); syncConformability(); });

    // Fill helpers
    fillAId.addEventListener('click', () => {
      const n = Math.min(clampInt(rowsA.value,1,8), clampInt(colsA.value,1,8));
      setGrid(eye(n), gridA, 'A');
    });
    fillARand.addEventListener('click', () => setGrid(rand(clampInt(rowsA.value,1,8), clampInt(colsA.value,1,8)), gridA, 'A'));
    clearA.addEventListener('click', () => setGrid(Array.from({length:clampInt(rowsA.value,1,8)},()=>Array(clampInt(colsA.value,1,8)).fill(0)), gridA, 'A'));

    fillBId.addEventListener('click', () => {
      const n = Math.min(clampInt(rowsB.value,1,8), clampInt(colsB.value,1,8));
      setGrid(eye(n), gridB, 'B');
    });
    fillBRand.addEventListener('click', () => setGrid(rand(clampInt(rowsB.value,1,8), clampInt(colsB.value,1,8)), gridB, 'B'));
    clearB.addEventListener('click', () => setGrid(Array.from({length:clampInt(rowsB.value,1,8)},()=>Array(clampInt(colsB.value,1,8)).fill(0)), gridB, 'B'));

    swapBtn.addEventListener('click', () => {
      const A = parseGrid(gridA, clampInt(rowsA.value,1,8), clampInt(colsA.value,1,8), 'A', gridAErr);
      const B = parseGrid(gridB, clampInt(rowsB.value,1,8), clampInt(colsB.value,1,8), 'B', gridBErr);
      if (!A || !B) return;
      const rA=rowsA.value, cA=colsA.value;
      rowsA.value = rowsB.value; colsA.value = colsB.value;
      rowsB.value = rA; colsB.value = cA;
      setGrid(B, gridA, 'A');
      setGrid(A, gridB, 'B');
      updateVisibility();
    });

    resetBtn.addEventListener('click', () => {
      opSel.value = 'mul';
      rowsA.value = 2; colsA.value = 2; rowsB.value = 2; colsB.value = 2;
      precisionEl.value = 6; scalarK.value = 2; rhsB.value='';
      updateVisibility(); rebuildGrids();
      resultSummary.innerHTML = ''; resultMatrices.innerHTML = ''; resultLatex.textContent=''; resultLatex.classList.add('hidden');
      [gridAErr, gridBErr, rowsAErr, colsAErr, rowsBErr, colsBErr, operationError, scalarErr, rhsErr].forEach(e=>e.textContent='');
    });

    copyBtn.addEventListener('click', async () => {
      const text = resultLatex.textContent || '';
      try {
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = 'Copied!';
        setTimeout(()=> copyBtn.textContent='Copy result as LaTeX', 1200);
      } catch { /* ignore */ }
    });

    computeBtn.addEventListener('click', () => {
      const op = opSel.value;
      const mA = clampInt(rowsA.value,1,8), nA = clampInt(colsA.value,1,8);
      const A = parseGrid(gridA, mA, nA, 'A', gridAErr);
      if (!A) return;

      const prec = clampInt(precisionEl.value,0,12);
      const fmt = (x)=> Number(x).toFixed(prec).replace(/-0\.0+$/,'0');

      let resSummary = '';
      let resLatex = '';
      let resMatricesHTML = '';

      function renderMatrix(M, label){
        // HTML
        const table = document.createElement('table'); table.className='mx-table';
        const tbody = document.createElement('tbody');
        for (const row of M){
          const tr = document.createElement('tr');
          for (const x of row){
            const td = document.createElement('td'); td.textContent = fmt(x);
            tr.appendChild(td);
          }
          tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        const wrap = document.createElement('div'); wrap.className='relative inline-block p-4';
        const bracket = document.createElement('div'); bracket.className='mx-bracket absolute inset-y-4 left-0 right-0 pointer-events-none';
        const title = document.createElement('div'); title.className='font-semibold mb-2'; title.textContent = label;
        wrap.appendChild(title); wrap.appendChild(table); wrap.appendChild(bracket);
        return wrap.outerHTML;
      }

      function latexOf(M, name) {
        const body = M.map(r => r.map(x=> fmt(x)).join(' & ')).join(' \\\\ ');
        return `\\[ ${name}=\\begin{bmatrix} ${body} \\end{bmatrix} \\]`;
      }

      // Branch per operation
      if (op==='add' || op==='sub' || op==='mul') {
        const mB=clampInt(rowsB.value,1,8), nB=clampInt(colsB.value,1,8);
        const B=parseGrid(gridB,mB,nB,'B',gridBErr); if(!B) return;

        if (op!=='mul' && (mA!==mB || nA!==nB)) {
          operationError.textContent = 'For A±B, A and B must have identical dimensions.';
          return;
        } else { operationError.textContent=''; }

        if (op==='mul' && nA!==mB) {
          operationError.textContent = 'For A×B, cols(A) must equal rows(B).';
          return;
        } else { operationError.textContent=''; }

        let C, sym;
        if (op==='add'){ C = add(A,B, +1); sym = 'A+B'; resSummary='Computed A + B.'; }
        if (op==='sub'){ C = add(A,B, -1); sym = 'A-B'; resSummary='Computed A − B.'; }
        if (op==='mul'){ C = mul(A,B);      sym = 'AB';  resSummary='Computed A × B.'; }

        resultSummary.innerHTML = `<p class="mb-2"><strong>${resSummary}</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(op==='mul'?B:B,'B') + renderMatrix(C, sym);
        resLatex = latexOf(A,'A') + '\n' + (op!=='mul' ? latexOf(B,'B') : latexOf(B,'B')) + `\n\\[ ${sym}=A${op==='mul'?'\\,B':(op==='add'?'+':'-')+'B'} \\]` + '\n' + latexOf(C, sym);
      }

      if (op==='scalar') {
        const k = Number(scalarK.value);
        if (Number.isNaN(k)) { scalarErr.textContent='Enter a valid scalar k.'; return; } else { scalarErr.textContent=''; }
        const C = scalarMul(k, A);
        resultSummary.innerHTML = `<p class="mb-2"><strong>Computed k·A with k=${fmt(k)}.</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(C,'k·A');
        resLatex = latexOf(A,'A') + `\n\\[ k=${fmt(k)} \\]\n` + latexOf(C,'kA');
      }

      if (op==='transpose') {
        const T = transpose(A);
        resultSummary.innerHTML = `<p class="mb-2"><strong>Computed transpose(A).</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(T,'Aᵀ');
        resLatex = latexOf(A,'A') + '\n\\[ A^{\\mathsf{T}} \\]\n' + latexOf(T,'A^{\\mathsf{T}}');
      }

      if (op==='det') {
        if (mA!==nA) { operationError.textContent='det(A) requires A to be square.'; return; } else { operationError.textContent=''; }
        const d = det(A);
        resultSummary.innerHTML = `<p class="mb-2"><strong>det(A) = ${fmt(d)}</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A');
        resLatex = latexOf(A,'A') + `\n\\[ \\det(A) = ${fmt(d)} \\]`;
      }

      if (op==='inv') {
        if (mA!==nA) { operationError.textContent='A⁻¹ requires A to be square.'; return; } else { operationError.textContent=''; }
        const d = det(A);
        if (Math.abs(d)<tol) { operationError.textContent='A is singular or near-singular (|det(A)| < tolerance). Inverse not computed.'; return; }
        const Ai = inverse(A);
        if (!Ai) { operationError.textContent='Inverse failed due to numerical instability.'; return; }
        resultSummary.innerHTML = `<p class="mb-2"><strong>Computed A⁻¹ (det(A) = ${fmt(d)}).</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(Ai,'A⁻¹');
        resLatex = latexOf(A,'A') + `\n\\[ A^{-1} \\]\n` + latexOf(Ai,'A^{-1}');
      }

      if (op==='rank') {
        const {R, rank} = rref(A);
        resultSummary.innerHTML = `<p class="mb-2"><strong>rank(A) = ${rank}</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(R,'RREF(A)');
        resLatex = latexOf(A,'A') + `\n\\[ \\mathrm{rank}(A) = ${rank} \\]` + '\n' + latexOf(R,'\\mathrm{RREF}(A)');
      }

      if (op==='trace') {
        if (mA!==nA) { operationError.textContent='trace(A) requires A to be square.'; return; } else { operationError.textContent=''; }
        const tr = trace(A);
        resultSummary.innerHTML = `<p class="mb-2"><strong>trace(A) = ${fmt(tr)}</strong></p>`;
        resultMatrices.innerHTML = renderMatrix(A,'A');
        resLatex = latexOf(A,'A') + `\n\\[ \\mathrm{tr}(A) = ${fmt(tr)} \\]`;
      }

      if (op==='solve') {
        if (mA===0 || nA===0) { operationError.textContent='Set a valid size for A.'; return; } else { operationError.textContent=''; }
        // Parse b
        const nums = rhsB.value.trim().split(/[\s,;]+/).filter(Boolean).map(Number);
        if (nums.length !== mA || nums.some(n=>Number.isNaN(n))) {
          rhsErr.textContent = `b must have exactly ${mA} numeric entr${mA===1?'y':'ies'}.`;
          return;
        } else { rhsErr.textContent=''; }
        const res = solve(A, nums);
        if (res.status==='inconsistent') {
          resultSummary.innerHTML = `<p class="mb-2 text-red-700"><strong>The system is inconsistent (no solution).</strong></p>`;
          resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(nums.map(x=>[x]),'b (as column)');
          resLatex = latexOf(A,'A') + '\n' + latexOf(nums.map(x=>[x]),'\\mathbf{b}') + '\n\\[ \\text{No solution} \\]';
        } else if (res.status==='underdetermined') {
          resultSummary.innerHTML = `<p class="mb-2 text-orange-700"><strong>Infinitely many solutions (rank(A) &lt; n). Provide additional constraints.</strong></p>`;
          resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(nums.map(x=>[x]),'b (as column)');
          resLatex = latexOf(A,'A') + '\n' + latexOf(nums.map(x=>[x]),'\\mathbf{b}') + '\n\\[ \\text{Infinitely many solutions} \\]';
        } else {
          const xcol = res.x.map(v=>[v]);
          resultSummary.innerHTML = `<p class="mb-2"><strong>Unique solution x found.</strong></p>`;
          resultMatrices.innerHTML = renderMatrix(A,'A') + renderMatrix(nums.map(x=>[x]),'b (as column)') + renderMatrix(xcol,'x');
          resLatex = latexOf(A,'A') + '\n' + latexOf(nums.map(x=>[x]),'\\mathbf{b}') + '\n' + latexOf(xcol,'\\mathbf{x}');
        }
      }

      resultLatex.textContent = resLatex;
      resultLatex.classList.remove('hidden');
      // Ensure MathJax renders
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
    });

    // Init
    updateVisibility();
    rebuildGrids();
    // Preload friendly example
    setGrid([[1,2],[3,4]], gridA, 'A');
    setGrid([[5,6],[7,8]], gridB, 'B');
  })();
  </script>
</body>
</html>
