<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Kruskal's Algorithm Calculator – Minimum Spanning Tree (MST) Solver</title>
    <meta name="description" content="Use this free Kruskal's algorithm calculator to compute minimum spanning trees (MST) step-by-step from a weighted graph. Enter edges, see which edges are added or skipped, and get total MST cost.">
    <link rel="canonical" href="https://calcdomain.com/kruskal-s-algorithm-calculator">
    
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .card-hover { transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        .card-hover:hover { transform: translateY(-5px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .prose { max-width: 65ch; margin-left: auto; margin-right: auto; }
        .prose h2 { font-size: 1.5rem; font-weight: 600; margin-top: 2rem; margin-bottom: 1rem; }
        .prose h3 { font-size: 1.25rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .prose p { margin-bottom: 1rem; line-height: 1.6; }
        .prose ul, .prose ol { margin-left: 1.5rem; margin-bottom: 1rem; }
        .prose li { margin-bottom: 0.5rem; }
        .formula-box { background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 8px; padding: 1rem; overflow-x: auto; margin: 1rem 0; }
    </style>
    
    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-7MB5V1LZRN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7MB5V1LZRN');
    </script>

    <meta name="google-site-verification" content="_tiTZ9ivAdtXcAS9CMnTNJ549Sg39WVqP_ZFbWgglNA">

    <script src="https://cmp.gatekeeperconsent.com/min.js" data-cfasync="false"></script>
    <script src="https://the.gatekeeperconsent.com/cmp.min.js" data-cfasync="false"></script>

    <script async="" src="//www.ezojs.com/ezoic/sa.min.js"></script>
    <script>
        window.ezstandalone = window.ezstandalone || {};
        ezstandalone.cmd = ezstandalone.cmd || [];
    </script>

    <script type="application/ld+json">
[
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      {
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": "https://calcdomain.com"
      },
      {
        "@type": "ListItem",
        "position": 2,
        "name": "Engineering",
        "item": "https://calcdomain.com/categories/engineering"
      },
      {
        "@type": "ListItem",
        "position": 3,
        "name": "Electrical",
        "item": "https://calcdomain.com/subcategories/electrical"
      }
    ]
  },
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What does this Kruskal's algorithm calculator do?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "This calculator takes a weighted, undirected graph as input and applies Kruskal's algorithm to compute a minimum spanning tree (or a minimum spanning forest if the graph is disconnected). It shows the sorted edges, which ones are added or skipped, and the total MST weight."
        }
      },
      {
        "@type": "Question",
        "name": "How should I format the input for Kruskal's algorithm?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Enter one edge per line using the format: u v w, where u and v are vertex labels and w is the edge weight. You can separate fields by spaces or commas, for example: A B 3 or 1,2,5. Lines starting with # or // are treated as comments and ignored."
        }
      },
      {
        "@type": "Question",
        "name": "Can this calculator handle disconnected graphs?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes. If your graph is disconnected, Kruskal's algorithm will compute a minimum spanning forest: one minimum spanning tree per connected component. The tool will warn you if fewer edges than |V|-1 are selected, which means the graph is not fully connected."
        }
      },
      {
        "@type": "Question",
        "name": "When should I use Kruskal's algorithm instead of Prim's algorithm?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Kruskal's algorithm is usually preferred for sparse graphs and when edges are naturally listed, because it sorts edges once and then processes them greedily. Prim's algorithm is often more convenient when you have a dense graph represented by an adjacency matrix. Both return a minimum spanning tree if all edge weights are non-negative."
        }
      }
    ]
  },
  {
    "@context": "https://schema.org",
    "@type": "HowTo",
    "name": "How to compute a minimum spanning tree with Kruskal's Algorithm",
    "description": "Step-by-step instructions on how to use the Kruskal's Algorithm Calculator on CalcDomain to compute a minimum spanning tree (MST) from a weighted graph.",
    "step": [
      {
        "@type": "HowToStep",
        "name": "Enter the graph edges",
        "text": "In the edges input area, enter one edge per line using the format u v w, where u and v are vertex labels and w is the edge weight. You can separate values with spaces or commas."
      },
      {
        "@type": "HowToStep",
        "name": "(Optional) Load a sample graph",
        "text": "If you want to see how the calculator works, click the button to load a sample graph. The tool will pre-fill the edges input with a classic MST example."
      },
      {
        "@type": "HowToStep",
        "name": "Run Kruskal's algorithm",
        "text": "Click the Compute MST button. The calculator will sort the edges by weight and apply Kruskal's algorithm using a union–find data structure."
      },
      {
        "@type": "HowToStep",
        "name": "Review the results",
        "text": "Check the summary of vertices, edges selected in the MST, and total MST weight. Use the step-by-step table to see which edges were added or skipped and why."
      },
      {
        "@type": "HowToStep",
        "name": "Interpret connectivity",
        "text": "If the number of selected edges is less than |V|-1, the tool will indicate that the graph is disconnected and that the output is a minimum spanning forest rather than a single MST."
      }
    ]
  }
]
</script>

<style>
/* AUDIT_SPINE_CSS */
.auditspine-note{
  border:1px solid #e5e7eb;
  background:#fff;
  border-radius:12px;
  padding:12px;
  color:#475569;
  font-size:13px;
  line-height:1.5;
}
.auditspine-mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
.auditspine-changelog{
  border:1px solid #e5e7eb;
  background:#fff;
  border-left:5px solid #334155;
  border-radius:12px;
  padding:12px;
  font-size:13px;
  color:#475569;
}
.auditspine-formula{
  margin:10px 0;
  background:#0b1220;
  color:#e5e7eb;
  border-radius:12px;
  padding:12px;
  border:1px solid rgba(255,255,255,.12);
  overflow-x:auto;
}
.auditspine-formula pre{margin:8px 0 0; white-space:pre-wrap;}
.auditspine-hr{border:none; border-top:1px solid #e5e7eb; margin:18px 0;}
.auditspine-badge{
  display:inline-block;
  padding:4px 10px;
  border-radius:999px;
  font-size:12px;
  font-weight:600;
  border:1px solid #e5e7eb;
  background:#f8fafc;
  color:#0f172a;
}
.auditspine-badge-warn{
  background:#fff7ed;
  border-color:#fed7aa;
  color:#9a3412;
}
</style>
</head>
<body class="bg-gray-50 text-gray-800">

    <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9476637732224939" crossorigin="anonymous"></script>

    <header class="bg-white shadow-sm sticky top-0 z-50">
      <nav class="container mx-auto px-4 lg:px-6 py-4" aria-label="Primary">
        <div class="flex justify-between items-center">
          <a href="https://calcdomain.com" class="text-2xl font-bold text-blue-600">CalcDomain</a>
          <div class="w-full max-w-md hidden md:block mx-8">
            <div class="relative">
              <input type="search" id="search-input" placeholder="Search for a calculator..." class="w-full py-2 px-4 pr-10 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" autocomplete="off">
              <svg class="w-5 h-5 absolute right-4 top-1/2 -translate-y-1/2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
              <div id="search-results" class="absolute top-full left-0 right-0 bg-white shadow-lg rounded-lg mt-2 max-h-96 overflow-y-auto z-50 hidden border border-gray-200"></div>
            </div>
          </div>
          <div class="hidden md:flex items-center space-x-6">
            <a href="https://calcdomain.com/search" class="text-gray-700 hover:text-blue-600 transition-colors">Advanced Search</a>
            <a href="https://calcdomain.com/categories" class="text-gray-700 hover:text-blue-600 transition-colors">Categories</a>
          </div>
          <button id="mobile-menu-toggle" class="md:hidden p-2" aria-controls="mobile-menu" aria-expanded="false" aria-label="Open menu" type="button">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
          </button>
        </div>
        <nav id="mobile-menu" class="md:hidden mt-4 hidden" aria-label="Mobile menu" role="navigation">
          <div class="mb-4">
            <div class="relative">
              <input type="search" id="mobile-search-input" placeholder="Search calculators..." class="w-full py-3 px-4 pr-10 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
              <svg class="w-5 h-5 absolute right-4 top-1/2 -translate-y-1/2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
            </div>
          </div>
          <div class="space-y-2">
            <a href="https://calcdomain.com/search" class="block py-2 text-gray-700 hover:text-blue-600">Advanced Search</a>
            <a href="https://calcdomain.com/categories" class="block py-2 text-gray-700 hover:text-blue-600">Categories</a>
          </div>
        </nav>
      </nav>
    </header>

    <div class="container mx-auto px-4 py-8">
      
      <nav class="text-sm mb-4 text-gray-600" aria-label="Breadcrumbs"><a href="https://calcdomain.com" class="hover:text-blue-600">Home</a> &raquo; <a href="https://calcdomain.com/categories/engineering" class="hover:text-blue-600">Engineering</a> &raquo; <a href="https://calcdomain.com/subcategories/electrical" class="hover:text-blue-600">Electrical</a></nav>
      
      <div class="flex flex-col lg:flex-row gap-8">
        
        <main class="w-full lg:w-2/3">
          <div class="bg-white p-6 rounded-lg shadow-md">
            
            <h1 class="text-2xl md:text-3xl font-bold mb-4">
              Kruskal's Algorithm Calculator – Minimum Spanning Tree (MST)
            </h1>
            <p class="text-gray-700 mb-4">
              This Kruskal's algorithm calculator builds a <strong>minimum spanning tree (MST)</strong> from your weighted, undirected graph. 
              Enter edges and weights, hit <em>Compute MST</em>, and see step-by-step which edges are added, which ones are skipped, and the final MST cost.
            </p>
            <p class="text-gray-700 mb-6">
              The tool is designed for computer science students, software engineers, and anyone working with 
              <strong>graph algorithms</strong>, network design, or optimization problems that require MSTs.
            </p>

            <!-- CALCULATOR UI -->
            <section aria-labelledby="kruskal-calculator" class="mb-8">
              <h2 id="kruskal-calculator" class="text-xl font-semibold mb-3">
                Kruskal's Algorithm Calculator
              </h2>
              <p class="text-gray-700 mb-3 text-sm">
                Enter one edge per line in the format: <code class="bg-gray-100 px-1 rounded">u v w</code> 
                where <code>u</code> and <code>v</code> are vertex labels and <code>w</code> is the edge weight.
                Spaces or commas are accepted as separators. Lines starting with <code>#</code> or <code>//</code> are ignored.
              </p>

              <form id="kruskal-form" class="space-y-4" onsubmit="return false;">
                <div>
                  <label for="edges-input" class="block text-sm font-medium text-gray-700 mb-1">
                    Edges (one per line)
                  </label>
                  <textarea id="edges-input" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm font-mono focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" rows="8" placeholder="Example:
A B 4
A H 8
B H 11
B C 8
C D 7
C F 4
C I 2
D E 9
D F 14
E F 10
F G 2
G H 1
G I 6
H I 7"></textarea>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                  <div>
                    <label for="vertex-hint" class="block text-sm font-medium text-gray-700 mb-1">
                      Known vertices (optional)
                    </label>
                    <input id="vertex-hint" type="text" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="e.g. A,B,C,D,E,F,G,H,I">
                    <p class="text-xs text-gray-500 mt-1">
                      Use this only if you want to enforce a specific vertex set (isolated vertices included).
                    </p>
                  </div>

                  <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">
                      Graph type
                    </label>
                    <select id="graph-type" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm bg-gray-100 text-gray-700" disabled="">
                      <option>Undirected (required for Kruskal's MST)</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">
                      Kruskal's algorithm assumes an undirected graph with real-valued edge weights.
                    </p>
                  </div>

                  <div class="flex gap-2 md:justify-end">
                    <button type="button" id="load-sample-btn" class="inline-flex items-center justify-center px-4 py-2 rounded-md text-sm font-medium bg-gray-100 text-gray-800 hover:bg-gray-200 border border-gray-300">
                      Load sample graph
                    </button>
                    <button type="button" id="compute-btn" class="inline-flex items-center justify-center px-4 py-2 rounded-md text-sm font-semibold bg-blue-600 text-white hover:bg-blue-700">
                      Compute MST
                    </button>
                  </div>
                </div>

                <div id="error-message" class="mt-2 text-sm text-red-600 hidden"></div>
              </form>

              <div id="results" class="mt-6 space-y-4 hidden">
                <div class="bg-blue-50 border border-blue-100 rounded-lg p-4 text-sm">
                  <h3 class="font-semibold text-blue-800 mb-2">MST Summary</h3>
                  <p id="summary-line" class="text-blue-900 mb-1"></p>
                  <p id="connectivity-line" class="text-blue-900 mb-1"></p>
                  <p id="vertex-edge-line" class="text-blue-900"></p>
                </div>

                <div>
                  <h3 class="text-lg font-semibold mb-2">Edges in the minimum spanning tree</h3>
                  <div class="overflow-x-auto">
                    <table class="min-w-full text-sm border border-gray-200 rounded-lg overflow-hidden">
                      <thead class="bg-gray-100">
                        <tr>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">#</th>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Edge</th>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Weight</th>
                        </tr>
                      </thead>
                      <tbody id="mst-edges-body">
                        <!-- Filled by JS -->
                      </tbody>
                    </table>
                  </div>
                </div>

                <div>
                  <h3 class="text-lg font-semibold mb-2">Kruskal's algorithm – step-by-step</h3>
                  <p class="text-sm text-gray-600 mb-2">
                    Edges are processed in non-decreasing order of weight. An edge is added to the MST if and only if it connects two different components (does not form a cycle).
                  </p>
                  <div class="overflow-x-auto">
                    <table class="min-w-full text-xs md:text-sm border border-gray-200 rounded-lg overflow-hidden">
                      <thead class="bg-gray-100">
                        <tr>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Step</th>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Edge</th>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Weight</th>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Action</th>
                          <th class="px-3 py-2 text-left font-medium text-gray-700 border-b">Reason</th>
                        </tr>
                      </thead>
                      <tbody id="steps-table-body">
                        <!-- Filled by JS -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </section>

            <!-- EXPLANATION SECTION -->
            <section class="prose">
              <h2>How Kruskal's algorithm works</h2>
              <p>
                Given a connected, weighted, undirected graph \( G = (V, E) \), a 
                <strong>minimum spanning tree (MST)</strong> is a subset of edges \( T \subseteq E \) that:
              </p>
              <ul>
                <li>connects all vertices,</li>
                <li>contains exactly \(|V| - 1\) edges, and</li>
                <li>has minimum possible total weight among all such spanning trees.</li>
              </ul>
              <p>
                <strong>Kruskal's algorithm</strong> builds an MST by repeatedly adding the cheapest edge that does not create a cycle,
                using a <em>disjoint-set union (DSU) / union–find</em> data structure to track components efficiently.
              </p>

              <div class="formula-box text-sm">
<pre class="whitespace-pre-wrap"><code>// Input: Weighted undirected graph G = (V, E)
KruskalMST(V, E):
  // sort edges by non-decreasing weight
  sort E by weight ascending

  make-set(v) for each v in V   // DSU initialization
  MST = empty set

  for each edge (u, v, w) in E (in sorted order):
    if find-set(u) != find-set(v):    // different components?
      MST.add((u, v, w))              // safe to add
      union(u, v)                     // merge components

  return MST
</code></pre>
              </div>

              <p>
                The union–find structure supports almost-constant-time <code>find</code> and <code>union</code> operations,
                so the overall time complexity is dominated by sorting the edges:
              </p>
              <ul>
                <li>\(O(|E|\log|E|)\) for sorting the edges,</li>
                <li>plus near-linear time for the union–find operations.</li>
              </ul>

              <h3>Worked example</h3>
              <p>
                Consider the sample graph with vertices \( \{A, B, C, D, E, F, G, H, I\} \) and edges such as:
              </p>
              <div class="formula-box text-sm">
<pre class="whitespace-pre-wrap"><code>A B 4
A H 8
B H 11
B C 8
C D 7
C F 4
C I 2
D E 9
D F 14
E F 10
F G 2
G H 1
G I 6
H I 7
</code></pre>
              </div>
              <p>
                When you click <strong>Compute MST</strong>, the calculator sorts all edges by weight 
                (starting with <code>G H 1</code>, <code>C I 2</code>, <code>F G 2</code>, …) and adds each edge if it does not 
                connect vertices that are already in the same component. The step-by-step table shows exactly which edges were added or skipped.
              </p>

              <h3>Interpreting the results</h3>
              <ul>
                <li>
                  If the number of selected edges equals \(|V| - 1\), the graph is connected and the result is a valid minimum spanning tree.
                </li>
                <li>
                  If fewer edges are selected, the graph is disconnected and the result is a 
                  <strong>minimum spanning forest</strong> (one MST per connected component).
                </li>
                <li>
                  The total weight is the sum of the weights of all edges in the MST (or forest).
                </li>
              </ul>

              <h2>How to use the Kruskal's Algorithm Calculator</h2>
              <ol>
                <li>
                  <strong>List your edges.</strong> For each undirected edge, choose a pair of vertex labels (e.g. A and B) and a weight.
                </li>
                <li>
                  <strong>Enter one edge per line.</strong> Use the format <code>u v w</code>, for example <code>A B 7</code> or <code>1,2,3.5</code>.
                </li>
                <li>
                  <strong>(Optional) Provide a vertex set.</strong> If your graph contains isolated vertices, list them in 
                  the “Known vertices” field, separated by commas.
                </li>
                <li>
                  <strong>Click “Compute MST”.</strong> The tool applies Kruskal's algorithm and shows both a concise summary and detailed steps.
                </li>
                <li>
                  <strong>Review connectivity.</strong> Check whether the graph is fully connected or if you obtained a minimum spanning forest.
                </li>
              </ol>

              <h2>Limitations and notes</h2>
              <ul>
                <li>
                  The calculator expects a <strong>finite, undirected graph</strong> with real-valued weights. Directed graphs and negative cycles are out of scope.
                </li>
                <li>
                  If multiple MSTs have the same total weight, Kruskal's algorithm may return any one of them depending on the tie-breaking order of edges.
                </li>
                <li>
                  For very large graphs, performance is mainly limited by your browser and device resources.
                </li>
              </ul>

              <h2>FAQ – Kruskal's Algorithm &amp; MST</h2>

              <details class="mb-2">
                <summary class="font-semibold cursor-pointer">What is the main difference between Kruskal's and Prim's algorithm?</summary>
                <p>
                  Kruskal's algorithm processes edges globally in order of increasing weight and builds the MST by selecting 
                  the next cheapest edge that does not form a cycle. Prim's algorithm starts from an arbitrary root vertex and 
                  grows a single tree by repeatedly adding the cheapest edge that expands the current tree. Both algorithms 
                  have similar asymptotic complexity but behave differently on sparse vs dense graphs and with different graph representations.
                </p>
              </details>

              <details class="mb-2">
                <summary class="font-semibold cursor-pointer">Can I use this calculator for graphs with equal edge weights?</summary>
                <p>
                  Yes. Ties in edge weights are allowed. When multiple edges have the same weight, the algorithm uses a stable sort 
                  and a deterministic ordering to process them. Different valid MSTs with the same total weight may exist; any of them is acceptable.
                </p>
              </details>

              <details class="mb-2">
                <summary class="font-semibold cursor-pointer">What happens if I accidentally input directed edges?</summary>
                <p>
                  The calculator treats every line as an undirected edge connecting two vertices, regardless of the order. 
                  If you are modeling a directed network, you should convert it to an undirected representation appropriate for MST analysis 
                  or use a dedicated shortest-path or flow algorithm instead.
                </p>
              </details>

              <details>
                <summary class="font-semibold cursor-pointer">Does Kruskal's algorithm work with negative edge weights?</summary>
                <p>
                  As long as the graph is undirected and does not contain negative cycles (which are not meaningful in MST problems),
                  Kruskal's algorithm still works with negative edge weights. It will first select the most negative edges, 
                  provided they do not form cycles, and proceed to higher weights.
                </p>
              </details>
            </section>

          </div>
        
<!-- AUDIT_SPINE_START -->
<hr class="auditspine-hr">
<section aria-label="Formulas, sources, changelog, verification">
  <span class="auditspine-badge">Audit: Complete</span>

  <details style="margin-top:10px">
    <summary><strong>Formula (LaTeX) + variables + units</strong></summary>
    <div class="auditspine-note" style="margin-top:10px">
      This section shows the formulas used by the calculator engine, plus variable definitions and units.
      
    </div>
    <div class="auditspine-formula">
      <div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[','\\]</div>
  <pre class="auditspine-mono">','\</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted text)</strong></div>
  
  <pre class="auditspine-mono">// Input: Weighted undirected graph G = (V, E) KruskalMST(V, E): // sort edges by non-decreasing weight sort E by weight ascending make-set(v) for each v in V // DSU initialization MST = empty set for each edge (u, v, w) in E (in sorted order): if find-set(u) != find-set(v): // different components? MST.add((u, v, w)) // safe to add union(u, v) // merge components return MST</pre>
</div>
      <div style="margin-top:12px"><strong>Variables and units</strong></div>
      <ul style="margin:8px 0 0 18px">
        <li><em>No variables provided in audit spec.</em></li>
      </ul>
    </div>
  </details>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Sources (authoritative):</strong>
    <ul style="margin:8px 0 0 18px">
      <li><strong>NIST — Weights and measures</strong> — nist.gov · Accessed 2026-01-19<br><a href="https://www.nist.gov/pml/weights-and-measures" target="_blank" rel="nofollow noopener">https://www.nist.gov/pml/weights-and-measures</a></li>
<li><strong>FTC — Consumer advice</strong> — consumer.ftc.gov · Accessed 2026-01-19<br><a href="https://consumer.ftc.gov/" target="_blank" rel="nofollow noopener">https://consumer.ftc.gov/</a></li>
    </ul>
  </div>

  <div class="auditspine-changelog" style="margin-top:12px">
    <strong>Changelog</strong><br>
    <div style="margin-top:6px">
      <strong>Version:</strong> 0.1.0-draft<br>
      <strong>Last code update:</strong> 2026-01-19
    </div>
    <div style="margin-top:10px">
  <strong>0.1.0-draft</strong> · 2026-01-19
  <ul style="margin:6px 0 0 18px">
    <li>Initial audit spec draft generated from HTML extraction (review required).</li>
<li>Verify formulas match the calculator engine and convert any text-only formulas to LaTeX.</li>
<li>Confirm sources are authoritative and relevant to the calculator methodology.</li>
  </ul>
</div>
  </div>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Verified by Ugo Candido on 2026-01-19</strong><br>
    <a href="https://calcdomain.com/ugocandido" target="_blank" rel="noopener">Profile</a> ·
    <a href="https://www.linkedin.com/in/ugocandido92821/" target="_blank" rel="noopener">LinkedIn</a>
  </div>
</section>
<!-- AUDIT_SPINE_END -->
</main>
        
        <aside class="w-full lg:w-1/3">

          <div class="bg-white p-4 rounded-lg shadow-md mb-6">
            <h2 class="text-lg font-semibold mb-3">Related Engineering Tools</h2>
            <ul class="space-y-2 text-sm">
              <li>
                <a href="https://calcdomain.com/asce-7-22-tornado-load" class="text-blue-600 hover:underline">
                  ASCE 7-22 Tornado Load
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/batch-reactor-design" class="text-blue-600 hover:underline">
                  Batch reactor design
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/civil" class="text-blue-600 hover:underline">
                  Civil engineering
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/load-balancing-simulator" class="text-blue-600 hover:underline">
                  Load balancing algorithm simulator
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/moment-of-inertia" class="text-blue-600 hover:underline">
                  Moment of inertia
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/prim-s-algorithm-calculator" class="text-blue-600 hover:underline">
                  Minimum spanning tree (Prim's algorithm)
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/cyclomatic-complexity" class="text-blue-600 hover:underline">
                  Cyclomatic complexity
                </a>
              </li>
              <li>
                <a href="https://calcdomain.com/flash-distillation" class="text-blue-600 hover:underline">
                  Flash distillation
                </a>
              </li>
            </ul>
          </div>

          <div class="bg-white p-4 rounded-lg shadow-md">
            <h2 class="text-lg font-semibold mb-3">Tips for using MST calculators</h2>
            <ul class="list-disc list-inside text-sm text-gray-700 space-y-1">
              <li>Double-check edge weights; small typos can change the MST.</li>
              <li>Make sure your graph model is undirected before applying Kruskal's algorithm.</li>
              <li>Compare results with Prim's algorithm to build intuition on sparse vs dense graphs.</li>
              <li>Use comments (<code>#</code> or <code>//</code>) to keep notes directly in the input.</li>
            </ul>
          </div>

        </aside>
        
      </div>
    </div>
    <footer class="bg-gray-900 text-white py-12">
  <div class="container mx-auto px-4">
    <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
      <div>
        <h3 class="text-2xl font-bold mb-4">CalcDomain</h3>
        <p class="text-gray-400 mb-4">
          Your trusted source for free online calculators. Accurate, fast, and reliable calculations for every need.
        </p>
        </div>

      <div>
        <h4 class="text-lg font-semibold mb-4">Categories</h4>
                                                                <ul class="space-y-2">
          <li><a href="https://calcdomain.com/categories/construction" class="text-gray-400 hover:text-white">Construction</a></li>
          <li><a href="https://calcdomain.com/categories/construction-diy" class="text-gray-400 hover:text-white">Construction & DIY</a></li>
          <li><a href="https://calcdomain.com/categories/engineering" class="text-gray-400 hover:text-white">Engineering</a></li>
          <li><a href="https://calcdomain.com/categories/finance" class="text-gray-400 hover:text-white">Finance</a></li>
          <li><a href="https://calcdomain.com/categories/general" class="text-gray-400 hover:text-white">General</a></li>
          <li><a href="https://calcdomain.com/categories/health-fitness" class="text-gray-400 hover:text-white">Health & Fitness</a></li>
          <li><a href="https://calcdomain.com/categories/lifestyle-everyday" class="text-gray-400 hover:text-white">Lifestyle & Everyday</a></li>
          <li><a href="https://calcdomain.com/categories/math" class="text-gray-400 hover:text-white">Math</a></li>
          <li><a href="https://calcdomain.com/categories/math-conversions" class="text-gray-400 hover:text-white">Math & Conversions</a></li>
          <li><a href="https://calcdomain.com/categories/science" class="text-gray-400 hover:text-white">Science</a></li>
        </ul>
      </div>

      <div>
        <h4 class="text-lg font-semibold mb-4">Popular Tools</h4>
        <ul class="space-y-2">
          <li><a href="https://calcdomain.com/mortgage-payment" class="text-gray-400 hover:text-white">Mortgage Calculator</a></li>
          <li><a href="https://calcdomain.com/percentage-calculator" class="text-gray-400 hover:text-white">Percentage Calculator</a></li>
          <li><a href="https://calcdomain.com/bmi-calculator" class="text-gray-400 hover:text-white">BMI Calculator</a></li>
          <li><a href="https://calcdomain.com/auto-loan-calculator" class="text-gray-400 hover:text-white">Auto Loan Calculator</a></li>
          <li><a href="https://calcdomain.com/house-affordability" class="text-gray-400 hover:text-white">House Affordability</a></li>
        </ul>
      </div>

      <div>
        <h4 class="text-lg font-semibold mb-4">Support</h4>
        <ul class="space-y-2">
          <li><a href="https://calcdomain.com/about" class="text-gray-400 hover:text-white">About Us</a></li>
          <li><a href="https://calcdomain.com/contact" class="text-gray-400 hover:text-white">Contact</a></li>
          <li><a href="https://calcdomain.com/privacy" class="text-gray-400 hover:text-white">Privacy Policy</a></li>
          <li><a href="https://calcdomain.com/terms" class="text-gray-400 hover:text-white">Terms of Service</a></li>
          <li><a href="https://calcdomain.com/sitemap.xml" class="text-gray-400 hover:text-white">Site Map</a></li>
        </ul>
      </div>
    </div>

    <div class="border-t border-gray-800 mt-8 pt-8 text-center text-gray-400">
      <p>&copy; 2025 CalcDomain. All Rights Reserved. | Free Online Calculators for Everyone</p>
    </div>
  </div>
</footer>









    
    <script src="/assets/js/script_menu.js" defer=""></script>
    <script src="/assets/js/script_faq.js" defer=""></script>
    <script src="search.js" defer=""></script>

    <script>
      (function () {
        const edgesInput = document.getElementById('edges-input');
        const vertexHintInput = document.getElementById('vertex-hint');
        const computeBtn = document.getElementById('compute-btn');
        const loadSampleBtn = document.getElementById('load-sample-btn');
        const errorMessage = document.getElementById('error-message');
        const resultsSection = document.getElementById('results');
        const summaryLine = document.getElementById('summary-line');
        const connectivityLine = document.getElementById('connectivity-line');
        const vertexEdgeLine = document.getElementById('vertex-edge-line');
        const mstEdgesBody = document.getElementById('mst-edges-body');
        const stepsTableBody = document.getElementById('steps-table-body');

        function showError(msg) {
          errorMessage.textContent = msg;
          errorMessage.classList.remove('hidden');
          resultsSection.classList.add('hidden');
        }

        function clearError() {
          errorMessage.textContent = '';
          errorMessage.classList.add('hidden');
        }

        function parseVertexHint() {
          const txt = vertexHintInput.value.trim();
          if (!txt) return null;
          const parts = txt.split(/[,;\s]+/).map(s => s.trim()).filter(Boolean);
          if (parts.length === 0) return null;
          return new Set(parts);
        }

        function parseEdges(raw) {
          const lines = raw.split(/\r?\n/);
          const edges = [];
          for (let line of lines) {
            line = line.trim();
            if (!line) continue;
            if (line.startsWith('#') || line.startsWith('//')) continue;
            line = line.replace(/,/g, ' ');
            const parts = line.split(/\s+/).filter(Boolean);
            if (parts.length < 3) {
              throw new Error('Each non-comment line must contain at least two vertices and a weight, e.g. "A B 3". Problematic line: "' + line + '"');
            }
            const wStr = parts[parts.length - 1];
            const u = parts[0];
            const v = parts[1];
            const w = parseFloat(wStr);
            if (!u || !v || Number.isNaN(w)) {
              throw new Error('Invalid edge format. Expected "u v w" with numeric weight. Problematic line: "' + line + '"');
            }
            edges.push({ u, v, w });
          }
          if (edges.length === 0) {
            throw new Error('Please enter at least one valid edge.');
          }
          return edges;
        }

        function buildVertexSet(edges, hintSet) {
          const vertices = new Set();
          if (hintSet) {
            hintSet.forEach(v => vertices.add(v));
          }
          for (const e of edges) {
            vertices.add(e.u);
            vertices.add(e.v);
          }
          return Array.from(vertices);
        }

        function kruskal(vertices, edges) {
          // Map vertices to indices
          const indexMap = new Map();
          vertices.forEach((v, i) => indexMap.set(v, i));

          const parent = [];
          const rank = [];
          const n = vertices.length;
          for (let i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
          }

          function find(x) {
            if (parent[x] !== x) {
              parent[x] = find(parent[x]);
            }
            return parent[x];
          }

          function union(x, y) {
            const rx = find(x);
            const ry = find(y);
            if (rx === ry) return false;
            if (rank[rx] < rank[ry]) {
              parent[rx] = ry;
            } else if (rank[rx] > rank[ry]) {
              parent[ry] = rx;
            } else {
              parent[ry] = rx;
              rank[rx]++;
            }
            return true;
          }

          const sortedEdges = edges.slice().sort((a, b) => {
            if (a.w !== b.w) return a.w - b.w;
            const au = String(a.u);
            const bu = String(b.u);
            if (au !== bu) return au < bu ? -1 : 1;
            const av = String(a.v);
            const bv = String(b.v);
            if (av !== bv) return av < bv ? -1 : 1;
            return 0;
          });

          const mstEdges = [];
          const steps = [];
          let totalWeight = 0;

          for (let i = 0; i < sortedEdges.length; i++) {
            const e = sortedEdges[i];
            const iu = indexMap.get(e.u);
            const iv = indexMap.get(e.v);
            if (iu === undefined || iv === undefined) {
              steps.push({
                edge: e,
                action: 'Skipped',
                reason: 'Vertex not recognized'
              });
              continue;
            }
            const ru = find(iu);
            const rv = find(iv);
            if (ru !== rv) {
              union(ru, rv);
              mstEdges.push(e);
              totalWeight += e.w;
              steps.push({
                edge: e,
                action: 'Added',
                reason: 'Vertices are in different components (no cycle)'
              });
            } else {
              steps.push({
                edge: e,
                action: 'Skipped',
                reason: 'Adding this edge would create a cycle'
              });
            }
          }

          // Count components
          const componentRoots = new Set();
          for (let i = 0; i < n; i++) {
            componentRoots.add(find(i));
          }

          return {
            mstEdges,
            steps,
            totalWeight,
            vertexCount: vertices.length,
            edgeCount: edges.length,
            componentCount: componentRoots.size
          };
        }

        function formatWeight(value) {
          if (!Number.isFinite(value)) return String(value);
          const rounded = Number(value.toFixed(4));
          return String(rounded);
        }

        function renderResults(result) {
          resultsSection.classList.remove('hidden');
          mstEdgesBody.innerHTML = '';
          stepsTableBody.innerHTML = '';

          const { mstEdges, steps, totalWeight, vertexCount, edgeCount, componentCount } = result;

          // Summary
          if (mstEdges.length === 0) {
            summaryLine.textContent = 'No edges were selected for the minimum spanning tree. Check the input for errors or disconnected vertices.';
          } else {
            const edgesDesc = mstEdges
              .map(e => `${e.u}–${e.v}`)
              .join(', ');
            summaryLine.textContent =
              `MST edges: { ${edgesDesc} } with total weight = ${formatWeight(totalWeight)}.`;
          }

          if (vertexCount > 0) {
            if (mstEdges.length === vertexCount - 1 && componentCount === 1) {
              connectivityLine.textContent =
                `The graph appears to be connected (|V| = ${vertexCount}); a valid minimum spanning tree with |E_MST| = |V| − 1 was found.`;
            } else {
              connectivityLine.textContent =
                `The graph is not fully connected. The result is a minimum spanning forest with ${componentCount} component(s).`;
            }
          } else {
            connectivityLine.textContent = '';
          }

          vertexEdgeLine.textContent =
            `Vertices: ${vertexCount}, input edges: ${edgeCount}, selected MST edges: ${mstEdges.length}.`;

          // MST edges table
          mstEdges.forEach((e, idx) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td class="px-3 py-2 border-b text-gray-700">${idx + 1}</td>
              <td class="px-3 py-2 border-b text-gray-700 font-mono">${e.u} – ${e.v}</td>
              <td class="px-3 py-2 border-b text-gray-700">${formatWeight(e.w)}</td>
            `;
            mstEdgesBody.appendChild(tr);
          });

          // Steps table
          steps.forEach((s, idx) => {
            const isAdded = s.action === 'Added';
            const tr = document.createElement('tr');
            tr.className = isAdded ? 'bg-green-50' : 'bg-red-50';
            tr.innerHTML = `
              <td class="px-3 py-2 border-b text-gray-700">${idx + 1}</td>
              <td class="px-3 py-2 border-b text-gray-700 font-mono">${s.edge.u} – ${s.edge.v}</td>
              <td class="px-3 py-2 border-b text-gray-700">${formatWeight(s.edge.w)}</td>
              <td class="px-3 py-2 border-b text-gray-700 font-semibold">${s.action}</td>
              <td class="px-3 py-2 border-b text-gray-700">${s.reason}</td>
            `;
            stepsTableBody.appendChild(tr);
          });
        }

        function loadSample() {
          const sample = [
            'A B 4',
            'A H 8',
            'B H 11',
            'B C 8',
            'C D 7',
            'C F 4',
            'C I 2',
            'D E 9',
            'D F 14',
            'E F 10',
            'F G 2',
            'G H 1',
            'G I 6',
            'H I 7'
          ].join('\n');
          edgesInput.value = sample;
          vertexHintInput.value = 'A,B,C,D,E,F,G,H,I';
        }

        computeBtn.addEventListener('click', function () {
          clearError();
          try {
            const raw = edgesInput.value.trim();
            if (!raw) {
              showError('Please enter at least one edge before computing the MST.');
              return;
            }
            const edges = parseEdges(raw);
            const hintSet = parseVertexHint();
            const vertices = buildVertexSet(edges, hintSet);
            const result = kruskal(vertices, edges);
            renderResults(result);
          } catch (err) {
            console.error(err);
            showError(err.message || 'An unexpected error occurred while running Kruskal\'s algorithm.');
          }
        });

        loadSampleBtn.addEventListener('click', function () {
          loadSample();
          clearError();
          resultsSection.classList.add('hidden');
        });
      })();
    </script>
    
    <script>
      window.MathJax = {
        tex: { inlineMath: [['\\(','\\)'], ['$', '$']], displayMath: [['$','$'], ['\\[','\\]']] },
        svg: { fontCache: 'global' }
      };
    </script>
    <script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    



</body></html>