<!DOCTYPE html><html lang="en"><head>
<link rel="canonical" href="https://calcdomain.com/nec-box-fill">





 
<link rel="icon" type="image/png" href="https://calcdomain.com/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/svg+xml" href="https://calcdomain.com/favicon.svg">
<link rel="shortcut icon" href="https://calcdomain.com/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="https://calcdomain.com/apple-touch-icon.png">
<link rel="manifest" href="https://calcdomain.com/site.webmanifest">
<meta charset="utf-8">
<title>NEC Box Fill Calculator</title>
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="Professional NEC Box Fill Calculator for US electricians. Compute required box volume per NEC 314.16(B) with device yokes, grounds, clamps, and fittings. Mobile-first, accessible, and optimized for Core Web Vitals." name="description">
<meta content="Ugo Candido" name="author">

<meta content="#ffffff" name="theme-color">
<noscript></noscript>
<style>
    :root{
      --primary-color:#005A9C; --secondary-color:#003F6E; --accent-color:#00A4E4;
      --background-color:#F8F9FA; --surface-color:#FFFFFF;
      --text-color:#212529; --muted-text-color:#495057; --border-color:#DEE2E6;
      --success-color:#198754; --danger-color:#DC3545; --warning-color:#F59E0B;

      --font-sans:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
      --font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;

      --container-max:1200px;
      --radius-6:6px; --radius-8:8px; --radius-12:12px;
      --focus-ring:3px solid #005A9C;
      --shadow-sm:0 2px 6px rgba(16,24,40,.06);
      --shadow-md:0 8px 24px rgba(16,24,40,.08);
      --touch-min:48px;
    }
    @media (prefers-reduced-motion: reduce){
      *{animation-duration:.001ms!important;transition-duration:.001ms!important;scroll-behavior:auto!important}
    }
    *,*::before,*::after{box-sizing:border-box}
    html{font-size:16px}
    body{
      margin:0; font-family:var(--font-sans); background:var(--background-color);
      color:var(--text-color); line-height:1.6; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }
    a{color:var(--primary-color); text-decoration:none}
    a:hover{text-decoration:underline}
    a:focus{outline:var(--focus-ring); outline-offset:2px}
    h1,h2,h3,h4{color:var(--secondary-color); line-height:1.25; margin:.5rem 0 .75rem}
    h1{font-size:clamp(1.75rem,4vw,2.25rem)}
    h2{font-size:clamp(1.35rem,3vw,1.75rem)}
    h3{font-size:clamp(1.2rem,2.5vw,1.35rem)}
    p{margin:.75rem 0 1rem; max-width:75ch}
    code,.code{font-family:var(--font-mono); background:#eef2f6; padding:.15em .35em; border-radius:4px}
    .container{max-width:var(--container-max); margin:0 auto; padding:0 clamp(1rem,4vw,2rem)}
    .skip-link{
      position:absolute; left:6px; top:-40px; background:var(--primary-color); color:#fff; padding:.5rem .75rem;
      border-radius:0 0 4px 4px; z-index:1000; text-decoration:none; font-weight:600
    }
    .skip-link:focus{top:0}

    /* Header (non-sticky per spec) */
    .site-header{background:var(--surface-color); border-bottom:1px solid var(--border-color)}
    .header-content{display:grid; grid-template-columns:auto 1fr auto; gap:.75rem; align-items:center; padding:.75rem 0}
    .logo{font-weight:800; color:var(--primary-color); font-size:1.125rem}
    .site-search{display:flex; gap:.5rem; align-items:center}
    .site-search input[type="search"]{
      flex:1 1 auto; min-width:0; padding:.6rem .75rem; border:1px solid var(--border-color);
      border-radius:10px
    }
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      min-height:var(--touch-min); min-width:var(--touch-min);
      border-radius:10px; border:1px solid transparent; cursor:pointer; font-weight:600; padding:.6rem 1rem
    }
    .btn-primary{background:var(--primary-color); color:#fff}
    .btn-primary:hover{background:var(--secondary-color)}
    .btn-secondary{background:#fff; border-color:var(--primary-color); color:var(--primary-color)}
    .btn-secondary:hover{background:rgba(0,90,156,.06)}
    .nav-toggle{border:1px solid var(--border-color); background:#fff}
    .main-nav{display:none}
    .breadcrumb{margin:.75rem 0; font-size:.95rem; color:var(--muted-text-color)}

    /* Calculator layout */
    .calculator-layout{
      display:grid; grid-template-columns:1fr; gap:1.5rem; margin-top:1rem
    }
    @media (min-width: 992px){
      .calculator-layout{grid-template-columns:minmax(280px,420px) 1fr}
    }
    .calculator-container{
      background:var(--surface-color); border:1px solid var(--border-color); border-radius:12px; padding:1.25rem; box-shadow:var(--shadow-sm)
    }
    .form-group{margin-bottom:1rem}
    .form-group label{display:block; font-weight:700; margin-bottom:.35rem}
    .field-help{font-size:.9rem; color:var(--muted-text-color)}
    .inline-help{display:inline-flex; align-items:center; gap:.35rem}
    .help-btn{
      margin-left:.25rem; width:var(--touch-min); height:var(--touch-min); display:inline-flex; align-items:center; justify-content:center;
      border-radius:50%; border:1px solid var(--border-color); background:#fff; color:#111; font-weight:800
    }
    .help-btn:focus{outline:var(--focus-ring)}
    .tooltip{display:none; margin-top:.35rem; background:#eef6ff; border:1px solid #cfe2ff; color:#0a3871; padding:.5rem .75rem; border-radius:8px}
    .tooltip[aria-hidden="false"]{display:block}
    .input-group{position:relative}
    .form-control{
      width:100%; min-height:var(--touch-min); padding:.65rem .75rem; border:1px solid var(--border-color); border-radius:10px; font-size:1rem
    }
    .form-control:focus{outline:var(--focus-ring); outline-offset:2px}
    .form-control[aria-invalid="true"]{border-color:var(--danger-color)}
    .error-message{color:var(--danger-color); font-size:.9rem; margin-top:.25rem; min-height:1.25em}
    .quick-picks{display:flex; flex-wrap:wrap; gap:.5rem; margin-top:.5rem}
    .chip{border:1px solid var(--border-color); background:#fff; padding:.4rem .75rem; border-radius:999px; cursor:pointer; min-height:var(--touch-min); display:inline-flex; align-items:center}
    .chip:focus{outline:var(--focus-ring)}

    .group-list{display:grid; gap:.5rem}
    .group-row{
      display:grid; grid-template-columns:1.2fr .8fr auto; gap:.5rem; align-items:start; padding:.5rem; border:1px dashed var(--border-color); border-radius:8px; background:#fafbfc
    }
    .group-row .remove-btn{background:#fff; border:1px solid var(--border-color); color:#111; border-radius:10px; padding:.5rem .75rem}
    .group-row .remove-btn:hover{background:#f1f3f5}

    .results-container{
      margin-top:.5rem; padding:1rem; background:#f7fafc; border:1px solid var(--border-color); border-radius:12px; min-height:240px
    }
    .results-header{display:flex; align-items:center; justify-content:space-between; gap:1rem; margin-bottom:.5rem}
    .status-badge{
      display:inline-flex; align-items:center; gap:.4rem; font-weight:700; padding:.35rem .6rem; border-radius:999px; font-size:.95rem
    }
    .status-ok{background:#e8f5ee; color:#0d6836; border:1px solid #b7e4c5}
    .status-fail{background:#fdecec; color:#8b1d1d; border:1px solid #f5b5b5}
    .result-grid{display:grid; grid-template-columns:1fr; gap:.75rem}
    @media (min-width: 680px){ .result-grid{grid-template-columns:repeat(2,1fr)} }
    .result-card{background:#fff; border:1px solid var(--border-color); border-radius:10px; padding:.75rem}
    .result-card .label{color:var(--muted-text-color); font-size:.95rem}
    .result-card .value{font-size:1.35rem; font-weight:800}
    .value-ok{color:var(--success-color)} .value-bad{color:var(--danger-color)}
    .breakdown{margin-top:.75rem}
    .breakdown h4{margin:.25rem 0 .5rem}
    .breakdown-list{list-style:none; padding-left:0; margin:0; display:grid; gap:.35rem}
    .breakdown-list li{display:flex; justify-content:space-between; gap:.75rem; border-bottom:1px dashed #e2e8f0; padding:.25rem 0}
    .muted{color:var(--muted-text-color)}
    .formula-box{background:#eef2f6; border:1px solid #d0d7e2; border-radius:10px; padding:1rem; overflow:auto}
    .author-box{font-size:.95rem; color:var(--muted-text-color); border-top:1px solid var(--border-color); margin-top:1.5rem; padding-top:1rem}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0}
    footer.site-footer{background:var(--secondary-color); color:#fff; margin-top:2rem; padding:1.5rem 0}
    footer a{color:#fff}
  </style>
<script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "NEC Box Fill Calculator",
  "description": "Compute required electrical box volume per NEC 314.16(B) with an accessible, professional-grade calculator. Includes devices, grounds, clamps, fittings, and AWG-specific volumes.",
  "url": "https://calcdomain.com/nec-box-fill",
  "inLanguage": "en",
  "mainEntity": [
    {
      "@type": "HowTo",
      "name": "NEC box fill calculation – step-by-step example",
      "description": "Worked example using NEC 314.16(B) and Table 314.16(B) to determine the minimum box volume.",
      "step": [
        {
          "@type": "HowToStep",
          "name": "Gather inputs",
          "text": "Count insulated conductors by AWG, device yokes and their conductor size, number of equipment grounding conductors and their largest AWG, presence of internal clamps, and internal fittings. Get the box's marked volume (cu in)."
        },
        {
          "@type": "HowToStep",
          "name": "Apply conductor volumes",
          "text": "Multiply each count of insulated conductors by the volume allowance from NEC Table 314.16(B) for that AWG."
        },
        {
          "@type": "HowToStep",
          "name": "Account for grounds",
          "text": "If one or more equipment grounding conductors are present, add one conductor volume using the largest EGC size present."
        },
        {
          "@type": "HowToStep",
          "name": "Account for devices",
          "text": "For each yoke (e.g., duplex receptacle), add two conductor volumes using the largest AWG conductor connected to that yoke."
        },
        {
          "@type": "HowToStep",
          "name": "Account for clamps and fittings",
          "text": "If internal clamps are present add one conductor volume; add one conductor volume per internal fitting, both using the largest insulated conductor in the box."
        },
        {
          "@type": "HowToStep",
          "name": "Compare to box volume",
          "text": "Sum all allowances to get the required minimum volume and compare against the box's marked cubic inch volume."
        }
      ]
    },
    {
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Do pigtails count toward box fill?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No additional count for pigtails that originate and terminate within the same box. Their conductors are already included in the count per NEC 314.16(B)."
          }
        },
        {
          "@type": "Question",
          "name": "How do equipment grounding conductors count?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "All equipment grounding conductors together count as a single conductor volume based on the largest EGC present. If there are zero EGCs, add none."
          }
        },
        {
          "@type": "Question",
          "name": "How many conductors does a device yoke count as?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Each yoke (strap) containing one or more devices counts as two conductor volumes of the largest conductor connected to that yoke."
          }
        },
        {
          "@type": "Question",
          "name": "Do internal cable clamps count?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. Integral internal clamps count as one conductor volume of the largest insulated conductor that enters the box."
          }
        },
        {
          "@type": "Question",
          "name": "Do pass-through conductors count?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. Each insulated conductor that passes through a box without splice counts as one conductor volume."
          }
        },
        {
          "@type": "Question",
          "name": "What AWG sizes are supported by the NEC table?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Common entries in Table 314.16(B) include 18, 16, 14, 12, 10, 8, and 6 AWG. This tool uses the cubic-inch allowances from that table."
          }
        },
        {
          "@type": "Question",
          "name": "How do I handle multi-gang boxes?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Use the manufacturer’s marked volume in cubic inches. Multi-gang box volumes are typically marked as the sum of the gangs. Enter that marked total volume into the calculator."
          }
        }
      ]
    }
  ],
  "reviewedBy": {
    "@type": "Person",
    "name": "Ugo Candido"
  },
  "dateModified": "2026-01-19"
}</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>
<script src="search.js" defer=""></script>
<!-- MathJax for LaTeX formulas -->
<script>
  window.MathJax = { tex: { inlineMath: [['\\(','\\)'], [',
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link rel="preload" href="https://calcdomain.com/assets/js/mobile-menu.js" as="script">
<link rel="preload" href="https://calcdomain.com/assets/js/page-enhancements.js" as="script">


<style>
/* AUDIT_SPINE_CSS */
.auditspine-note{
  border:1px solid #e5e7eb;
  background:#fff;
  border-radius:12px;
  padding:12px;
  color:#475569;
  font-size:13px;
  line-height:1.5;
}
.auditspine-mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
.auditspine-changelog{
  border:1px solid #e5e7eb;
  background:#fff;
  border-left:5px solid #334155;
  border-radius:12px;
  padding:12px;
  font-size:13px;
  color:#475569;
}
.auditspine-formula{
  margin:10px 0;
  background:#0b1220;
  color:#e5e7eb;
  border-radius:12px;
  padding:12px;
  border:1px solid rgba(255,255,255,.12);
  overflow-x:auto;
}
.auditspine-formula pre{margin:8px 0 0; white-space:pre-wrap;}
.auditspine-hr{border:none; border-top:1px solid #e5e7eb; margin:18px 0;}
</style>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://calcdomain.com"
    },
    {
      "@type": "ListItem",
      "position": 2,
      "name": "General",
      "item": "https://calcdomain.com/categories/general"
    },
    {
      "@type": "ListItem",
      "position": 3,
      "name": "Miscellaneous",
      "item": "https://calcdomain.com/subcategories/miscellaneous"
    }
  ]
}
</script>
</head>
<body>
<a class="skip-link" href="#main-content">Skip to main content</a>

<main class="main-content" id="main-content">
<div class="container">
<nav class="text-sm mb-4 text-gray-600" aria-label="Breadcrumbs"><a href="https://calcdomain.com" class="hover:text-blue-600">Home</a> &raquo; <a href="https://calcdomain.com/categories/general" class="hover:text-blue-600">General</a> &raquo; <a href="https://calcdomain.com/subcategories/miscellaneous" class="hover:text-blue-600">Miscellaneous</a></nav>
<h1>NEC Box Fill Calculator</h1>
<p>
        This professional-grade calculator determines the minimum electrical box volume required by the US National Electrical Code (NEC) 314.16(B). It’s designed for electricians, inspectors, and engineers to quickly verify compliance by accounting for insulated conductors, equipment grounding conductors, device yokes, internal clamps, and fittings.
      </p>
<div class="calculator-layout">
<section aria-labelledby="calc-heading" class="calculator-container">
<h2 id="calc-heading">Calculator</h2>
<!-- Box volume -->
<div class="form-group">
<label for="boxVolume">Box marked volume (cubic inches) *</label>
<div class="inline-help">
<button aria-controls="tip-boxVolume" aria-expanded="false" aria-label="Help: box marked volume" class="help-btn" id="tip-boxVolume-btn" type="button">?</button>
</div>
<div class="input-group">
<input aria-describedby="boxVolumeError tip-boxVolume" aria-required="true" class="form-control" id="boxVolume" inputmode="decimal" min="0" placeholder="e.g., 20.3" step="0.25" type="number">
</div>
<div aria-live="polite" class="error-message" id="boxVolumeError" role="alert"></div>
<div aria-hidden="true" class="tooltip" id="tip-boxVolume">
              The box’s cubic-inch volume is required by NEC to be marked by the manufacturer. You’ll typically find it stamped or printed on the box. For multi-gang boxes, enter the total marked volume.
            </div>
<div aria-label="Quick picks for common box volumes" class="quick-picks" role="group">
<button class="chip" data-volume="18" type="button">18 in³</button>
<button class="chip" data-volume="20.3" type="button">20.3 in³</button>
<button class="chip" data-volume="22.5" type="button">22.5 in³</button>
<button class="chip" data-volume="25" type="button">25 in³</button>
<button class="chip" data-volume="32" type="button">32 in³</button>
</div>
</div>
<!-- Insulated conductors -->
<div class="form-group">
<label>Insulated conductors that enter and terminate/splice in this box</label>
<div class="inline-help">
<button aria-controls="tip-conductors" aria-expanded="false" aria-label="Help: insulated conductors" class="help-btn" id="tip-conductors-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-conductors">
              Count all insulated current-carrying conductors that originate outside and terminate or are spliced in the box. Pass-through (unspliced) conductors also count as one each. Do not add extra for pigtails that originate and terminate within this same box (per NEC 314.16(B)).
            </div>
<div aria-live="polite" class="group-list" id="conductorGroups"></div>
<button aria-label="Add conductor group" class="btn btn-secondary" id="addConductorGroup" type="button">+ Add conductor group</button>
</div>
<!-- Equipment grounding conductors -->
<div class="form-group">
<label for="egcCount">Equipment grounding conductors (EGC)</label>
<div class="inline-help">
<button aria-controls="tip-egc" aria-expanded="false" aria-label="Help: equipment grounding conductors" class="help-btn" id="tip-egc-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-egc">
              If one or more EGCs are present, they collectively count as a single conductor volume based on the largest EGC present. Enter the number of EGCs and select the largest EGC AWG.
            </div>
<div class="input-group" style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem">
<div>
<label class="sr-only" for="egcCount">Number of equipment grounding conductors</label>
<input aria-describedby="egcCountError tip-egc" class="form-control" id="egcCount" inputmode="numeric" min="0" placeholder="Count" step="1" type="number">
<div aria-live="polite" class="error-message" id="egcCountError" role="alert"></div>
</div>
<div>
<label class="sr-only" for="egcAwg">Largest EGC size (AWG)</label>
<select aria-describedby="egcAwgError tip-egc" class="form-control" id="egcAwg">
<option value="">Largest EGC AWG</option>
<option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
</select>
<div aria-live="polite" class="error-message" id="egcAwgError" role="alert"></div>
</div>
</div>
</div>
<!-- Device yokes -->
<div class="form-group">
<label>Device yokes (e.g., switches, receptacles)</label>
<div class="inline-help">
<button aria-controls="tip-yokes" aria-expanded="false" aria-label="Help: device yokes" class="help-btn" id="tip-yokes-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-yokes">
              Each yoke that contains one or more devices counts as two conductor volumes, using the largest AWG conductor connected to that yoke. For example, a duplex receptacle on 12 AWG counts as 2 × the 12 AWG volume.
            </div>
<div aria-live="polite" class="group-list" id="yokeGroups"></div>
<button aria-label="Add device yoke group" class="btn btn-secondary" id="addYokeGroup" type="button">+ Add yoke group</button>
</div>
<!-- Clamps and fittings -->
<div class="form-group">
<label for="internalClamps">Internal cable clamps and support fittings</label>
<div class="inline-help">
<button aria-controls="tip-clamps" aria-expanded="false" aria-label="Help: clamps and fittings" class="help-btn" id="tip-clamps-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-clamps">
              Integral internal clamps count as one conductor volume of the largest insulated conductor in the box. Internal support fittings (like hickeys) each count as one conductor volume of the largest insulated conductor in the box.
            </div>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem">
<div class="input-group" style="display:flex; align-items:center; gap:.5rem">
<input aria-describedby="tip-clamps" id="internalClamps" type="checkbox">
<label for="internalClamps" style="margin:0">Internal cable clamps present</label>
</div>
<div>
<label class="sr-only" for="fittingCount">Number of internal fittings</label>
<input aria-describedby="fittingCountError tip-clamps" class="form-control" id="fittingCount" inputmode="numeric" min="0" placeholder="Fittings count" step="1" type="number">
<div aria-live="polite" class="error-message" id="fittingCountError" role="alert"></div>
</div>
</div>
</div>
<div class="form-group" style="display:flex; gap:.5rem; flex-wrap:wrap">
<button class="btn btn-secondary" id="resetForm" type="button">Reset</button>
</div>
<div aria-atomic="true" aria-live="polite" class="results-container">
<div class="results-header">
<h3 style="margin:0">Results</h3>
<span aria-live="polite" class="status-badge status-ok" id="statusBadge"><span aria-hidden="true">●</span>Waiting for inputs</span>
</div>
<div class="result-grid">
<div class="result-card">
<div class="label">Required minimum volume</div>
<div class="value" id="requiredVolume">0.00 in³</div>
</div>
<div class="result-card">
<div class="label">Box marked volume</div>
<div class="value" id="boxVolumeOut">—</div>
</div>
<div class="result-card">
<div class="label">Margin</div>
<div class="value" id="marginOut">—</div>
</div>
<div class="result-card">
<div class="label">Total counted “conductor equivalents”</div>
<div class="value" id="equivOut">0</div>
</div>
</div>
<div class="breakdown">
<h4>Breakdown</h4>
<ul class="breakdown-list" id="breakdownList">
<li><span class="muted">No items yet</span><span>—</span></li>
</ul>
</div>
</div>
</section>
<article aria-labelledby="content-heading" class="calculator-container">
<h2 id="content-heading">Authoritative Engineering Content</h2>
<section>
<h3>Data Source and Methodology</h3>
<p>
              Authoritative source: National Electrical Code (NEC) — NFPA 70 (2020), Article 314.16 and Table 314.16(B).
              <a href="https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70" rel="noopener" target="_blank">Official NFPA code page</a>
              (free view with account).
            </p>
<p><strong>All calculations strictly follow the formulas and allowances provided by this source.</strong></p>
<ul>
<li>Insulated conductors that enter and terminate/splice in the box: count 1 each.</li>
<li>Pass-through (unspliced) insulated conductors: count 1 each.</li>
<li>Equipment grounding conductors (all): count as 1 volume using the largest EGC present.</li>
<li>Each device yoke: counts as 2 volumes using the largest conductor connected to that yoke.</li>
<li>Integral internal clamps: count as 1 volume of the largest insulated conductor entering the box.</li>
<li>Internal fittings (e.g., hickeys): count as 1 volume each of the largest insulated conductor in the box.</li>
</ul>
<p class="field-help">
              For additional background see:
              <a href="https://www.ecmweb.com/content/article/20886012/box-fill-calculations" rel="noopener" target="_blank">ECM: Box Fill Calculations</a>,
              <a href="https://www.jadelearning.com/blog/nec-2017-article-314-16/" rel="noopener" target="_blank">JADE Learning: NEC 314.16</a>.
            </p>
</section>
<section>
<h3>The Formula Explained</h3>
<div aria-label="Mathematical formulas in LaTeX" class="formula-box">
<div style="font-family:var(--font-mono); font-size:1rem">
                Given the NEC volume allowance function V(AWG) from Table 314.16(B):<br>
                18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00 (cubic inches)
                <hr>
                Total required volume:<br>
                $$V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})$$
                where:<br>
                - $n_i$ = insulated conductors of size $\mathrm{AWG}_i$ that enter and terminate/splice (pass-through counts as 1).<br>
                - $\mathrm{EGC,max}$ = largest equipment grounding conductor AWG (counted once if any EGCs are present).<br>
                - $y_j$ = number of device yokes connected to conductors of $\mathrm{AWG}_{y_j}$ (each counts as 2 conductors).<br>
                - $\mathrm{AWG}_{\max}$ = largest insulated conductor AWG present in the box (used for clamp and fitting allowances).<br>
                - $f$ = number of internal support fittings.
              </div>
</div>
</section>
<section>
<h3>Glossary of Variables</h3>
<ul>
<li>Box marked volume (in³): Manufacturer-stamped cubic-inch capacity of the box.</li>
<li>Insulated conductors: Current-carrying conductors that enter and terminate or splice in the box; pass-throughs count once; pigtails within same box add no extra count.</li>
<li>Equipment grounding conductors (EGC): Green/bare conductors; all EGCs together count as one conductor volume using the largest EGC present.</li>
<li>Device yoke: A strap holding one or more devices (e.g., duplex receptacle). Each yoke counts as two conductors of the largest conductor on that yoke.</li>
<li>Internal clamps: Integral cable clamps inside the box; count as one conductor of the largest insulated conductor present.</li>
<li>Internal fittings: Accessories like hickeys; each counts as one conductor of the largest insulated conductor present.</li>
<li>V(AWG): NEC Table 314.16(B) volume per conductor size (in³): 18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00.</li>
</ul>
</section>
<section>
<h3>How It Works: A Step-by-Step Example</h3>
<p><strong>Scenario.</strong> Box contains: six 12 AWG insulated conductors; one duplex receptacle on 12 AWG (one yoke); two EGCs with largest EGC 12 AWG; integral clamps present; no fittings. Box marked volume = 20.3 in³.</p>
<ol>
<li>Conductor allowance: 6 × V(12) = 6 × 2.25 = 13.50 in³.</li>
<li>EGC allowance: present → 1 × V(12) = 2.25 in³.</li>
<li>Device yoke: 1 yoke → 2 × V(12) = 4.50 in³.</li>
<li>Clamp: present → 1 × V(12) = 2.25 in³.</li>
<li>Fittings: none → 0.</li>
<li>Total required: 13.50 + 2.25 + 4.50 + 2.25 = <strong>22.50 in³</strong>.</li>
<li>Comparison: 20.3 in³ box <strong>does not comply</strong> (short by 2.2 in³).</li>
</ol>
</section>
<section>
<h3>FAQ</h3>
<details>
<summary>Do pigtails count toward box fill?</summary>
<p>No additional count for pigtails that originate and terminate in the same box. Their conductors are already included per NEC 314.16(B).</p>
</details>
<details>
<summary>How are equipment grounding conductors counted?</summary>
<p>All EGCs taken together count as a single conductor volume based on the largest EGC present.</p>
</details>
<details>
<summary>Do pass-through conductors count?</summary>
<p>Yes. Each insulated pass-through (unspliced) conductor counts as one conductor volume.</p>
</details>
<details>
<summary>How do devices like duplex receptacles count?</summary>
<p>Each yoke counts as two conductor volumes using the largest conductor attached to that yoke.</p>
</details>
<details>
<summary>Do internal clamps and fittings count?</summary>
<p>Internal clamps count as one conductor volume; each internal fitting counts as one, both based on the largest insulated conductor in the box.</p>
</details>
<details>
<summary>Which AWG sizes are supported?</summary>
<p>18, 16, 14, 12, 10, 8, and 6 AWG, using the cubic-inch values in NEC Table 314.16(B).</p>
</details>
<details>
<summary>Can I use this for multi-gang boxes?</summary>
<p>Yes. Enter the total manufacturer-marked volume (sum of gangs) and include all conductors/devices in the calculation.</p>
</details>
</section>
<div class="author-box">
<p>
            </p>
</div>

<!-- AUDIT_SPINE_START -->
<hr class="auditspine-hr">
<section aria-label="Formulas, sources, changelog, verification">
  <span class="auditspine-badge">Audit: Complete</span>

  <details style="margin-top:10px">
    <summary><strong>Formula (LaTeX) + variables + units</strong></summary>
    <div class="auditspine-note" style="margin-top:10px">
      This section shows the formulas used by the calculator engine, plus variable definitions and units.
      
    </div>
    <div class="auditspine-formula">
      <div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[','\]</div>
  <pre class="auditspine-mono">','</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&amp;gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})\]</div>
  <pre class="auditspine-mono">V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&amp;gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[= (sel, ctx=document) =&gt; Array.from(ctx.querySelectorAll(sel)); const els = { boxVolume: $('#boxVolume'), boxVolumeError: $('#boxVolumeError'), quickPicks:\]</div>
  <pre class="auditspine-mono">= (sel, ctx=document) =&gt; Array.from(ctx.querySelectorAll(sel)); const els = { boxVolume: $('#boxVolume'), boxVolumeError: $('#boxVolumeError'), quickPicks:</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[('.help-btn'), }; function createConductorRow(initial = {awg:'', count:''}) { const rowId = `cg-${conductorRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'conductor-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Count of insulated conductors&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this conductor group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.conductorGroups.appendChild(row); } function createYokeRow(initial = {awg:'', count:''}) { const rowId = `yg-${yokeRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'yoke-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Device yoke conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Number of device yokes&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this yoke group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.yokeGroups.appendChild(row); } // Validation helpers function setError(el, msg) { el.textContent = msg || ''; } function markInvalid(input, invalid, describedById) { input.setAttribute('aria-invalid', invalid ? 'true' : 'false'); if (describedById) input.setAttribute('aria-describedby', describedById); } function parseIntSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } function parseFloatSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } // Field-specific validation function validateBoxVolume() { const val = parseFloatSafe(els.boxVolume.value); if (isNaN(val)) { setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } if (val &lt;= 0) { setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } setError(els.boxVolumeError, ''); markInvalid(els.boxVolume, false, 'boxVolumeError'); return val; } function validateEgc() { const count = parseIntSafe(els.egcCount.value); const awg = els.egcAwg.value; let ok = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { setError(els.egcCountError, 'Count cannot be negative.'); markInvalid(els.egcCount, true, 'egcCountError'); ok = false; } else { setError(els.egcCountError, ''); markInvalid(els.egcCount, false, 'egcCountError'); } if (count &gt; 0 &amp;&amp; !awg) { setError(els.egcAwgError, 'Select the largest EGC size (AWG).'); markInvalid(els.egcAwg, true, 'egcAwgError'); ok = false; } else { setError(els.egcAwgError, ''); markInvalid(els.egcAwg, false, 'egcAwgError'); } return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null; } function validateFittings() { const count = parseIntSafe(els.fittingCount.value); if (isNaN(count)) { setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return 0; } if (count &lt; 0) { setError(els.fittingCountError, 'Count cannot be negative.'); markInvalid(els.fittingCount, true, 'fittingCountError'); return null; } setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return count; } function validateGroupRow(row) { const isConductor = row.getAttribute('data-role') === 'conductor-row'; const idPrefix = row.querySelector('select').id.replace(/-awg$/, ''); const sel = row.querySelector(`#${idPrefix}-awg`); const cntInput = row.querySelector(`#${idPrefix}-count`); const err = row.querySelector(`#${idPrefix}-error`); const count = parseIntSafe(cntInput.value); const awg = sel.value; let valid = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { err.textContent = 'Count cannot be negative.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } else { cntInput.setAttribute('aria-invalid','false'); } if ((count || count === 0) &amp;&amp; count &gt; 0 &amp;&amp; !awg) { err.textContent = 'Select an AWG size for this group.'; sel.setAttribute('aria-invalid','true'); valid = false; } else { sel.setAttribute('aria-invalid','false'); } if ((count === 0 || isNaN(count)) &amp;&amp; !awg) { err.textContent = ''; } else if (valid) { err.textContent = ''; } // For yokes, ensure integer counts if (row.getAttribute('data-role') === 'yoke-row' &amp;&amp; !isNaN(count) &amp;&amp; !Number.isInteger(count)) { err.textContent = 'Number of yokes must be a whole number.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } return valid ? { count: isNaN(count) ? 0 : count, awg: awg || '' } : null; } function collectInputs() { // Box volume can be null (not provided); we still compute required const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume(); // Conductors const conductors = []; for (const row of\]</div>
  <pre class="auditspine-mono">('.help-btn'), }; function createConductorRow(initial = {awg:'', count:''}) { const rowId = `cg-${conductorRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'conductor-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Count of insulated conductors&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this conductor group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.conductorGroups.appendChild(row); } function createYokeRow(initial = {awg:'', count:''}) { const rowId = `yg-${yokeRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'yoke-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Device yoke conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Number of device yokes&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this yoke group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.yokeGroups.appendChild(row); } // Validation helpers function setError(el, msg) { el.textContent = msg || ''; } function markInvalid(input, invalid, describedById) { input.setAttribute('aria-invalid', invalid ? 'true' : 'false'); if (describedById) input.setAttribute('aria-describedby', describedById); } function parseIntSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } function parseFloatSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } // Field-specific validation function validateBoxVolume() { const val = parseFloatSafe(els.boxVolume.value); if (isNaN(val)) { setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } if (val &lt;= 0) { setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } setError(els.boxVolumeError, ''); markInvalid(els.boxVolume, false, 'boxVolumeError'); return val; } function validateEgc() { const count = parseIntSafe(els.egcCount.value); const awg = els.egcAwg.value; let ok = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { setError(els.egcCountError, 'Count cannot be negative.'); markInvalid(els.egcCount, true, 'egcCountError'); ok = false; } else { setError(els.egcCountError, ''); markInvalid(els.egcCount, false, 'egcCountError'); } if (count &gt; 0 &amp;&amp; !awg) { setError(els.egcAwgError, 'Select the largest EGC size (AWG).'); markInvalid(els.egcAwg, true, 'egcAwgError'); ok = false; } else { setError(els.egcAwgError, ''); markInvalid(els.egcAwg, false, 'egcAwgError'); } return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null; } function validateFittings() { const count = parseIntSafe(els.fittingCount.value); if (isNaN(count)) { setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return 0; } if (count &lt; 0) { setError(els.fittingCountError, 'Count cannot be negative.'); markInvalid(els.fittingCount, true, 'fittingCountError'); return null; } setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return count; } function validateGroupRow(row) { const isConductor = row.getAttribute('data-role') === 'conductor-row'; const idPrefix = row.querySelector('select').id.replace(/-awg$/, ''); const sel = row.querySelector(`#${idPrefix}-awg`); const cntInput = row.querySelector(`#${idPrefix}-count`); const err = row.querySelector(`#${idPrefix}-error`); const count = parseIntSafe(cntInput.value); const awg = sel.value; let valid = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { err.textContent = 'Count cannot be negative.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } else { cntInput.setAttribute('aria-invalid','false'); } if ((count || count === 0) &amp;&amp; count &gt; 0 &amp;&amp; !awg) { err.textContent = 'Select an AWG size for this group.'; sel.setAttribute('aria-invalid','true'); valid = false; } else { sel.setAttribute('aria-invalid','false'); } if ((count === 0 || isNaN(count)) &amp;&amp; !awg) { err.textContent = ''; } else if (valid) { err.textContent = ''; } // For yokes, ensure integer counts if (row.getAttribute('data-role') === 'yoke-row' &amp;&amp; !isNaN(count) &amp;&amp; !Number.isInteger(count)) { err.textContent = 'Number of yokes must be a whole number.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } return valid ? { count: isNaN(count) ? 0 : count, awg: awg || '' } : null; } function collectInputs() { // Box volume can be null (not provided); we still compute required const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume(); // Conductors const conductors = []; for (const row of</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[('#yokeGroups .group-row')) { const v = validateGroupRow(row); if (v === null) return null; // invalid if (v.count &gt; 0 &amp;&amp; v.awg) yokes.push(v); } // EGC const egc = validateEgc(); if (egc === null) return null; // Fittings const fittings = validateFittings(); if (fittings === null) return null; const clamps = els.internalClamps.checked; return { boxVol, conductors, yokes, egc, fittings, clamps }; } function largestInsulatedAWG(conductors, yokes) { // Return the physically largest conductor (smallest AWG number) // We compare by numerical value, but NEC table is discrete for listed sizes only. const sizes = new Set(); conductors.forEach(c =&gt; sizes.add(c.awg)); yokes.forEach(y =&gt; sizes.add(y.awg)); const arr = Array.from(sizes).map(Number).filter(Boolean); if (arr.length === 0) return null; // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12) return Math.min(...arr); } function compute() { const input = collectInputs(); if (!input) { // Invalid fields; keep results minimal renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []}); return; } const { boxVol, conductors, yokes, egc, fittings, clamps } = input; // Aggregate by AWG for conductors let breakdown = []; let required = 0; let equivalents = 0; // Conductors const condMap = new Map(); for (const c of conductors) { const cnt = condMap.get(c.awg) || 0; condMap.set(c.awg, cnt + c.count); } for (const [awg, count] of condMap) { const vol = (VOLUME_BY_AWG[awg] || 0) * count; required += vol; equivalents += count; breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol}); } // EGC (all count as one of largest EGC present) if (egc.count &gt; 0 &amp;&amp; egc.awg) { const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol}); } // Yokes for (const y of yokes) { const addEq = y.count * 2; const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq; required += vol; equivalents += addEq; breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol}); } // Largest insulated AWG for clamps/fittings const awgMax = largestInsulatedAWG(conductors, yokes); if (clamps &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol}); } if (fittings &gt; 0 &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings; required += vol; equivalents += fittings; breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol}); } const result = { required, box: boxVol, margin: (typeof boxVol === 'number') ? (boxVol - required) : null, ok: (typeof boxVol === 'number') ? (boxVol &gt;= required) : null, equiv: equivalents, breakdown }; renderResults(result); } function formatIn3(n) { return `${n.toFixed(2)} in³`; } function readBoxVolOrNull(){ const v = parseFloatSafe(els.boxVolume.value); return isNaN(v) ? null : v; } function renderResults({required, box, margin, ok, equiv, breakdown}) { // Required $('#requiredVolume').textContent = formatIn3(required || 0); // Box and margin if (typeof box === 'number') { $('#boxVolumeOut').textContent = formatIn3(box); const mEl = $('#marginOut'); if (typeof margin === 'number') { const pct = (box &gt; 0) ? (margin / box * 100) : 0; mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`; mEl.className = 'value ' + (margin &gt;= 0 ? 'value-ok' : 'value-bad'); } else { mEl.textContent = '—'; mEl.className = 'value'; } } else { $('#boxVolumeOut').textContent = '—'; $('#marginOut').textContent = '—'; $('#marginOut').className = 'value'; } // Equivalents $('#equivOut').textContent = String(equiv || 0); // Status const status = $('#statusBadge'); if (ok === null) { status.className = 'status-badge'; status.textContent = 'Waiting for inputs'; } else if (ok) { status.className = 'status-badge status-ok'; status.textContent = 'Compliant ✓'; } else { status.className = 'status-badge status-fail'; status.textContent = 'Not compliant ✕'; } // Breakdown const list = $('#breakdownList'); list.innerHTML = ''; if (!breakdown || breakdown.length === 0) { const li = document.createElement('li'); li.innerHTML = '&lt;span class="muted"&gt;No items yet&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;'; list.appendChild(li); } else { for (const item of breakdown) { const li = document.createElement('li'); const left = document.createElement('span'); const right = document.createElement('span'); left.textContent = item.label; right.textContent = formatIn3(item.vol); li.appendChild(left); li.appendChild(right); list.appendChild(li); } } } // Event wiring function onBlurRecalc(e) { const target = e.target; if (target.matches('input, select')) { // Validate specific fields if (target === els.boxVolume) validateBoxVolume(); if (target === els.egcCount || target === els.egcAwg) validateEgc(); if (target === els.fittingCount) validateFittings(); if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row')); compute(); } } function onClick(e){ const t = e.target; // Quick pick chips if (t.matches('.chip[data-volume]')) { els.boxVolume.value = t.getAttribute('data-volume'); validateBoxVolume(); compute(); } // Add/Remove rows if (t === els.addConductorGroup) { createConductorRow({awg:'', count:''}); // Move focus into new row count const rows =\]</div>
  <pre class="auditspine-mono">('#yokeGroups .group-row')) { const v = validateGroupRow(row); if (v === null) return null; // invalid if (v.count &gt; 0 &amp;&amp; v.awg) yokes.push(v); } // EGC const egc = validateEgc(); if (egc === null) return null; // Fittings const fittings = validateFittings(); if (fittings === null) return null; const clamps = els.internalClamps.checked; return { boxVol, conductors, yokes, egc, fittings, clamps }; } function largestInsulatedAWG(conductors, yokes) { // Return the physically largest conductor (smallest AWG number) // We compare by numerical value, but NEC table is discrete for listed sizes only. const sizes = new Set(); conductors.forEach(c =&gt; sizes.add(c.awg)); yokes.forEach(y =&gt; sizes.add(y.awg)); const arr = Array.from(sizes).map(Number).filter(Boolean); if (arr.length === 0) return null; // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12) return Math.min(...arr); } function compute() { const input = collectInputs(); if (!input) { // Invalid fields; keep results minimal renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []}); return; } const { boxVol, conductors, yokes, egc, fittings, clamps } = input; // Aggregate by AWG for conductors let breakdown = []; let required = 0; let equivalents = 0; // Conductors const condMap = new Map(); for (const c of conductors) { const cnt = condMap.get(c.awg) || 0; condMap.set(c.awg, cnt + c.count); } for (const [awg, count] of condMap) { const vol = (VOLUME_BY_AWG[awg] || 0) * count; required += vol; equivalents += count; breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol}); } // EGC (all count as one of largest EGC present) if (egc.count &gt; 0 &amp;&amp; egc.awg) { const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol}); } // Yokes for (const y of yokes) { const addEq = y.count * 2; const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq; required += vol; equivalents += addEq; breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol}); } // Largest insulated AWG for clamps/fittings const awgMax = largestInsulatedAWG(conductors, yokes); if (clamps &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol}); } if (fittings &gt; 0 &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings; required += vol; equivalents += fittings; breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol}); } const result = { required, box: boxVol, margin: (typeof boxVol === 'number') ? (boxVol - required) : null, ok: (typeof boxVol === 'number') ? (boxVol &gt;= required) : null, equiv: equivalents, breakdown }; renderResults(result); } function formatIn3(n) { return `${n.toFixed(2)} in³`; } function readBoxVolOrNull(){ const v = parseFloatSafe(els.boxVolume.value); return isNaN(v) ? null : v; } function renderResults({required, box, margin, ok, equiv, breakdown}) { // Required $('#requiredVolume').textContent = formatIn3(required || 0); // Box and margin if (typeof box === 'number') { $('#boxVolumeOut').textContent = formatIn3(box); const mEl = $('#marginOut'); if (typeof margin === 'number') { const pct = (box &gt; 0) ? (margin / box * 100) : 0; mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`; mEl.className = 'value ' + (margin &gt;= 0 ? 'value-ok' : 'value-bad'); } else { mEl.textContent = '—'; mEl.className = 'value'; } } else { $('#boxVolumeOut').textContent = '—'; $('#marginOut').textContent = '—'; $('#marginOut').className = 'value'; } // Equivalents $('#equivOut').textContent = String(equiv || 0); // Status const status = $('#statusBadge'); if (ok === null) { status.className = 'status-badge'; status.textContent = 'Waiting for inputs'; } else if (ok) { status.className = 'status-badge status-ok'; status.textContent = 'Compliant ✓'; } else { status.className = 'status-badge status-fail'; status.textContent = 'Not compliant ✕'; } // Breakdown const list = $('#breakdownList'); list.innerHTML = ''; if (!breakdown || breakdown.length === 0) { const li = document.createElement('li'); li.innerHTML = '&lt;span class="muted"&gt;No items yet&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;'; list.appendChild(li); } else { for (const item of breakdown) { const li = document.createElement('li'); const left = document.createElement('span'); const right = document.createElement('span'); left.textContent = item.label; right.textContent = formatIn3(item.vol); li.appendChild(left); li.appendChild(right); list.appendChild(li); } } } // Event wiring function onBlurRecalc(e) { const target = e.target; if (target.matches('input, select')) { // Validate specific fields if (target === els.boxVolume) validateBoxVolume(); if (target === els.egcCount || target === els.egcAwg) validateEgc(); if (target === els.fittingCount) validateFittings(); if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row')); compute(); } } function onClick(e){ const t = e.target; // Quick pick chips if (t.matches('.chip[data-volume]')) { els.boxVolume.value = t.getAttribute('data-volume'); validateBoxVolume(); compute(); } // Add/Remove rows if (t === els.addConductorGroup) { createConductorRow({awg:'', count:''}); // Move focus into new row count const rows =</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted text)</strong></div>
  
  <pre class="auditspine-mono">Given the NEC volume allowance function V(AWG) from Table 314.16(B): 18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00 (cubic inches) Total required volume: $V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})$ where: - $n_i$ = insulated conductors of size $\mathrm{AWG}_i$ that enter and terminate/splice (pass-through counts as 1). - $\mathrm{EGC,max}$ = largest equipment grounding conductor AWG (counted once if any EGCs are present). - $y_j$ = number of device yokes connected to conductors of $\mathrm{AWG}_{y_j}$ (each counts as 2 conductors). - $\mathrm{AWG}_{\max}$ = largest insulated conductor AWG present in the box (used for clamp and fitting allowances). - $f$ = number of internal support fittings.</pre>
</div>
      <div style="margin-top:12px"><strong>Variables and units</strong></div>
      <ul style="margin:8px 0 0 18px">
        <li><em>No variables provided in audit spec.</em></li>
      </ul>
    </div>
  </details>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Sources (authoritative):</strong>
    <ul style="margin:8px 0 0 18px">
      <li><strong>Engineering</strong> — calcdomain.com · Accessed 2026-01-19<br><a href="https://calcdomain.com/engineering" target="_blank" rel="nofollow noopener">https://calcdomain.com/engineering</a></li>
<li><strong>Electrical (US NEC)</strong> — calcdomain.com · Accessed 2026-01-19<br><a href="https://calcdomain.com/subcategories/electrical" target="_blank" rel="nofollow noopener">https://calcdomain.com/subcategories/electrical</a></li>
<li><strong>Official NFPA code page</strong> — nfpa.org · Accessed 2026-01-19<br><a href="https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70" target="_blank" rel="nofollow noopener">https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70</a></li>
<li><strong>ECM: Box Fill Calculations</strong> — ecmweb.com · Accessed 2026-01-19<br><a href="https://www.ecmweb.com/content/article/20886012/box-fill-calculations" target="_blank" rel="nofollow noopener">https://www.ecmweb.com/content/article/20886012/box-fill-calculations</a></li>
<li><strong>JADE Learning: NEC 314.16</strong> — jadelearning.com · Accessed 2026-01-19<br><a href="https://www.jadelearning.com/blog/nec-2017-article-314-16/" target="_blank" rel="nofollow noopener">https://www.jadelearning.com/blog/nec-2017-article-314-16/</a></li>
    </ul>
  </div>

  <div class="auditspine-changelog" style="margin-top:12px">
    <strong>Changelog</strong><br>
    <div style="margin-top:6px">
      <strong>Version:</strong> 0.1.0-draft<br>
      <strong>Last code update:</strong> 2026-01-19
    </div>
    <div style="margin-top:10px">
  <strong>0.1.0-draft</strong> · 2026-01-19
  <ul style="margin:6px 0 0 18px">
    <li>Initial audit spec draft generated from HTML extraction (review required).</li>
<li>Verify formulas match the calculator engine and convert any text-only formulas to LaTeX.</li>
<li>Confirm sources are authoritative and relevant to the calculator methodology.</li>
  </ul>
</div>
  </div>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Verified by Ugo Candido on 2026-01-19</strong><br>
    <a href="https://calcdomain.com/ugocandido" target="_blank" rel="noopener">Profile</a> ·
    <a href="https://www.linkedin.com/in/ugocandido92821/" target="_blank" rel="noopener">LinkedIn</a>
  </div>
</section>
<!-- AUDIT_SPINE_END -->
</article>
</div>
</div>
</main>
<!-- Standard Footer --> 
<script defer="">
    (function(){
      'use strict';

      // Volume allowances per NEC Table 314.16(B) in cubic inches
      const VOLUME_BY_AWG = {
        18: 1.50,
        16: 1.75,
        14: 2.00,
        12: 2.25,
        10: 2.50,
        8: 3.00,
        6: 5.00
      };

      // State
      let conductorRowId = 0;
      let yokeRowId = 0;

      const $ = (sel, ctx=document) => ctx.querySelector(sel);
      const $$ = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));

      const els = {
        boxVolume: $('#boxVolume'),
        boxVolumeError: $('#boxVolumeError'),
        quickPicks: $$('.chip[data-volume]'),
        statusBadge: $('#statusBadge'),
        requiredVolume: $('#requiredVolume'),
        boxVolumeOut: $('#boxVolumeOut'),
        marginOut: $('#marginOut'),
        equivOut: $('#equivOut'),
        breakdownList: $('#breakdownList'),
        conductorGroups: $('#conductorGroups'),
        addConductorGroup: $('#addConductorGroup'),
        egcCount: $('#egcCount'),
        egcCountError: $('#egcCountError'),
        egcAwg: $('#egcAwg'),
        egcAwgError: $('#egcAwgError'),
        yokeGroups: $('#yokeGroups'),
        addYokeGroup: $('#addYokeGroup'),
        internalClamps: $('#internalClamps'),
        fittingCount: $('#fittingCount'),
        fittingCountError: $('#fittingCountError'),
        resetForm: $('#resetForm'),

        // Tooltips
        tipBtns: $$('.help-btn'),
      };

      function createConductorRow(initial = {awg:'', count:''}) {
        const rowId = `cg-${conductorRowId++}`;
        const row = document.createElement('div');
        row.className = 'group-row';
        row.setAttribute('data-role', 'conductor-row');
        row.innerHTML = `
          <div>
            <label class="sr-only" for="${rowId}-awg">Conductor size (AWG)</label>
            <select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error">
              <option value="">AWG size</option>
              <option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
            </select>
          </div>
          <div>
            <label class="sr-only" for="${rowId}-count">Count of insulated conductors</label>
            <input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error">
          </div>
          <div style="display:flex; gap:.5rem; align-items:center">
            <button class="remove-btn" type="button" aria-label="Remove this conductor group">Remove</button>
          </div>
          <div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"></div>
        `;
        if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg;
        if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count;
        els.conductorGroups.appendChild(row);
      }

      function createYokeRow(initial = {awg:'', count:''}) {
        const rowId = `yg-${yokeRowId++}`;
        const row = document.createElement('div');
        row.className = 'group-row';
        row.setAttribute('data-role', 'yoke-row');
        row.innerHTML = `
          <div>
            <label class="sr-only" for="${rowId}-awg">Device yoke conductor size (AWG)</label>
            <select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error">
              <option value="">AWG size</option>
              <option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
            </select>
          </div>
          <div>
            <label class="sr-only" for="${rowId}-count">Number of device yokes</label>
            <input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error">
          </div>
          <div style="display:flex; gap:.5rem; align-items:center">
            <button class="remove-btn" type="button" aria-label="Remove this yoke group">Remove</button>
          </div>
          <div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"></div>
        `;
        if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg;
        if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count;
        els.yokeGroups.appendChild(row);
      }

      // Validation helpers
      function setError(el, msg) {
        el.textContent = msg || '';
      }
      function markInvalid(input, invalid, describedById) {
        input.setAttribute('aria-invalid', invalid ? 'true' : 'false');
        if (describedById) input.setAttribute('aria-describedby', describedById);
      }
      function parseIntSafe(value) {
        if (value === '' || value === null || value === undefined) return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
      }
      function parseFloatSafe(value) {
        if (value === '' || value === null || value === undefined) return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
      }

      // Field-specific validation
      function validateBoxVolume() {
        const val = parseFloatSafe(els.boxVolume.value);
        if (isNaN(val)) {
          setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.');
          markInvalid(els.boxVolume, true, 'boxVolumeError');
          return null;
        }
        if (val <= 0) {
          setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.');
          markInvalid(els.boxVolume, true, 'boxVolumeError');
          return null;
        }
        setError(els.boxVolumeError, '');
        markInvalid(els.boxVolume, false, 'boxVolumeError');
        return val;
      }

      function validateEgc() {
        const count = parseIntSafe(els.egcCount.value);
        const awg = els.egcAwg.value;
        let ok = true;

        if (!isNaN(count) && count < 0) {
          setError(els.egcCountError, 'Count cannot be negative.');
          markInvalid(els.egcCount, true, 'egcCountError');
          ok = false;
        } else {
          setError(els.egcCountError, '');
          markInvalid(els.egcCount, false, 'egcCountError');
        }

        if (count > 0 && !awg) {
          setError(els.egcAwgError, 'Select the largest EGC size (AWG).');
          markInvalid(els.egcAwg, true, 'egcAwgError');
          ok = false;
        } else {
          setError(els.egcAwgError, '');
          markInvalid(els.egcAwg, false, 'egcAwgError');
        }

        return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null;
      }

      function validateFittings() {
        const count = parseIntSafe(els.fittingCount.value);
        if (isNaN(count)) {
          setError(els.fittingCountError, '');
          markInvalid(els.fittingCount, false, 'fittingCountError');
          return 0;
        }
        if (count < 0) {
          setError(els.fittingCountError, 'Count cannot be negative.');
          markInvalid(els.fittingCount, true, 'fittingCountError');
          return null;
        }
        setError(els.fittingCountError, '');
        markInvalid(els.fittingCount, false, 'fittingCountError');
        return count;
      }

      function validateGroupRow(row) {
        const isConductor = row.getAttribute('data-role') === 'conductor-row';
        const idPrefix = row.querySelector('select').id.replace(/-awg$/, '');
        const sel = row.querySelector(`#${idPrefix}-awg`);
        const cntInput = row.querySelector(`#${idPrefix}-count`);
        const err = row.querySelector(`#${idPrefix}-error`);

        const count = parseIntSafe(cntInput.value);
        const awg = sel.value;
        let valid = true;

        if (!isNaN(count) && count < 0) {
          err.textContent = 'Count cannot be negative.';
          cntInput.setAttribute('aria-invalid','true');
          valid = false;
        } else {
          cntInput.setAttribute('aria-invalid','false');
        }

        if ((count || count === 0) && count > 0 && !awg) {
          err.textContent = 'Select an AWG size for this group.';
          sel.setAttribute('aria-invalid','true');
          valid = false;
        } else {
          sel.setAttribute('aria-invalid','false');
        }

        if ((count === 0 || isNaN(count)) && !awg) {
          err.textContent = '';
        } else if (valid) {
          err.textContent = '';
        }

        // For yokes, ensure integer counts
        if (row.getAttribute('data-role') === 'yoke-row' && !isNaN(count) && !Number.isInteger(count)) {
          err.textContent = 'Number of yokes must be a whole number.';
          cntInput.setAttribute('aria-invalid','true');
          valid = false;
        }

        return valid ? {
          count: isNaN(count) ? 0 : count,
          awg: awg || ''
        } : null;
      }

      function collectInputs() {
        // Box volume can be null (not provided); we still compute required
        const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume();

        // Conductors
        const conductors = [];
        for (const row of $$('#conductorGroups .group-row')) {
          const v = validateGroupRow(row);
          if (v === null) return null; // invalid
          if (v.count > 0 && v.awg) conductors.push(v);
        }

        // Yokes
        const yokes = [];
        for (const row of $$('#yokeGroups .group-row')) {
          const v = validateGroupRow(row);
          if (v === null) return null; // invalid
          if (v.count > 0 && v.awg) yokes.push(v);
        }

        // EGC
        const egc = validateEgc();
        if (egc === null) return null;

        // Fittings
        const fittings = validateFittings();
        if (fittings === null) return null;

        const clamps = els.internalClamps.checked;

        return { boxVol, conductors, yokes, egc, fittings, clamps };
      }

      function largestInsulatedAWG(conductors, yokes) {
        // Return the physically largest conductor (smallest AWG number)
        // We compare by numerical value, but NEC table is discrete for listed sizes only.
        const sizes = new Set();
        conductors.forEach(c => sizes.add(c.awg));
        yokes.forEach(y => sizes.add(y.awg));
        const arr = Array.from(sizes).map(Number).filter(Boolean);
        if (arr.length === 0) return null;
        // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12)
        return Math.min(...arr);
      }

      function compute() {
        const input = collectInputs();
        if (!input) {
          // Invalid fields; keep results minimal
          renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []});
          return;
        }

        const { boxVol, conductors, yokes, egc, fittings, clamps } = input;

        // Aggregate by AWG for conductors
        let breakdown = [];
        let required = 0;
        let equivalents = 0;

        // Conductors
        const condMap = new Map();
        for (const c of conductors) {
          const cnt = condMap.get(c.awg) || 0;
          condMap.set(c.awg, cnt + c.count);
        }
        for (const [awg, count] of condMap) {
          const vol = (VOLUME_BY_AWG[awg] || 0) * count;
          required += vol;
          equivalents += count;
          breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol});
        }

        // EGC (all count as one of largest EGC present)
        if (egc.count > 0 && egc.awg) {
          const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1;
          required += vol;
          equivalents += 1;
          breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol});
        }

        // Yokes
        for (const y of yokes) {
          const addEq = y.count * 2;
          const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq;
          required += vol;
          equivalents += addEq;
          breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol});
        }

        // Largest insulated AWG for clamps/fittings
        const awgMax = largestInsulatedAWG(conductors, yokes);
        if (clamps && awgMax) {
          const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1;
          required += vol;
          equivalents += 1;
          breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol});
        }
        if (fittings > 0 && awgMax) {
          const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings;
          required += vol;
          equivalents += fittings;
          breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol});
        }

        const result = {
          required,
          box: boxVol,
          margin: (typeof boxVol === 'number') ? (boxVol - required) : null,
          ok: (typeof boxVol === 'number') ? (boxVol >= required) : null,
          equiv: equivalents,
          breakdown
        };

        renderResults(result);
      }

      function formatIn3(n) {
        return `${n.toFixed(2)} in³`;
      }

      function readBoxVolOrNull(){
        const v = parseFloatSafe(els.boxVolume.value);
        return isNaN(v) ? null : v;
      }

      function renderResults({required, box, margin, ok, equiv, breakdown}) {
        // Required
        $('#requiredVolume').textContent = formatIn3(required || 0);

        // Box and margin
        if (typeof box === 'number') {
          $('#boxVolumeOut').textContent = formatIn3(box);
          const mEl = $('#marginOut');
          if (typeof margin === 'number') {
            const pct = (box > 0) ? (margin / box * 100) : 0;
            mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`;
            mEl.className = 'value ' + (margin >= 0 ? 'value-ok' : 'value-bad');
          } else {
            mEl.textContent = '—';
            mEl.className = 'value';
          }
        } else {
          $('#boxVolumeOut').textContent = '—';
          $('#marginOut').textContent = '—';
          $('#marginOut').className = 'value';
        }

        // Equivalents
        $('#equivOut').textContent = String(equiv || 0);

        // Status
        const status = $('#statusBadge');
        if (ok === null) {
          status.className = 'status-badge';
          status.textContent = 'Waiting for inputs';
        } else if (ok) {
          status.className = 'status-badge status-ok';
          status.textContent = 'Compliant ✓';
        } else {
          status.className = 'status-badge status-fail';
          status.textContent = 'Not compliant ✕';
        }

        // Breakdown
        const list = $('#breakdownList');
        list.innerHTML = '';
        if (!breakdown || breakdown.length === 0) {
          const li = document.createElement('li');
          li.innerHTML = '<span class="muted">No items yet</span><span>—</span>';
          list.appendChild(li);
        } else {
          for (const item of breakdown) {
            const li = document.createElement('li');
            const left = document.createElement('span');
            const right = document.createElement('span');
            left.textContent = item.label;
            right.textContent = formatIn3(item.vol);
            li.appendChild(left);
            li.appendChild(right);
            list.appendChild(li);
          }
        }
      }

      // Event wiring
      function onBlurRecalc(e) {
        const target = e.target;
        if (target.matches('input, select')) {
          // Validate specific fields
          if (target === els.boxVolume) validateBoxVolume();
          if (target === els.egcCount || target === els.egcAwg) validateEgc();
          if (target === els.fittingCount) validateFittings();
          if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row'));
          compute();
        }
      }

      function onClick(e){
        const t = e.target;

        // Quick pick chips
        if (t.matches('.chip[data-volume]')) {
          els.boxVolume.value = t.getAttribute('data-volume');
          validateBoxVolume();
          compute();
        }

        // Add/Remove rows
        if (t === els.addConductorGroup) {
          createConductorRow({awg:'', count:''});
          // Move focus into new row count
          const rows = $$('#conductorGroups .group-row');
          const last = rows[rows.length-1];
          last.querySelector('select').focus();
        }
        if (t === els.addYokeGroup) {
          createYokeRow({awg:'', count:''});
          const rows = $$('#yokeGroups .group-row');
          const last = rows[rows.length-1];
          last.querySelector('select').focus();
        }
        if (t.matches('.group-row .remove-btn')) {
          const row = t.closest('.group-row');
          row.parentElement.removeChild(row);
          compute();
        }

        // Reset
        if (t === els.resetForm) {
          resetAll();
        }

        // Tooltips
        if (t.matches('.help-btn')) {
          const btn = t;
          const id = btn.getAttribute('aria-controls');
          const panel = document.getElementById(id);
          const expanded = btn.getAttribute('aria-expanded') === 'true';
          btn.setAttribute('aria-expanded', String(!expanded));
          panel.setAttribute('aria-hidden', String(expanded));
        }
      }

      function resetAll(){
        els.boxVolume.value = '';
        setError(els.boxVolumeError,'');
        markInvalid(els.boxVolume,false,'boxVolumeError');

        els.conductorGroups.innerHTML = '';
        createConductorRow({awg:'', count:''});

        els.egcCount.value = '';
        els.egcAwg.value = '';
        setError(els.egcCountError,''); setError(els.egcAwgError,'');
        els.egcCount.setAttribute('aria-invalid','false'); els.egcAwg.setAttribute('aria-invalid','false');

        els.yokeGroups.innerHTML = '';
        createYokeRow({awg:'', count:''});

        els.internalClamps.checked = false;
        els.fittingCount.value = '';
        setError(els.fittingCountError,'');
        els.fittingCount.setAttribute('aria-invalid','false');

        // Close tooltips
        els.tipBtns.forEach(btn=>{
          const id = btn.getAttribute('aria-controls');
          document.getElementById(id)?.setAttribute('aria-hidden','true');
          btn.setAttribute('aria-expanded','false');
        });

        renderResults({required:0, box:null, margin:null, ok:null, equiv:0, breakdown:[]});
      }

      // Initialize
      function init(){
        // Initial rows
        createConductorRow({awg:'', count:''});
        createYokeRow({awg:'', count:''});

        // Bind events
        document.addEventListener('blur', onBlurRecalc, true);
        document.addEventListener('input', (e)=>{
          if (e.target.matches('input, select')) compute();
        }, true);
        document.addEventListener('click', onClick);

        // Initial compute
        compute();
      }

      init();
    })();
  </script>

</body></html>, ',
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link rel="preload" href="https://calcdomain.com/assets/js/mobile-menu.js" as="script">
<link rel="preload" href="https://calcdomain.com/assets/js/page-enhancements.js" as="script">


<style>
/* AUDIT_SPINE_CSS */
.auditspine-note{
  border:1px solid #e5e7eb;
  background:#fff;
  border-radius:12px;
  padding:12px;
  color:#475569;
  font-size:13px;
  line-height:1.5;
}
.auditspine-mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
.auditspine-changelog{
  border:1px solid #e5e7eb;
  background:#fff;
  border-left:5px solid #334155;
  border-radius:12px;
  padding:12px;
  font-size:13px;
  color:#475569;
}
.auditspine-formula{
  margin:10px 0;
  background:#0b1220;
  color:#e5e7eb;
  border-radius:12px;
  padding:12px;
  border:1px solid rgba(255,255,255,.12);
  overflow-x:auto;
}
.auditspine-formula pre{margin:8px 0 0; white-space:pre-wrap;}
.auditspine-hr{border:none; border-top:1px solid #e5e7eb; margin:18px 0;}
</style>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://calcdomain.com"
    },
    {
      "@type": "ListItem",
      "position": 2,
      "name": "General",
      "item": "https://calcdomain.com/categories/general"
    },
    {
      "@type": "ListItem",
      "position": 3,
      "name": "Miscellaneous",
      "item": "https://calcdomain.com/subcategories/miscellaneous"
    }
  ]
}
</script>
</head>
<body>
<a class="skip-link" href="#main-content">Skip to main content</a>

<main class="main-content" id="main-content">
<div class="container">
<nav class="text-sm mb-4 text-gray-600" aria-label="Breadcrumbs"><a href="https://calcdomain.com" class="hover:text-blue-600">Home</a> &raquo; <a href="https://calcdomain.com/categories/general" class="hover:text-blue-600">General</a> &raquo; <a href="https://calcdomain.com/subcategories/miscellaneous" class="hover:text-blue-600">Miscellaneous</a></nav>
<h1>NEC Box Fill Calculator</h1>
<p>
        This professional-grade calculator determines the minimum electrical box volume required by the US National Electrical Code (NEC) 314.16(B). It’s designed for electricians, inspectors, and engineers to quickly verify compliance by accounting for insulated conductors, equipment grounding conductors, device yokes, internal clamps, and fittings.
      </p>
<div class="calculator-layout">
<section aria-labelledby="calc-heading" class="calculator-container">
<h2 id="calc-heading">Calculator</h2>
<!-- Box volume -->
<div class="form-group">
<label for="boxVolume">Box marked volume (cubic inches) *</label>
<div class="inline-help">
<button aria-controls="tip-boxVolume" aria-expanded="false" aria-label="Help: box marked volume" class="help-btn" id="tip-boxVolume-btn" type="button">?</button>
</div>
<div class="input-group">
<input aria-describedby="boxVolumeError tip-boxVolume" aria-required="true" class="form-control" id="boxVolume" inputmode="decimal" min="0" placeholder="e.g., 20.3" step="0.25" type="number">
</div>
<div aria-live="polite" class="error-message" id="boxVolumeError" role="alert"></div>
<div aria-hidden="true" class="tooltip" id="tip-boxVolume">
              The box’s cubic-inch volume is required by NEC to be marked by the manufacturer. You’ll typically find it stamped or printed on the box. For multi-gang boxes, enter the total marked volume.
            </div>
<div aria-label="Quick picks for common box volumes" class="quick-picks" role="group">
<button class="chip" data-volume="18" type="button">18 in³</button>
<button class="chip" data-volume="20.3" type="button">20.3 in³</button>
<button class="chip" data-volume="22.5" type="button">22.5 in³</button>
<button class="chip" data-volume="25" type="button">25 in³</button>
<button class="chip" data-volume="32" type="button">32 in³</button>
</div>
</div>
<!-- Insulated conductors -->
<div class="form-group">
<label>Insulated conductors that enter and terminate/splice in this box</label>
<div class="inline-help">
<button aria-controls="tip-conductors" aria-expanded="false" aria-label="Help: insulated conductors" class="help-btn" id="tip-conductors-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-conductors">
              Count all insulated current-carrying conductors that originate outside and terminate or are spliced in the box. Pass-through (unspliced) conductors also count as one each. Do not add extra for pigtails that originate and terminate within this same box (per NEC 314.16(B)).
            </div>
<div aria-live="polite" class="group-list" id="conductorGroups"></div>
<button aria-label="Add conductor group" class="btn btn-secondary" id="addConductorGroup" type="button">+ Add conductor group</button>
</div>
<!-- Equipment grounding conductors -->
<div class="form-group">
<label for="egcCount">Equipment grounding conductors (EGC)</label>
<div class="inline-help">
<button aria-controls="tip-egc" aria-expanded="false" aria-label="Help: equipment grounding conductors" class="help-btn" id="tip-egc-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-egc">
              If one or more EGCs are present, they collectively count as a single conductor volume based on the largest EGC present. Enter the number of EGCs and select the largest EGC AWG.
            </div>
<div class="input-group" style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem">
<div>
<label class="sr-only" for="egcCount">Number of equipment grounding conductors</label>
<input aria-describedby="egcCountError tip-egc" class="form-control" id="egcCount" inputmode="numeric" min="0" placeholder="Count" step="1" type="number">
<div aria-live="polite" class="error-message" id="egcCountError" role="alert"></div>
</div>
<div>
<label class="sr-only" for="egcAwg">Largest EGC size (AWG)</label>
<select aria-describedby="egcAwgError tip-egc" class="form-control" id="egcAwg">
<option value="">Largest EGC AWG</option>
<option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
</select>
<div aria-live="polite" class="error-message" id="egcAwgError" role="alert"></div>
</div>
</div>
</div>
<!-- Device yokes -->
<div class="form-group">
<label>Device yokes (e.g., switches, receptacles)</label>
<div class="inline-help">
<button aria-controls="tip-yokes" aria-expanded="false" aria-label="Help: device yokes" class="help-btn" id="tip-yokes-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-yokes">
              Each yoke that contains one or more devices counts as two conductor volumes, using the largest AWG conductor connected to that yoke. For example, a duplex receptacle on 12 AWG counts as 2 × the 12 AWG volume.
            </div>
<div aria-live="polite" class="group-list" id="yokeGroups"></div>
<button aria-label="Add device yoke group" class="btn btn-secondary" id="addYokeGroup" type="button">+ Add yoke group</button>
</div>
<!-- Clamps and fittings -->
<div class="form-group">
<label for="internalClamps">Internal cable clamps and support fittings</label>
<div class="inline-help">
<button aria-controls="tip-clamps" aria-expanded="false" aria-label="Help: clamps and fittings" class="help-btn" id="tip-clamps-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-clamps">
              Integral internal clamps count as one conductor volume of the largest insulated conductor in the box. Internal support fittings (like hickeys) each count as one conductor volume of the largest insulated conductor in the box.
            </div>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem">
<div class="input-group" style="display:flex; align-items:center; gap:.5rem">
<input aria-describedby="tip-clamps" id="internalClamps" type="checkbox">
<label for="internalClamps" style="margin:0">Internal cable clamps present</label>
</div>
<div>
<label class="sr-only" for="fittingCount">Number of internal fittings</label>
<input aria-describedby="fittingCountError tip-clamps" class="form-control" id="fittingCount" inputmode="numeric" min="0" placeholder="Fittings count" step="1" type="number">
<div aria-live="polite" class="error-message" id="fittingCountError" role="alert"></div>
</div>
</div>
</div>
<div class="form-group" style="display:flex; gap:.5rem; flex-wrap:wrap">
<button class="btn btn-secondary" id="resetForm" type="button">Reset</button>
</div>
<div aria-atomic="true" aria-live="polite" class="results-container">
<div class="results-header">
<h3 style="margin:0">Results</h3>
<span aria-live="polite" class="status-badge status-ok" id="statusBadge"><span aria-hidden="true">●</span>Waiting for inputs</span>
</div>
<div class="result-grid">
<div class="result-card">
<div class="label">Required minimum volume</div>
<div class="value" id="requiredVolume">0.00 in³</div>
</div>
<div class="result-card">
<div class="label">Box marked volume</div>
<div class="value" id="boxVolumeOut">—</div>
</div>
<div class="result-card">
<div class="label">Margin</div>
<div class="value" id="marginOut">—</div>
</div>
<div class="result-card">
<div class="label">Total counted “conductor equivalents”</div>
<div class="value" id="equivOut">0</div>
</div>
</div>
<div class="breakdown">
<h4>Breakdown</h4>
<ul class="breakdown-list" id="breakdownList">
<li><span class="muted">No items yet</span><span>—</span></li>
</ul>
</div>
</div>
</section>
<article aria-labelledby="content-heading" class="calculator-container">
<h2 id="content-heading">Authoritative Engineering Content</h2>
<section>
<h3>Data Source and Methodology</h3>
<p>
              Authoritative source: National Electrical Code (NEC) — NFPA 70 (2020), Article 314.16 and Table 314.16(B).
              <a href="https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70" rel="noopener" target="_blank">Official NFPA code page</a>
              (free view with account).
            </p>
<p><strong>All calculations strictly follow the formulas and allowances provided by this source.</strong></p>
<ul>
<li>Insulated conductors that enter and terminate/splice in the box: count 1 each.</li>
<li>Pass-through (unspliced) insulated conductors: count 1 each.</li>
<li>Equipment grounding conductors (all): count as 1 volume using the largest EGC present.</li>
<li>Each device yoke: counts as 2 volumes using the largest conductor connected to that yoke.</li>
<li>Integral internal clamps: count as 1 volume of the largest insulated conductor entering the box.</li>
<li>Internal fittings (e.g., hickeys): count as 1 volume each of the largest insulated conductor in the box.</li>
</ul>
<p class="field-help">
              For additional background see:
              <a href="https://www.ecmweb.com/content/article/20886012/box-fill-calculations" rel="noopener" target="_blank">ECM: Box Fill Calculations</a>,
              <a href="https://www.jadelearning.com/blog/nec-2017-article-314-16/" rel="noopener" target="_blank">JADE Learning: NEC 314.16</a>.
            </p>
</section>
<section>
<h3>The Formula Explained</h3>
<div aria-label="Mathematical formulas in LaTeX" class="formula-box">
<div style="font-family:var(--font-mono); font-size:1rem">
                Given the NEC volume allowance function V(AWG) from Table 314.16(B):<br>
                18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00 (cubic inches)
                <hr>
                Total required volume:<br>
                $$V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})$$
                where:<br>
                - $n_i$ = insulated conductors of size $\mathrm{AWG}_i$ that enter and terminate/splice (pass-through counts as 1).<br>
                - $\mathrm{EGC,max}$ = largest equipment grounding conductor AWG (counted once if any EGCs are present).<br>
                - $y_j$ = number of device yokes connected to conductors of $\mathrm{AWG}_{y_j}$ (each counts as 2 conductors).<br>
                - $\mathrm{AWG}_{\max}$ = largest insulated conductor AWG present in the box (used for clamp and fitting allowances).<br>
                - $f$ = number of internal support fittings.
              </div>
</div>
</section>
<section>
<h3>Glossary of Variables</h3>
<ul>
<li>Box marked volume (in³): Manufacturer-stamped cubic-inch capacity of the box.</li>
<li>Insulated conductors: Current-carrying conductors that enter and terminate or splice in the box; pass-throughs count once; pigtails within same box add no extra count.</li>
<li>Equipment grounding conductors (EGC): Green/bare conductors; all EGCs together count as one conductor volume using the largest EGC present.</li>
<li>Device yoke: A strap holding one or more devices (e.g., duplex receptacle). Each yoke counts as two conductors of the largest conductor on that yoke.</li>
<li>Internal clamps: Integral cable clamps inside the box; count as one conductor of the largest insulated conductor present.</li>
<li>Internal fittings: Accessories like hickeys; each counts as one conductor of the largest insulated conductor present.</li>
<li>V(AWG): NEC Table 314.16(B) volume per conductor size (in³): 18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00.</li>
</ul>
</section>
<section>
<h3>How It Works: A Step-by-Step Example</h3>
<p><strong>Scenario.</strong> Box contains: six 12 AWG insulated conductors; one duplex receptacle on 12 AWG (one yoke); two EGCs with largest EGC 12 AWG; integral clamps present; no fittings. Box marked volume = 20.3 in³.</p>
<ol>
<li>Conductor allowance: 6 × V(12) = 6 × 2.25 = 13.50 in³.</li>
<li>EGC allowance: present → 1 × V(12) = 2.25 in³.</li>
<li>Device yoke: 1 yoke → 2 × V(12) = 4.50 in³.</li>
<li>Clamp: present → 1 × V(12) = 2.25 in³.</li>
<li>Fittings: none → 0.</li>
<li>Total required: 13.50 + 2.25 + 4.50 + 2.25 = <strong>22.50 in³</strong>.</li>
<li>Comparison: 20.3 in³ box <strong>does not comply</strong> (short by 2.2 in³).</li>
</ol>
</section>
<section>
<h3>FAQ</h3>
<details>
<summary>Do pigtails count toward box fill?</summary>
<p>No additional count for pigtails that originate and terminate in the same box. Their conductors are already included per NEC 314.16(B).</p>
</details>
<details>
<summary>How are equipment grounding conductors counted?</summary>
<p>All EGCs taken together count as a single conductor volume based on the largest EGC present.</p>
</details>
<details>
<summary>Do pass-through conductors count?</summary>
<p>Yes. Each insulated pass-through (unspliced) conductor counts as one conductor volume.</p>
</details>
<details>
<summary>How do devices like duplex receptacles count?</summary>
<p>Each yoke counts as two conductor volumes using the largest conductor attached to that yoke.</p>
</details>
<details>
<summary>Do internal clamps and fittings count?</summary>
<p>Internal clamps count as one conductor volume; each internal fitting counts as one, both based on the largest insulated conductor in the box.</p>
</details>
<details>
<summary>Which AWG sizes are supported?</summary>
<p>18, 16, 14, 12, 10, 8, and 6 AWG, using the cubic-inch values in NEC Table 314.16(B).</p>
</details>
<details>
<summary>Can I use this for multi-gang boxes?</summary>
<p>Yes. Enter the total manufacturer-marked volume (sum of gangs) and include all conductors/devices in the calculation.</p>
</details>
</section>
<div class="author-box">
<p>
            </p>
</div>

<!-- AUDIT_SPINE_START -->
<hr class="auditspine-hr">
<section aria-label="Formulas, sources, changelog, verification">
  <span class="auditspine-badge">Audit: Complete</span>

  <details style="margin-top:10px">
    <summary><strong>Formula (LaTeX) + variables + units</strong></summary>
    <div class="auditspine-note" style="margin-top:10px">
      This section shows the formulas used by the calculator engine, plus variable definitions and units.
      
    </div>
    <div class="auditspine-formula">
      <div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[','\]</div>
  <pre class="auditspine-mono">','</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&amp;gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})\]</div>
  <pre class="auditspine-mono">V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&amp;gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[= (sel, ctx=document) =&gt; Array.from(ctx.querySelectorAll(sel)); const els = { boxVolume: $('#boxVolume'), boxVolumeError: $('#boxVolumeError'), quickPicks:\]</div>
  <pre class="auditspine-mono">= (sel, ctx=document) =&gt; Array.from(ctx.querySelectorAll(sel)); const els = { boxVolume: $('#boxVolume'), boxVolumeError: $('#boxVolumeError'), quickPicks:</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[('.help-btn'), }; function createConductorRow(initial = {awg:'', count:''}) { const rowId = `cg-${conductorRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'conductor-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Count of insulated conductors&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this conductor group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.conductorGroups.appendChild(row); } function createYokeRow(initial = {awg:'', count:''}) { const rowId = `yg-${yokeRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'yoke-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Device yoke conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Number of device yokes&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this yoke group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.yokeGroups.appendChild(row); } // Validation helpers function setError(el, msg) { el.textContent = msg || ''; } function markInvalid(input, invalid, describedById) { input.setAttribute('aria-invalid', invalid ? 'true' : 'false'); if (describedById) input.setAttribute('aria-describedby', describedById); } function parseIntSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } function parseFloatSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } // Field-specific validation function validateBoxVolume() { const val = parseFloatSafe(els.boxVolume.value); if (isNaN(val)) { setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } if (val &lt;= 0) { setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } setError(els.boxVolumeError, ''); markInvalid(els.boxVolume, false, 'boxVolumeError'); return val; } function validateEgc() { const count = parseIntSafe(els.egcCount.value); const awg = els.egcAwg.value; let ok = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { setError(els.egcCountError, 'Count cannot be negative.'); markInvalid(els.egcCount, true, 'egcCountError'); ok = false; } else { setError(els.egcCountError, ''); markInvalid(els.egcCount, false, 'egcCountError'); } if (count &gt; 0 &amp;&amp; !awg) { setError(els.egcAwgError, 'Select the largest EGC size (AWG).'); markInvalid(els.egcAwg, true, 'egcAwgError'); ok = false; } else { setError(els.egcAwgError, ''); markInvalid(els.egcAwg, false, 'egcAwgError'); } return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null; } function validateFittings() { const count = parseIntSafe(els.fittingCount.value); if (isNaN(count)) { setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return 0; } if (count &lt; 0) { setError(els.fittingCountError, 'Count cannot be negative.'); markInvalid(els.fittingCount, true, 'fittingCountError'); return null; } setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return count; } function validateGroupRow(row) { const isConductor = row.getAttribute('data-role') === 'conductor-row'; const idPrefix = row.querySelector('select').id.replace(/-awg$/, ''); const sel = row.querySelector(`#${idPrefix}-awg`); const cntInput = row.querySelector(`#${idPrefix}-count`); const err = row.querySelector(`#${idPrefix}-error`); const count = parseIntSafe(cntInput.value); const awg = sel.value; let valid = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { err.textContent = 'Count cannot be negative.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } else { cntInput.setAttribute('aria-invalid','false'); } if ((count || count === 0) &amp;&amp; count &gt; 0 &amp;&amp; !awg) { err.textContent = 'Select an AWG size for this group.'; sel.setAttribute('aria-invalid','true'); valid = false; } else { sel.setAttribute('aria-invalid','false'); } if ((count === 0 || isNaN(count)) &amp;&amp; !awg) { err.textContent = ''; } else if (valid) { err.textContent = ''; } // For yokes, ensure integer counts if (row.getAttribute('data-role') === 'yoke-row' &amp;&amp; !isNaN(count) &amp;&amp; !Number.isInteger(count)) { err.textContent = 'Number of yokes must be a whole number.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } return valid ? { count: isNaN(count) ? 0 : count, awg: awg || '' } : null; } function collectInputs() { // Box volume can be null (not provided); we still compute required const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume(); // Conductors const conductors = []; for (const row of\]</div>
  <pre class="auditspine-mono">('.help-btn'), }; function createConductorRow(initial = {awg:'', count:''}) { const rowId = `cg-${conductorRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'conductor-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Count of insulated conductors&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this conductor group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.conductorGroups.appendChild(row); } function createYokeRow(initial = {awg:'', count:''}) { const rowId = `yg-${yokeRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'yoke-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Device yoke conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Number of device yokes&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this yoke group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.yokeGroups.appendChild(row); } // Validation helpers function setError(el, msg) { el.textContent = msg || ''; } function markInvalid(input, invalid, describedById) { input.setAttribute('aria-invalid', invalid ? 'true' : 'false'); if (describedById) input.setAttribute('aria-describedby', describedById); } function parseIntSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } function parseFloatSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } // Field-specific validation function validateBoxVolume() { const val = parseFloatSafe(els.boxVolume.value); if (isNaN(val)) { setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } if (val &lt;= 0) { setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } setError(els.boxVolumeError, ''); markInvalid(els.boxVolume, false, 'boxVolumeError'); return val; } function validateEgc() { const count = parseIntSafe(els.egcCount.value); const awg = els.egcAwg.value; let ok = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { setError(els.egcCountError, 'Count cannot be negative.'); markInvalid(els.egcCount, true, 'egcCountError'); ok = false; } else { setError(els.egcCountError, ''); markInvalid(els.egcCount, false, 'egcCountError'); } if (count &gt; 0 &amp;&amp; !awg) { setError(els.egcAwgError, 'Select the largest EGC size (AWG).'); markInvalid(els.egcAwg, true, 'egcAwgError'); ok = false; } else { setError(els.egcAwgError, ''); markInvalid(els.egcAwg, false, 'egcAwgError'); } return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null; } function validateFittings() { const count = parseIntSafe(els.fittingCount.value); if (isNaN(count)) { setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return 0; } if (count &lt; 0) { setError(els.fittingCountError, 'Count cannot be negative.'); markInvalid(els.fittingCount, true, 'fittingCountError'); return null; } setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return count; } function validateGroupRow(row) { const isConductor = row.getAttribute('data-role') === 'conductor-row'; const idPrefix = row.querySelector('select').id.replace(/-awg$/, ''); const sel = row.querySelector(`#${idPrefix}-awg`); const cntInput = row.querySelector(`#${idPrefix}-count`); const err = row.querySelector(`#${idPrefix}-error`); const count = parseIntSafe(cntInput.value); const awg = sel.value; let valid = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { err.textContent = 'Count cannot be negative.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } else { cntInput.setAttribute('aria-invalid','false'); } if ((count || count === 0) &amp;&amp; count &gt; 0 &amp;&amp; !awg) { err.textContent = 'Select an AWG size for this group.'; sel.setAttribute('aria-invalid','true'); valid = false; } else { sel.setAttribute('aria-invalid','false'); } if ((count === 0 || isNaN(count)) &amp;&amp; !awg) { err.textContent = ''; } else if (valid) { err.textContent = ''; } // For yokes, ensure integer counts if (row.getAttribute('data-role') === 'yoke-row' &amp;&amp; !isNaN(count) &amp;&amp; !Number.isInteger(count)) { err.textContent = 'Number of yokes must be a whole number.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } return valid ? { count: isNaN(count) ? 0 : count, awg: awg || '' } : null; } function collectInputs() { // Box volume can be null (not provided); we still compute required const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume(); // Conductors const conductors = []; for (const row of</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[('#yokeGroups .group-row')) { const v = validateGroupRow(row); if (v === null) return null; // invalid if (v.count &gt; 0 &amp;&amp; v.awg) yokes.push(v); } // EGC const egc = validateEgc(); if (egc === null) return null; // Fittings const fittings = validateFittings(); if (fittings === null) return null; const clamps = els.internalClamps.checked; return { boxVol, conductors, yokes, egc, fittings, clamps }; } function largestInsulatedAWG(conductors, yokes) { // Return the physically largest conductor (smallest AWG number) // We compare by numerical value, but NEC table is discrete for listed sizes only. const sizes = new Set(); conductors.forEach(c =&gt; sizes.add(c.awg)); yokes.forEach(y =&gt; sizes.add(y.awg)); const arr = Array.from(sizes).map(Number).filter(Boolean); if (arr.length === 0) return null; // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12) return Math.min(...arr); } function compute() { const input = collectInputs(); if (!input) { // Invalid fields; keep results minimal renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []}); return; } const { boxVol, conductors, yokes, egc, fittings, clamps } = input; // Aggregate by AWG for conductors let breakdown = []; let required = 0; let equivalents = 0; // Conductors const condMap = new Map(); for (const c of conductors) { const cnt = condMap.get(c.awg) || 0; condMap.set(c.awg, cnt + c.count); } for (const [awg, count] of condMap) { const vol = (VOLUME_BY_AWG[awg] || 0) * count; required += vol; equivalents += count; breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol}); } // EGC (all count as one of largest EGC present) if (egc.count &gt; 0 &amp;&amp; egc.awg) { const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol}); } // Yokes for (const y of yokes) { const addEq = y.count * 2; const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq; required += vol; equivalents += addEq; breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol}); } // Largest insulated AWG for clamps/fittings const awgMax = largestInsulatedAWG(conductors, yokes); if (clamps &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol}); } if (fittings &gt; 0 &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings; required += vol; equivalents += fittings; breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol}); } const result = { required, box: boxVol, margin: (typeof boxVol === 'number') ? (boxVol - required) : null, ok: (typeof boxVol === 'number') ? (boxVol &gt;= required) : null, equiv: equivalents, breakdown }; renderResults(result); } function formatIn3(n) { return `${n.toFixed(2)} in³`; } function readBoxVolOrNull(){ const v = parseFloatSafe(els.boxVolume.value); return isNaN(v) ? null : v; } function renderResults({required, box, margin, ok, equiv, breakdown}) { // Required $('#requiredVolume').textContent = formatIn3(required || 0); // Box and margin if (typeof box === 'number') { $('#boxVolumeOut').textContent = formatIn3(box); const mEl = $('#marginOut'); if (typeof margin === 'number') { const pct = (box &gt; 0) ? (margin / box * 100) : 0; mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`; mEl.className = 'value ' + (margin &gt;= 0 ? 'value-ok' : 'value-bad'); } else { mEl.textContent = '—'; mEl.className = 'value'; } } else { $('#boxVolumeOut').textContent = '—'; $('#marginOut').textContent = '—'; $('#marginOut').className = 'value'; } // Equivalents $('#equivOut').textContent = String(equiv || 0); // Status const status = $('#statusBadge'); if (ok === null) { status.className = 'status-badge'; status.textContent = 'Waiting for inputs'; } else if (ok) { status.className = 'status-badge status-ok'; status.textContent = 'Compliant ✓'; } else { status.className = 'status-badge status-fail'; status.textContent = 'Not compliant ✕'; } // Breakdown const list = $('#breakdownList'); list.innerHTML = ''; if (!breakdown || breakdown.length === 0) { const li = document.createElement('li'); li.innerHTML = '&lt;span class="muted"&gt;No items yet&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;'; list.appendChild(li); } else { for (const item of breakdown) { const li = document.createElement('li'); const left = document.createElement('span'); const right = document.createElement('span'); left.textContent = item.label; right.textContent = formatIn3(item.vol); li.appendChild(left); li.appendChild(right); list.appendChild(li); } } } // Event wiring function onBlurRecalc(e) { const target = e.target; if (target.matches('input, select')) { // Validate specific fields if (target === els.boxVolume) validateBoxVolume(); if (target === els.egcCount || target === els.egcAwg) validateEgc(); if (target === els.fittingCount) validateFittings(); if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row')); compute(); } } function onClick(e){ const t = e.target; // Quick pick chips if (t.matches('.chip[data-volume]')) { els.boxVolume.value = t.getAttribute('data-volume'); validateBoxVolume(); compute(); } // Add/Remove rows if (t === els.addConductorGroup) { createConductorRow({awg:'', count:''}); // Move focus into new row count const rows =\]</div>
  <pre class="auditspine-mono">('#yokeGroups .group-row')) { const v = validateGroupRow(row); if (v === null) return null; // invalid if (v.count &gt; 0 &amp;&amp; v.awg) yokes.push(v); } // EGC const egc = validateEgc(); if (egc === null) return null; // Fittings const fittings = validateFittings(); if (fittings === null) return null; const clamps = els.internalClamps.checked; return { boxVol, conductors, yokes, egc, fittings, clamps }; } function largestInsulatedAWG(conductors, yokes) { // Return the physically largest conductor (smallest AWG number) // We compare by numerical value, but NEC table is discrete for listed sizes only. const sizes = new Set(); conductors.forEach(c =&gt; sizes.add(c.awg)); yokes.forEach(y =&gt; sizes.add(y.awg)); const arr = Array.from(sizes).map(Number).filter(Boolean); if (arr.length === 0) return null; // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12) return Math.min(...arr); } function compute() { const input = collectInputs(); if (!input) { // Invalid fields; keep results minimal renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []}); return; } const { boxVol, conductors, yokes, egc, fittings, clamps } = input; // Aggregate by AWG for conductors let breakdown = []; let required = 0; let equivalents = 0; // Conductors const condMap = new Map(); for (const c of conductors) { const cnt = condMap.get(c.awg) || 0; condMap.set(c.awg, cnt + c.count); } for (const [awg, count] of condMap) { const vol = (VOLUME_BY_AWG[awg] || 0) * count; required += vol; equivalents += count; breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol}); } // EGC (all count as one of largest EGC present) if (egc.count &gt; 0 &amp;&amp; egc.awg) { const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol}); } // Yokes for (const y of yokes) { const addEq = y.count * 2; const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq; required += vol; equivalents += addEq; breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol}); } // Largest insulated AWG for clamps/fittings const awgMax = largestInsulatedAWG(conductors, yokes); if (clamps &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol}); } if (fittings &gt; 0 &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings; required += vol; equivalents += fittings; breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol}); } const result = { required, box: boxVol, margin: (typeof boxVol === 'number') ? (boxVol - required) : null, ok: (typeof boxVol === 'number') ? (boxVol &gt;= required) : null, equiv: equivalents, breakdown }; renderResults(result); } function formatIn3(n) { return `${n.toFixed(2)} in³`; } function readBoxVolOrNull(){ const v = parseFloatSafe(els.boxVolume.value); return isNaN(v) ? null : v; } function renderResults({required, box, margin, ok, equiv, breakdown}) { // Required $('#requiredVolume').textContent = formatIn3(required || 0); // Box and margin if (typeof box === 'number') { $('#boxVolumeOut').textContent = formatIn3(box); const mEl = $('#marginOut'); if (typeof margin === 'number') { const pct = (box &gt; 0) ? (margin / box * 100) : 0; mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`; mEl.className = 'value ' + (margin &gt;= 0 ? 'value-ok' : 'value-bad'); } else { mEl.textContent = '—'; mEl.className = 'value'; } } else { $('#boxVolumeOut').textContent = '—'; $('#marginOut').textContent = '—'; $('#marginOut').className = 'value'; } // Equivalents $('#equivOut').textContent = String(equiv || 0); // Status const status = $('#statusBadge'); if (ok === null) { status.className = 'status-badge'; status.textContent = 'Waiting for inputs'; } else if (ok) { status.className = 'status-badge status-ok'; status.textContent = 'Compliant ✓'; } else { status.className = 'status-badge status-fail'; status.textContent = 'Not compliant ✕'; } // Breakdown const list = $('#breakdownList'); list.innerHTML = ''; if (!breakdown || breakdown.length === 0) { const li = document.createElement('li'); li.innerHTML = '&lt;span class="muted"&gt;No items yet&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;'; list.appendChild(li); } else { for (const item of breakdown) { const li = document.createElement('li'); const left = document.createElement('span'); const right = document.createElement('span'); left.textContent = item.label; right.textContent = formatIn3(item.vol); li.appendChild(left); li.appendChild(right); list.appendChild(li); } } } // Event wiring function onBlurRecalc(e) { const target = e.target; if (target.matches('input, select')) { // Validate specific fields if (target === els.boxVolume) validateBoxVolume(); if (target === els.egcCount || target === els.egcAwg) validateEgc(); if (target === els.fittingCount) validateFittings(); if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row')); compute(); } } function onClick(e){ const t = e.target; // Quick pick chips if (t.matches('.chip[data-volume]')) { els.boxVolume.value = t.getAttribute('data-volume'); validateBoxVolume(); compute(); } // Add/Remove rows if (t === els.addConductorGroup) { createConductorRow({awg:'', count:''}); // Move focus into new row count const rows =</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted text)</strong></div>
  
  <pre class="auditspine-mono">Given the NEC volume allowance function V(AWG) from Table 314.16(B): 18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00 (cubic inches) Total required volume: $V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})$ where: - $n_i$ = insulated conductors of size $\mathrm{AWG}_i$ that enter and terminate/splice (pass-through counts as 1). - $\mathrm{EGC,max}$ = largest equipment grounding conductor AWG (counted once if any EGCs are present). - $y_j$ = number of device yokes connected to conductors of $\mathrm{AWG}_{y_j}$ (each counts as 2 conductors). - $\mathrm{AWG}_{\max}$ = largest insulated conductor AWG present in the box (used for clamp and fitting allowances). - $f$ = number of internal support fittings.</pre>
</div>
      <div style="margin-top:12px"><strong>Variables and units</strong></div>
      <ul style="margin:8px 0 0 18px">
        <li><em>No variables provided in audit spec.</em></li>
      </ul>
    </div>
  </details>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Sources (authoritative):</strong>
    <ul style="margin:8px 0 0 18px">
      <li><strong>Engineering</strong> — calcdomain.com · Accessed 2026-01-19<br><a href="https://calcdomain.com/engineering" target="_blank" rel="nofollow noopener">https://calcdomain.com/engineering</a></li>
<li><strong>Electrical (US NEC)</strong> — calcdomain.com · Accessed 2026-01-19<br><a href="https://calcdomain.com/subcategories/electrical" target="_blank" rel="nofollow noopener">https://calcdomain.com/subcategories/electrical</a></li>
<li><strong>Official NFPA code page</strong> — nfpa.org · Accessed 2026-01-19<br><a href="https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70" target="_blank" rel="nofollow noopener">https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70</a></li>
<li><strong>ECM: Box Fill Calculations</strong> — ecmweb.com · Accessed 2026-01-19<br><a href="https://www.ecmweb.com/content/article/20886012/box-fill-calculations" target="_blank" rel="nofollow noopener">https://www.ecmweb.com/content/article/20886012/box-fill-calculations</a></li>
<li><strong>JADE Learning: NEC 314.16</strong> — jadelearning.com · Accessed 2026-01-19<br><a href="https://www.jadelearning.com/blog/nec-2017-article-314-16/" target="_blank" rel="nofollow noopener">https://www.jadelearning.com/blog/nec-2017-article-314-16/</a></li>
    </ul>
  </div>

  <div class="auditspine-changelog" style="margin-top:12px">
    <strong>Changelog</strong><br>
    <div style="margin-top:6px">
      <strong>Version:</strong> 0.1.0-draft<br>
      <strong>Last code update:</strong> 2026-01-19
    </div>
    <div style="margin-top:10px">
  <strong>0.1.0-draft</strong> · 2026-01-19
  <ul style="margin:6px 0 0 18px">
    <li>Initial audit spec draft generated from HTML extraction (review required).</li>
<li>Verify formulas match the calculator engine and convert any text-only formulas to LaTeX.</li>
<li>Confirm sources are authoritative and relevant to the calculator methodology.</li>
  </ul>
</div>
  </div>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Verified by Ugo Candido on 2026-01-19</strong><br>
    <a href="https://calcdomain.com/ugocandido" target="_blank" rel="noopener">Profile</a> ·
    <a href="https://www.linkedin.com/in/ugocandido92821/" target="_blank" rel="noopener">LinkedIn</a>
  </div>
</section>
<!-- AUDIT_SPINE_END -->
</article>
</div>
</div>
</main>
<!-- Standard Footer --> 
<script defer="">
    (function(){
      'use strict';

      // Volume allowances per NEC Table 314.16(B) in cubic inches
      const VOLUME_BY_AWG = {
        18: 1.50,
        16: 1.75,
        14: 2.00,
        12: 2.25,
        10: 2.50,
        8: 3.00,
        6: 5.00
      };

      // State
      let conductorRowId = 0;
      let yokeRowId = 0;

      const $ = (sel, ctx=document) => ctx.querySelector(sel);
      const $$ = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));

      const els = {
        boxVolume: $('#boxVolume'),
        boxVolumeError: $('#boxVolumeError'),
        quickPicks: $$('.chip[data-volume]'),
        statusBadge: $('#statusBadge'),
        requiredVolume: $('#requiredVolume'),
        boxVolumeOut: $('#boxVolumeOut'),
        marginOut: $('#marginOut'),
        equivOut: $('#equivOut'),
        breakdownList: $('#breakdownList'),
        conductorGroups: $('#conductorGroups'),
        addConductorGroup: $('#addConductorGroup'),
        egcCount: $('#egcCount'),
        egcCountError: $('#egcCountError'),
        egcAwg: $('#egcAwg'),
        egcAwgError: $('#egcAwgError'),
        yokeGroups: $('#yokeGroups'),
        addYokeGroup: $('#addYokeGroup'),
        internalClamps: $('#internalClamps'),
        fittingCount: $('#fittingCount'),
        fittingCountError: $('#fittingCountError'),
        resetForm: $('#resetForm'),

        // Tooltips
        tipBtns: $$('.help-btn'),
      };

      function createConductorRow(initial = {awg:'', count:''}) {
        const rowId = `cg-${conductorRowId++}`;
        const row = document.createElement('div');
        row.className = 'group-row';
        row.setAttribute('data-role', 'conductor-row');
        row.innerHTML = `
          <div>
            <label class="sr-only" for="${rowId}-awg">Conductor size (AWG)</label>
            <select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error">
              <option value="">AWG size</option>
              <option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
            </select>
          </div>
          <div>
            <label class="sr-only" for="${rowId}-count">Count of insulated conductors</label>
            <input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error">
          </div>
          <div style="display:flex; gap:.5rem; align-items:center">
            <button class="remove-btn" type="button" aria-label="Remove this conductor group">Remove</button>
          </div>
          <div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"></div>
        `;
        if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg;
        if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count;
        els.conductorGroups.appendChild(row);
      }

      function createYokeRow(initial = {awg:'', count:''}) {
        const rowId = `yg-${yokeRowId++}`;
        const row = document.createElement('div');
        row.className = 'group-row';
        row.setAttribute('data-role', 'yoke-row');
        row.innerHTML = `
          <div>
            <label class="sr-only" for="${rowId}-awg">Device yoke conductor size (AWG)</label>
            <select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error">
              <option value="">AWG size</option>
              <option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
            </select>
          </div>
          <div>
            <label class="sr-only" for="${rowId}-count">Number of device yokes</label>
            <input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error">
          </div>
          <div style="display:flex; gap:.5rem; align-items:center">
            <button class="remove-btn" type="button" aria-label="Remove this yoke group">Remove</button>
          </div>
          <div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"></div>
        `;
        if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg;
        if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count;
        els.yokeGroups.appendChild(row);
      }

      // Validation helpers
      function setError(el, msg) {
        el.textContent = msg || '';
      }
      function markInvalid(input, invalid, describedById) {
        input.setAttribute('aria-invalid', invalid ? 'true' : 'false');
        if (describedById) input.setAttribute('aria-describedby', describedById);
      }
      function parseIntSafe(value) {
        if (value === '' || value === null || value === undefined) return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
      }
      function parseFloatSafe(value) {
        if (value === '' || value === null || value === undefined) return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
      }

      // Field-specific validation
      function validateBoxVolume() {
        const val = parseFloatSafe(els.boxVolume.value);
        if (isNaN(val)) {
          setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.');
          markInvalid(els.boxVolume, true, 'boxVolumeError');
          return null;
        }
        if (val <= 0) {
          setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.');
          markInvalid(els.boxVolume, true, 'boxVolumeError');
          return null;
        }
        setError(els.boxVolumeError, '');
        markInvalid(els.boxVolume, false, 'boxVolumeError');
        return val;
      }

      function validateEgc() {
        const count = parseIntSafe(els.egcCount.value);
        const awg = els.egcAwg.value;
        let ok = true;

        if (!isNaN(count) && count < 0) {
          setError(els.egcCountError, 'Count cannot be negative.');
          markInvalid(els.egcCount, true, 'egcCountError');
          ok = false;
        } else {
          setError(els.egcCountError, '');
          markInvalid(els.egcCount, false, 'egcCountError');
        }

        if (count > 0 && !awg) {
          setError(els.egcAwgError, 'Select the largest EGC size (AWG).');
          markInvalid(els.egcAwg, true, 'egcAwgError');
          ok = false;
        } else {
          setError(els.egcAwgError, '');
          markInvalid(els.egcAwg, false, 'egcAwgError');
        }

        return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null;
      }

      function validateFittings() {
        const count = parseIntSafe(els.fittingCount.value);
        if (isNaN(count)) {
          setError(els.fittingCountError, '');
          markInvalid(els.fittingCount, false, 'fittingCountError');
          return 0;
        }
        if (count < 0) {
          setError(els.fittingCountError, 'Count cannot be negative.');
          markInvalid(els.fittingCount, true, 'fittingCountError');
          return null;
        }
        setError(els.fittingCountError, '');
        markInvalid(els.fittingCount, false, 'fittingCountError');
        return count;
      }

      function validateGroupRow(row) {
        const isConductor = row.getAttribute('data-role') === 'conductor-row';
        const idPrefix = row.querySelector('select').id.replace(/-awg$/, '');
        const sel = row.querySelector(`#${idPrefix}-awg`);
        const cntInput = row.querySelector(`#${idPrefix}-count`);
        const err = row.querySelector(`#${idPrefix}-error`);

        const count = parseIntSafe(cntInput.value);
        const awg = sel.value;
        let valid = true;

        if (!isNaN(count) && count < 0) {
          err.textContent = 'Count cannot be negative.';
          cntInput.setAttribute('aria-invalid','true');
          valid = false;
        } else {
          cntInput.setAttribute('aria-invalid','false');
        }

        if ((count || count === 0) && count > 0 && !awg) {
          err.textContent = 'Select an AWG size for this group.';
          sel.setAttribute('aria-invalid','true');
          valid = false;
        } else {
          sel.setAttribute('aria-invalid','false');
        }

        if ((count === 0 || isNaN(count)) && !awg) {
          err.textContent = '';
        } else if (valid) {
          err.textContent = '';
        }

        // For yokes, ensure integer counts
        if (row.getAttribute('data-role') === 'yoke-row' && !isNaN(count) && !Number.isInteger(count)) {
          err.textContent = 'Number of yokes must be a whole number.';
          cntInput.setAttribute('aria-invalid','true');
          valid = false;
        }

        return valid ? {
          count: isNaN(count) ? 0 : count,
          awg: awg || ''
        } : null;
      }

      function collectInputs() {
        // Box volume can be null (not provided); we still compute required
        const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume();

        // Conductors
        const conductors = [];
        for (const row of $$('#conductorGroups .group-row')) {
          const v = validateGroupRow(row);
          if (v === null) return null; // invalid
          if (v.count > 0 && v.awg) conductors.push(v);
        }

        // Yokes
        const yokes = [];
        for (const row of $$('#yokeGroups .group-row')) {
          const v = validateGroupRow(row);
          if (v === null) return null; // invalid
          if (v.count > 0 && v.awg) yokes.push(v);
        }

        // EGC
        const egc = validateEgc();
        if (egc === null) return null;

        // Fittings
        const fittings = validateFittings();
        if (fittings === null) return null;

        const clamps = els.internalClamps.checked;

        return { boxVol, conductors, yokes, egc, fittings, clamps };
      }

      function largestInsulatedAWG(conductors, yokes) {
        // Return the physically largest conductor (smallest AWG number)
        // We compare by numerical value, but NEC table is discrete for listed sizes only.
        const sizes = new Set();
        conductors.forEach(c => sizes.add(c.awg));
        yokes.forEach(y => sizes.add(y.awg));
        const arr = Array.from(sizes).map(Number).filter(Boolean);
        if (arr.length === 0) return null;
        // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12)
        return Math.min(...arr);
      }

      function compute() {
        const input = collectInputs();
        if (!input) {
          // Invalid fields; keep results minimal
          renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []});
          return;
        }

        const { boxVol, conductors, yokes, egc, fittings, clamps } = input;

        // Aggregate by AWG for conductors
        let breakdown = [];
        let required = 0;
        let equivalents = 0;

        // Conductors
        const condMap = new Map();
        for (const c of conductors) {
          const cnt = condMap.get(c.awg) || 0;
          condMap.set(c.awg, cnt + c.count);
        }
        for (const [awg, count] of condMap) {
          const vol = (VOLUME_BY_AWG[awg] || 0) * count;
          required += vol;
          equivalents += count;
          breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol});
        }

        // EGC (all count as one of largest EGC present)
        if (egc.count > 0 && egc.awg) {
          const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1;
          required += vol;
          equivalents += 1;
          breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol});
        }

        // Yokes
        for (const y of yokes) {
          const addEq = y.count * 2;
          const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq;
          required += vol;
          equivalents += addEq;
          breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol});
        }

        // Largest insulated AWG for clamps/fittings
        const awgMax = largestInsulatedAWG(conductors, yokes);
        if (clamps && awgMax) {
          const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1;
          required += vol;
          equivalents += 1;
          breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol});
        }
        if (fittings > 0 && awgMax) {
          const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings;
          required += vol;
          equivalents += fittings;
          breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol});
        }

        const result = {
          required,
          box: boxVol,
          margin: (typeof boxVol === 'number') ? (boxVol - required) : null,
          ok: (typeof boxVol === 'number') ? (boxVol >= required) : null,
          equiv: equivalents,
          breakdown
        };

        renderResults(result);
      }

      function formatIn3(n) {
        return `${n.toFixed(2)} in³`;
      }

      function readBoxVolOrNull(){
        const v = parseFloatSafe(els.boxVolume.value);
        return isNaN(v) ? null : v;
      }

      function renderResults({required, box, margin, ok, equiv, breakdown}) {
        // Required
        $('#requiredVolume').textContent = formatIn3(required || 0);

        // Box and margin
        if (typeof box === 'number') {
          $('#boxVolumeOut').textContent = formatIn3(box);
          const mEl = $('#marginOut');
          if (typeof margin === 'number') {
            const pct = (box > 0) ? (margin / box * 100) : 0;
            mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`;
            mEl.className = 'value ' + (margin >= 0 ? 'value-ok' : 'value-bad');
          } else {
            mEl.textContent = '—';
            mEl.className = 'value';
          }
        } else {
          $('#boxVolumeOut').textContent = '—';
          $('#marginOut').textContent = '—';
          $('#marginOut').className = 'value';
        }

        // Equivalents
        $('#equivOut').textContent = String(equiv || 0);

        // Status
        const status = $('#statusBadge');
        if (ok === null) {
          status.className = 'status-badge';
          status.textContent = 'Waiting for inputs';
        } else if (ok) {
          status.className = 'status-badge status-ok';
          status.textContent = 'Compliant ✓';
        } else {
          status.className = 'status-badge status-fail';
          status.textContent = 'Not compliant ✕';
        }

        // Breakdown
        const list = $('#breakdownList');
        list.innerHTML = '';
        if (!breakdown || breakdown.length === 0) {
          const li = document.createElement('li');
          li.innerHTML = '<span class="muted">No items yet</span><span>—</span>';
          list.appendChild(li);
        } else {
          for (const item of breakdown) {
            const li = document.createElement('li');
            const left = document.createElement('span');
            const right = document.createElement('span');
            left.textContent = item.label;
            right.textContent = formatIn3(item.vol);
            li.appendChild(left);
            li.appendChild(right);
            list.appendChild(li);
          }
        }
      }

      // Event wiring
      function onBlurRecalc(e) {
        const target = e.target;
        if (target.matches('input, select')) {
          // Validate specific fields
          if (target === els.boxVolume) validateBoxVolume();
          if (target === els.egcCount || target === els.egcAwg) validateEgc();
          if (target === els.fittingCount) validateFittings();
          if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row'));
          compute();
        }
      }

      function onClick(e){
        const t = e.target;

        // Quick pick chips
        if (t.matches('.chip[data-volume]')) {
          els.boxVolume.value = t.getAttribute('data-volume');
          validateBoxVolume();
          compute();
        }

        // Add/Remove rows
        if (t === els.addConductorGroup) {
          createConductorRow({awg:'', count:''});
          // Move focus into new row count
          const rows = $$('#conductorGroups .group-row');
          const last = rows[rows.length-1];
          last.querySelector('select').focus();
        }
        if (t === els.addYokeGroup) {
          createYokeRow({awg:'', count:''});
          const rows = $$('#yokeGroups .group-row');
          const last = rows[rows.length-1];
          last.querySelector('select').focus();
        }
        if (t.matches('.group-row .remove-btn')) {
          const row = t.closest('.group-row');
          row.parentElement.removeChild(row);
          compute();
        }

        // Reset
        if (t === els.resetForm) {
          resetAll();
        }

        // Tooltips
        if (t.matches('.help-btn')) {
          const btn = t;
          const id = btn.getAttribute('aria-controls');
          const panel = document.getElementById(id);
          const expanded = btn.getAttribute('aria-expanded') === 'true';
          btn.setAttribute('aria-expanded', String(!expanded));
          panel.setAttribute('aria-hidden', String(expanded));
        }
      }

      function resetAll(){
        els.boxVolume.value = '';
        setError(els.boxVolumeError,'');
        markInvalid(els.boxVolume,false,'boxVolumeError');

        els.conductorGroups.innerHTML = '';
        createConductorRow({awg:'', count:''});

        els.egcCount.value = '';
        els.egcAwg.value = '';
        setError(els.egcCountError,''); setError(els.egcAwgError,'');
        els.egcCount.setAttribute('aria-invalid','false'); els.egcAwg.setAttribute('aria-invalid','false');

        els.yokeGroups.innerHTML = '';
        createYokeRow({awg:'', count:''});

        els.internalClamps.checked = false;
        els.fittingCount.value = '';
        setError(els.fittingCountError,'');
        els.fittingCount.setAttribute('aria-invalid','false');

        // Close tooltips
        els.tipBtns.forEach(btn=>{
          const id = btn.getAttribute('aria-controls');
          document.getElementById(id)?.setAttribute('aria-hidden','true');
          btn.setAttribute('aria-expanded','false');
        });

        renderResults({required:0, box:null, margin:null, ok:null, equiv:0, breakdown:[]});
      }

      // Initialize
      function init(){
        // Initial rows
        createConductorRow({awg:'', count:''});
        createYokeRow({awg:'', count:''});

        // Bind events
        document.addEventListener('blur', onBlurRecalc, true);
        document.addEventListener('input', (e)=>{
          if (e.target.matches('input, select')) compute();
        }, true);
        document.addEventListener('click', onClick);

        // Initial compute
        compute();
      }

      init();
    })();
  </script>

</body></html>]], displayMath: [['\\[','\\]']] }, svg: { fontCache: 'global' } };,
    svg: { fontCache: 'global' }
  };
</script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link rel="preload" href="https://calcdomain.com/assets/js/mobile-menu.js" as="script">
<link rel="preload" href="https://calcdomain.com/assets/js/page-enhancements.js" as="script">


<style>
/* AUDIT_SPINE_CSS */
.auditspine-note{
  border:1px solid #e5e7eb;
  background:#fff;
  border-radius:12px;
  padding:12px;
  color:#475569;
  font-size:13px;
  line-height:1.5;
}
.auditspine-mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
.auditspine-changelog{
  border:1px solid #e5e7eb;
  background:#fff;
  border-left:5px solid #334155;
  border-radius:12px;
  padding:12px;
  font-size:13px;
  color:#475569;
}
.auditspine-formula{
  margin:10px 0;
  background:#0b1220;
  color:#e5e7eb;
  border-radius:12px;
  padding:12px;
  border:1px solid rgba(255,255,255,.12);
  overflow-x:auto;
}
.auditspine-formula pre{margin:8px 0 0; white-space:pre-wrap;}
.auditspine-hr{border:none; border-top:1px solid #e5e7eb; margin:18px 0;}
</style>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position": 1,
      "name": "Home",
      "item": "https://calcdomain.com"
    },
    {
      "@type": "ListItem",
      "position": 2,
      "name": "General",
      "item": "https://calcdomain.com/categories/general"
    },
    {
      "@type": "ListItem",
      "position": 3,
      "name": "Miscellaneous",
      "item": "https://calcdomain.com/subcategories/miscellaneous"
    }
  ]
}
</script>
</head>
<body>
<a class="skip-link" href="#main-content">Skip to main content</a>

<main class="main-content" id="main-content">
<div class="container">
<nav class="text-sm mb-4 text-gray-600" aria-label="Breadcrumbs"><a href="https://calcdomain.com" class="hover:text-blue-600">Home</a> &raquo; <a href="https://calcdomain.com/categories/general" class="hover:text-blue-600">General</a> &raquo; <a href="https://calcdomain.com/subcategories/miscellaneous" class="hover:text-blue-600">Miscellaneous</a></nav>
<h1>NEC Box Fill Calculator</h1>
<p>
        This professional-grade calculator determines the minimum electrical box volume required by the US National Electrical Code (NEC) 314.16(B). It’s designed for electricians, inspectors, and engineers to quickly verify compliance by accounting for insulated conductors, equipment grounding conductors, device yokes, internal clamps, and fittings.
      </p>
<div class="calculator-layout">
<section aria-labelledby="calc-heading" class="calculator-container">
<h2 id="calc-heading">Calculator</h2>
<!-- Box volume -->
<div class="form-group">
<label for="boxVolume">Box marked volume (cubic inches) *</label>
<div class="inline-help">
<button aria-controls="tip-boxVolume" aria-expanded="false" aria-label="Help: box marked volume" class="help-btn" id="tip-boxVolume-btn" type="button">?</button>
</div>
<div class="input-group">
<input aria-describedby="boxVolumeError tip-boxVolume" aria-required="true" class="form-control" id="boxVolume" inputmode="decimal" min="0" placeholder="e.g., 20.3" step="0.25" type="number">
</div>
<div aria-live="polite" class="error-message" id="boxVolumeError" role="alert"></div>
<div aria-hidden="true" class="tooltip" id="tip-boxVolume">
              The box’s cubic-inch volume is required by NEC to be marked by the manufacturer. You’ll typically find it stamped or printed on the box. For multi-gang boxes, enter the total marked volume.
            </div>
<div aria-label="Quick picks for common box volumes" class="quick-picks" role="group">
<button class="chip" data-volume="18" type="button">18 in³</button>
<button class="chip" data-volume="20.3" type="button">20.3 in³</button>
<button class="chip" data-volume="22.5" type="button">22.5 in³</button>
<button class="chip" data-volume="25" type="button">25 in³</button>
<button class="chip" data-volume="32" type="button">32 in³</button>
</div>
</div>
<!-- Insulated conductors -->
<div class="form-group">
<label>Insulated conductors that enter and terminate/splice in this box</label>
<div class="inline-help">
<button aria-controls="tip-conductors" aria-expanded="false" aria-label="Help: insulated conductors" class="help-btn" id="tip-conductors-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-conductors">
              Count all insulated current-carrying conductors that originate outside and terminate or are spliced in the box. Pass-through (unspliced) conductors also count as one each. Do not add extra for pigtails that originate and terminate within this same box (per NEC 314.16(B)).
            </div>
<div aria-live="polite" class="group-list" id="conductorGroups"></div>
<button aria-label="Add conductor group" class="btn btn-secondary" id="addConductorGroup" type="button">+ Add conductor group</button>
</div>
<!-- Equipment grounding conductors -->
<div class="form-group">
<label for="egcCount">Equipment grounding conductors (EGC)</label>
<div class="inline-help">
<button aria-controls="tip-egc" aria-expanded="false" aria-label="Help: equipment grounding conductors" class="help-btn" id="tip-egc-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-egc">
              If one or more EGCs are present, they collectively count as a single conductor volume based on the largest EGC present. Enter the number of EGCs and select the largest EGC AWG.
            </div>
<div class="input-group" style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem">
<div>
<label class="sr-only" for="egcCount">Number of equipment grounding conductors</label>
<input aria-describedby="egcCountError tip-egc" class="form-control" id="egcCount" inputmode="numeric" min="0" placeholder="Count" step="1" type="number">
<div aria-live="polite" class="error-message" id="egcCountError" role="alert"></div>
</div>
<div>
<label class="sr-only" for="egcAwg">Largest EGC size (AWG)</label>
<select aria-describedby="egcAwgError tip-egc" class="form-control" id="egcAwg">
<option value="">Largest EGC AWG</option>
<option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
</select>
<div aria-live="polite" class="error-message" id="egcAwgError" role="alert"></div>
</div>
</div>
</div>
<!-- Device yokes -->
<div class="form-group">
<label>Device yokes (e.g., switches, receptacles)</label>
<div class="inline-help">
<button aria-controls="tip-yokes" aria-expanded="false" aria-label="Help: device yokes" class="help-btn" id="tip-yokes-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-yokes">
              Each yoke that contains one or more devices counts as two conductor volumes, using the largest AWG conductor connected to that yoke. For example, a duplex receptacle on 12 AWG counts as 2 × the 12 AWG volume.
            </div>
<div aria-live="polite" class="group-list" id="yokeGroups"></div>
<button aria-label="Add device yoke group" class="btn btn-secondary" id="addYokeGroup" type="button">+ Add yoke group</button>
</div>
<!-- Clamps and fittings -->
<div class="form-group">
<label for="internalClamps">Internal cable clamps and support fittings</label>
<div class="inline-help">
<button aria-controls="tip-clamps" aria-expanded="false" aria-label="Help: clamps and fittings" class="help-btn" id="tip-clamps-btn" type="button">?</button>
</div>
<div aria-hidden="true" class="tooltip" id="tip-clamps">
              Integral internal clamps count as one conductor volume of the largest insulated conductor in the box. Internal support fittings (like hickeys) each count as one conductor volume of the largest insulated conductor in the box.
            </div>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:.5rem">
<div class="input-group" style="display:flex; align-items:center; gap:.5rem">
<input aria-describedby="tip-clamps" id="internalClamps" type="checkbox">
<label for="internalClamps" style="margin:0">Internal cable clamps present</label>
</div>
<div>
<label class="sr-only" for="fittingCount">Number of internal fittings</label>
<input aria-describedby="fittingCountError tip-clamps" class="form-control" id="fittingCount" inputmode="numeric" min="0" placeholder="Fittings count" step="1" type="number">
<div aria-live="polite" class="error-message" id="fittingCountError" role="alert"></div>
</div>
</div>
</div>
<div class="form-group" style="display:flex; gap:.5rem; flex-wrap:wrap">
<button class="btn btn-secondary" id="resetForm" type="button">Reset</button>
</div>
<div aria-atomic="true" aria-live="polite" class="results-container">
<div class="results-header">
<h3 style="margin:0">Results</h3>
<span aria-live="polite" class="status-badge status-ok" id="statusBadge"><span aria-hidden="true">●</span>Waiting for inputs</span>
</div>
<div class="result-grid">
<div class="result-card">
<div class="label">Required minimum volume</div>
<div class="value" id="requiredVolume">0.00 in³</div>
</div>
<div class="result-card">
<div class="label">Box marked volume</div>
<div class="value" id="boxVolumeOut">—</div>
</div>
<div class="result-card">
<div class="label">Margin</div>
<div class="value" id="marginOut">—</div>
</div>
<div class="result-card">
<div class="label">Total counted “conductor equivalents”</div>
<div class="value" id="equivOut">0</div>
</div>
</div>
<div class="breakdown">
<h4>Breakdown</h4>
<ul class="breakdown-list" id="breakdownList">
<li><span class="muted">No items yet</span><span>—</span></li>
</ul>
</div>
</div>
</section>
<article aria-labelledby="content-heading" class="calculator-container">
<h2 id="content-heading">Authoritative Engineering Content</h2>
<section>
<h3>Data Source and Methodology</h3>
<p>
              Authoritative source: National Electrical Code (NEC) — NFPA 70 (2020), Article 314.16 and Table 314.16(B).
              <a href="https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70" rel="noopener" target="_blank">Official NFPA code page</a>
              (free view with account).
            </p>
<p><strong>All calculations strictly follow the formulas and allowances provided by this source.</strong></p>
<ul>
<li>Insulated conductors that enter and terminate/splice in the box: count 1 each.</li>
<li>Pass-through (unspliced) insulated conductors: count 1 each.</li>
<li>Equipment grounding conductors (all): count as 1 volume using the largest EGC present.</li>
<li>Each device yoke: counts as 2 volumes using the largest conductor connected to that yoke.</li>
<li>Integral internal clamps: count as 1 volume of the largest insulated conductor entering the box.</li>
<li>Internal fittings (e.g., hickeys): count as 1 volume each of the largest insulated conductor in the box.</li>
</ul>
<p class="field-help">
              For additional background see:
              <a href="https://www.ecmweb.com/content/article/20886012/box-fill-calculations" rel="noopener" target="_blank">ECM: Box Fill Calculations</a>,
              <a href="https://www.jadelearning.com/blog/nec-2017-article-314-16/" rel="noopener" target="_blank">JADE Learning: NEC 314.16</a>.
            </p>
</section>
<section>
<h3>The Formula Explained</h3>
<div aria-label="Mathematical formulas in LaTeX" class="formula-box">
<div style="font-family:var(--font-mono); font-size:1rem">
                Given the NEC volume allowance function V(AWG) from Table 314.16(B):<br>
                18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00 (cubic inches)
                <hr>
                Total required volume:<br>
                $$V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})$$
                where:<br>
                - $n_i$ = insulated conductors of size $\mathrm{AWG}_i$ that enter and terminate/splice (pass-through counts as 1).<br>
                - $\mathrm{EGC,max}$ = largest equipment grounding conductor AWG (counted once if any EGCs are present).<br>
                - $y_j$ = number of device yokes connected to conductors of $\mathrm{AWG}_{y_j}$ (each counts as 2 conductors).<br>
                - $\mathrm{AWG}_{\max}$ = largest insulated conductor AWG present in the box (used for clamp and fitting allowances).<br>
                - $f$ = number of internal support fittings.
              </div>
</div>
</section>
<section>
<h3>Glossary of Variables</h3>
<ul>
<li>Box marked volume (in³): Manufacturer-stamped cubic-inch capacity of the box.</li>
<li>Insulated conductors: Current-carrying conductors that enter and terminate or splice in the box; pass-throughs count once; pigtails within same box add no extra count.</li>
<li>Equipment grounding conductors (EGC): Green/bare conductors; all EGCs together count as one conductor volume using the largest EGC present.</li>
<li>Device yoke: A strap holding one or more devices (e.g., duplex receptacle). Each yoke counts as two conductors of the largest conductor on that yoke.</li>
<li>Internal clamps: Integral cable clamps inside the box; count as one conductor of the largest insulated conductor present.</li>
<li>Internal fittings: Accessories like hickeys; each counts as one conductor of the largest insulated conductor present.</li>
<li>V(AWG): NEC Table 314.16(B) volume per conductor size (in³): 18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00.</li>
</ul>
</section>
<section>
<h3>How It Works: A Step-by-Step Example</h3>
<p><strong>Scenario.</strong> Box contains: six 12 AWG insulated conductors; one duplex receptacle on 12 AWG (one yoke); two EGCs with largest EGC 12 AWG; integral clamps present; no fittings. Box marked volume = 20.3 in³.</p>
<ol>
<li>Conductor allowance: 6 × V(12) = 6 × 2.25 = 13.50 in³.</li>
<li>EGC allowance: present → 1 × V(12) = 2.25 in³.</li>
<li>Device yoke: 1 yoke → 2 × V(12) = 4.50 in³.</li>
<li>Clamp: present → 1 × V(12) = 2.25 in³.</li>
<li>Fittings: none → 0.</li>
<li>Total required: 13.50 + 2.25 + 4.50 + 2.25 = <strong>22.50 in³</strong>.</li>
<li>Comparison: 20.3 in³ box <strong>does not comply</strong> (short by 2.2 in³).</li>
</ol>
</section>
<section>
<h3>FAQ</h3>
<details>
<summary>Do pigtails count toward box fill?</summary>
<p>No additional count for pigtails that originate and terminate in the same box. Their conductors are already included per NEC 314.16(B).</p>
</details>
<details>
<summary>How are equipment grounding conductors counted?</summary>
<p>All EGCs taken together count as a single conductor volume based on the largest EGC present.</p>
</details>
<details>
<summary>Do pass-through conductors count?</summary>
<p>Yes. Each insulated pass-through (unspliced) conductor counts as one conductor volume.</p>
</details>
<details>
<summary>How do devices like duplex receptacles count?</summary>
<p>Each yoke counts as two conductor volumes using the largest conductor attached to that yoke.</p>
</details>
<details>
<summary>Do internal clamps and fittings count?</summary>
<p>Internal clamps count as one conductor volume; each internal fitting counts as one, both based on the largest insulated conductor in the box.</p>
</details>
<details>
<summary>Which AWG sizes are supported?</summary>
<p>18, 16, 14, 12, 10, 8, and 6 AWG, using the cubic-inch values in NEC Table 314.16(B).</p>
</details>
<details>
<summary>Can I use this for multi-gang boxes?</summary>
<p>Yes. Enter the total manufacturer-marked volume (sum of gangs) and include all conductors/devices in the calculation.</p>
</details>
</section>
<div class="author-box">
<p>
            </p>
</div>

<!-- AUDIT_SPINE_START -->
<hr class="auditspine-hr">
<section aria-label="Formulas, sources, changelog, verification">
  <span class="auditspine-badge">Audit: Complete</span>

  <details style="margin-top:10px">
    <summary><strong>Formula (LaTeX) + variables + units</strong></summary>
    <div class="auditspine-note" style="margin-top:10px">
      This section shows the formulas used by the calculator engine, plus variable definitions and units.
      
    </div>
    <div class="auditspine-formula">
      <div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[','\]</div>
  <pre class="auditspine-mono">','</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&amp;gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})\]</div>
  <pre class="auditspine-mono">V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&amp;gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[= (sel, ctx=document) =&gt; Array.from(ctx.querySelectorAll(sel)); const els = { boxVolume: $('#boxVolume'), boxVolumeError: $('#boxVolumeError'), quickPicks:\]</div>
  <pre class="auditspine-mono">= (sel, ctx=document) =&gt; Array.from(ctx.querySelectorAll(sel)); const els = { boxVolume: $('#boxVolume'), boxVolumeError: $('#boxVolumeError'), quickPicks:</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[('.help-btn'), }; function createConductorRow(initial = {awg:'', count:''}) { const rowId = `cg-${conductorRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'conductor-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Count of insulated conductors&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this conductor group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.conductorGroups.appendChild(row); } function createYokeRow(initial = {awg:'', count:''}) { const rowId = `yg-${yokeRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'yoke-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Device yoke conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Number of device yokes&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this yoke group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.yokeGroups.appendChild(row); } // Validation helpers function setError(el, msg) { el.textContent = msg || ''; } function markInvalid(input, invalid, describedById) { input.setAttribute('aria-invalid', invalid ? 'true' : 'false'); if (describedById) input.setAttribute('aria-describedby', describedById); } function parseIntSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } function parseFloatSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } // Field-specific validation function validateBoxVolume() { const val = parseFloatSafe(els.boxVolume.value); if (isNaN(val)) { setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } if (val &lt;= 0) { setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } setError(els.boxVolumeError, ''); markInvalid(els.boxVolume, false, 'boxVolumeError'); return val; } function validateEgc() { const count = parseIntSafe(els.egcCount.value); const awg = els.egcAwg.value; let ok = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { setError(els.egcCountError, 'Count cannot be negative.'); markInvalid(els.egcCount, true, 'egcCountError'); ok = false; } else { setError(els.egcCountError, ''); markInvalid(els.egcCount, false, 'egcCountError'); } if (count &gt; 0 &amp;&amp; !awg) { setError(els.egcAwgError, 'Select the largest EGC size (AWG).'); markInvalid(els.egcAwg, true, 'egcAwgError'); ok = false; } else { setError(els.egcAwgError, ''); markInvalid(els.egcAwg, false, 'egcAwgError'); } return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null; } function validateFittings() { const count = parseIntSafe(els.fittingCount.value); if (isNaN(count)) { setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return 0; } if (count &lt; 0) { setError(els.fittingCountError, 'Count cannot be negative.'); markInvalid(els.fittingCount, true, 'fittingCountError'); return null; } setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return count; } function validateGroupRow(row) { const isConductor = row.getAttribute('data-role') === 'conductor-row'; const idPrefix = row.querySelector('select').id.replace(/-awg$/, ''); const sel = row.querySelector(`#${idPrefix}-awg`); const cntInput = row.querySelector(`#${idPrefix}-count`); const err = row.querySelector(`#${idPrefix}-error`); const count = parseIntSafe(cntInput.value); const awg = sel.value; let valid = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { err.textContent = 'Count cannot be negative.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } else { cntInput.setAttribute('aria-invalid','false'); } if ((count || count === 0) &amp;&amp; count &gt; 0 &amp;&amp; !awg) { err.textContent = 'Select an AWG size for this group.'; sel.setAttribute('aria-invalid','true'); valid = false; } else { sel.setAttribute('aria-invalid','false'); } if ((count === 0 || isNaN(count)) &amp;&amp; !awg) { err.textContent = ''; } else if (valid) { err.textContent = ''; } // For yokes, ensure integer counts if (row.getAttribute('data-role') === 'yoke-row' &amp;&amp; !isNaN(count) &amp;&amp; !Number.isInteger(count)) { err.textContent = 'Number of yokes must be a whole number.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } return valid ? { count: isNaN(count) ? 0 : count, awg: awg || '' } : null; } function collectInputs() { // Box volume can be null (not provided); we still compute required const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume(); // Conductors const conductors = []; for (const row of\]</div>
  <pre class="auditspine-mono">('.help-btn'), }; function createConductorRow(initial = {awg:'', count:''}) { const rowId = `cg-${conductorRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'conductor-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Count of insulated conductors&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this conductor group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.conductorGroups.appendChild(row); } function createYokeRow(initial = {awg:'', count:''}) { const rowId = `yg-${yokeRowId++}`; const row = document.createElement('div'); row.className = 'group-row'; row.setAttribute('data-role', 'yoke-row'); row.innerHTML = ` &lt;div&gt; &lt;label class="sr-only" for="${rowId}-awg"&gt;Device yoke conductor size (AWG)&lt;/label&gt; &lt;select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error"&gt; &lt;option value=""&gt;AWG size&lt;/option&gt; &lt;option&gt;18&lt;/option&gt;&lt;option&gt;16&lt;/option&gt;&lt;option&gt;14&lt;/option&gt;&lt;option&gt;12&lt;/option&gt;&lt;option&gt;10&lt;/option&gt;&lt;option&gt;8&lt;/option&gt;&lt;option&gt;6&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label class="sr-only" for="${rowId}-count"&gt;Number of device yokes&lt;/label&gt; &lt;input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error"&gt; &lt;/div&gt; &lt;div style="display:flex; gap:.5rem; align-items:center"&gt; &lt;button class="remove-btn" type="button" aria-label="Remove this yoke group"&gt;Remove&lt;/button&gt; &lt;/div&gt; &lt;div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"&gt;&lt;/div&gt; `; if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg; if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count; els.yokeGroups.appendChild(row); } // Validation helpers function setError(el, msg) { el.textContent = msg || ''; } function markInvalid(input, invalid, describedById) { input.setAttribute('aria-invalid', invalid ? 'true' : 'false'); if (describedById) input.setAttribute('aria-describedby', describedById); } function parseIntSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } function parseFloatSafe(value) { if (value === '' || value === null || value === undefined) return NaN; const n = Number(value); return Number.isFinite(n) ? n : NaN; } // Field-specific validation function validateBoxVolume() { const val = parseFloatSafe(els.boxVolume.value); if (isNaN(val)) { setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } if (val &lt;= 0) { setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.'); markInvalid(els.boxVolume, true, 'boxVolumeError'); return null; } setError(els.boxVolumeError, ''); markInvalid(els.boxVolume, false, 'boxVolumeError'); return val; } function validateEgc() { const count = parseIntSafe(els.egcCount.value); const awg = els.egcAwg.value; let ok = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { setError(els.egcCountError, 'Count cannot be negative.'); markInvalid(els.egcCount, true, 'egcCountError'); ok = false; } else { setError(els.egcCountError, ''); markInvalid(els.egcCount, false, 'egcCountError'); } if (count &gt; 0 &amp;&amp; !awg) { setError(els.egcAwgError, 'Select the largest EGC size (AWG).'); markInvalid(els.egcAwg, true, 'egcAwgError'); ok = false; } else { setError(els.egcAwgError, ''); markInvalid(els.egcAwg, false, 'egcAwgError'); } return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null; } function validateFittings() { const count = parseIntSafe(els.fittingCount.value); if (isNaN(count)) { setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return 0; } if (count &lt; 0) { setError(els.fittingCountError, 'Count cannot be negative.'); markInvalid(els.fittingCount, true, 'fittingCountError'); return null; } setError(els.fittingCountError, ''); markInvalid(els.fittingCount, false, 'fittingCountError'); return count; } function validateGroupRow(row) { const isConductor = row.getAttribute('data-role') === 'conductor-row'; const idPrefix = row.querySelector('select').id.replace(/-awg$/, ''); const sel = row.querySelector(`#${idPrefix}-awg`); const cntInput = row.querySelector(`#${idPrefix}-count`); const err = row.querySelector(`#${idPrefix}-error`); const count = parseIntSafe(cntInput.value); const awg = sel.value; let valid = true; if (!isNaN(count) &amp;&amp; count &lt; 0) { err.textContent = 'Count cannot be negative.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } else { cntInput.setAttribute('aria-invalid','false'); } if ((count || count === 0) &amp;&amp; count &gt; 0 &amp;&amp; !awg) { err.textContent = 'Select an AWG size for this group.'; sel.setAttribute('aria-invalid','true'); valid = false; } else { sel.setAttribute('aria-invalid','false'); } if ((count === 0 || isNaN(count)) &amp;&amp; !awg) { err.textContent = ''; } else if (valid) { err.textContent = ''; } // For yokes, ensure integer counts if (row.getAttribute('data-role') === 'yoke-row' &amp;&amp; !isNaN(count) &amp;&amp; !Number.isInteger(count)) { err.textContent = 'Number of yokes must be a whole number.'; cntInput.setAttribute('aria-invalid','true'); valid = false; } return valid ? { count: isNaN(count) ? 0 : count, awg: awg || '' } : null; } function collectInputs() { // Box volume can be null (not provided); we still compute required const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume(); // Conductors const conductors = []; for (const row of</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted LaTeX)</strong></div>
  <div style="margin-top:6px">\[('#yokeGroups .group-row')) { const v = validateGroupRow(row); if (v === null) return null; // invalid if (v.count &gt; 0 &amp;&amp; v.awg) yokes.push(v); } // EGC const egc = validateEgc(); if (egc === null) return null; // Fittings const fittings = validateFittings(); if (fittings === null) return null; const clamps = els.internalClamps.checked; return { boxVol, conductors, yokes, egc, fittings, clamps }; } function largestInsulatedAWG(conductors, yokes) { // Return the physically largest conductor (smallest AWG number) // We compare by numerical value, but NEC table is discrete for listed sizes only. const sizes = new Set(); conductors.forEach(c =&gt; sizes.add(c.awg)); yokes.forEach(y =&gt; sizes.add(y.awg)); const arr = Array.from(sizes).map(Number).filter(Boolean); if (arr.length === 0) return null; // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12) return Math.min(...arr); } function compute() { const input = collectInputs(); if (!input) { // Invalid fields; keep results minimal renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []}); return; } const { boxVol, conductors, yokes, egc, fittings, clamps } = input; // Aggregate by AWG for conductors let breakdown = []; let required = 0; let equivalents = 0; // Conductors const condMap = new Map(); for (const c of conductors) { const cnt = condMap.get(c.awg) || 0; condMap.set(c.awg, cnt + c.count); } for (const [awg, count] of condMap) { const vol = (VOLUME_BY_AWG[awg] || 0) * count; required += vol; equivalents += count; breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol}); } // EGC (all count as one of largest EGC present) if (egc.count &gt; 0 &amp;&amp; egc.awg) { const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol}); } // Yokes for (const y of yokes) { const addEq = y.count * 2; const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq; required += vol; equivalents += addEq; breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol}); } // Largest insulated AWG for clamps/fittings const awgMax = largestInsulatedAWG(conductors, yokes); if (clamps &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol}); } if (fittings &gt; 0 &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings; required += vol; equivalents += fittings; breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol}); } const result = { required, box: boxVol, margin: (typeof boxVol === 'number') ? (boxVol - required) : null, ok: (typeof boxVol === 'number') ? (boxVol &gt;= required) : null, equiv: equivalents, breakdown }; renderResults(result); } function formatIn3(n) { return `${n.toFixed(2)} in³`; } function readBoxVolOrNull(){ const v = parseFloatSafe(els.boxVolume.value); return isNaN(v) ? null : v; } function renderResults({required, box, margin, ok, equiv, breakdown}) { // Required $('#requiredVolume').textContent = formatIn3(required || 0); // Box and margin if (typeof box === 'number') { $('#boxVolumeOut').textContent = formatIn3(box); const mEl = $('#marginOut'); if (typeof margin === 'number') { const pct = (box &gt; 0) ? (margin / box * 100) : 0; mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`; mEl.className = 'value ' + (margin &gt;= 0 ? 'value-ok' : 'value-bad'); } else { mEl.textContent = '—'; mEl.className = 'value'; } } else { $('#boxVolumeOut').textContent = '—'; $('#marginOut').textContent = '—'; $('#marginOut').className = 'value'; } // Equivalents $('#equivOut').textContent = String(equiv || 0); // Status const status = $('#statusBadge'); if (ok === null) { status.className = 'status-badge'; status.textContent = 'Waiting for inputs'; } else if (ok) { status.className = 'status-badge status-ok'; status.textContent = 'Compliant ✓'; } else { status.className = 'status-badge status-fail'; status.textContent = 'Not compliant ✕'; } // Breakdown const list = $('#breakdownList'); list.innerHTML = ''; if (!breakdown || breakdown.length === 0) { const li = document.createElement('li'); li.innerHTML = '&lt;span class="muted"&gt;No items yet&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;'; list.appendChild(li); } else { for (const item of breakdown) { const li = document.createElement('li'); const left = document.createElement('span'); const right = document.createElement('span'); left.textContent = item.label; right.textContent = formatIn3(item.vol); li.appendChild(left); li.appendChild(right); list.appendChild(li); } } } // Event wiring function onBlurRecalc(e) { const target = e.target; if (target.matches('input, select')) { // Validate specific fields if (target === els.boxVolume) validateBoxVolume(); if (target === els.egcCount || target === els.egcAwg) validateEgc(); if (target === els.fittingCount) validateFittings(); if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row')); compute(); } } function onClick(e){ const t = e.target; // Quick pick chips if (t.matches('.chip[data-volume]')) { els.boxVolume.value = t.getAttribute('data-volume'); validateBoxVolume(); compute(); } // Add/Remove rows if (t === els.addConductorGroup) { createConductorRow({awg:'', count:''}); // Move focus into new row count const rows =\]</div>
  <pre class="auditspine-mono">('#yokeGroups .group-row')) { const v = validateGroupRow(row); if (v === null) return null; // invalid if (v.count &gt; 0 &amp;&amp; v.awg) yokes.push(v); } // EGC const egc = validateEgc(); if (egc === null) return null; // Fittings const fittings = validateFittings(); if (fittings === null) return null; const clamps = els.internalClamps.checked; return { boxVol, conductors, yokes, egc, fittings, clamps }; } function largestInsulatedAWG(conductors, yokes) { // Return the physically largest conductor (smallest AWG number) // We compare by numerical value, but NEC table is discrete for listed sizes only. const sizes = new Set(); conductors.forEach(c =&gt; sizes.add(c.awg)); yokes.forEach(y =&gt; sizes.add(y.awg)); const arr = Array.from(sizes).map(Number).filter(Boolean); if (arr.length === 0) return null; // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12) return Math.min(...arr); } function compute() { const input = collectInputs(); if (!input) { // Invalid fields; keep results minimal renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []}); return; } const { boxVol, conductors, yokes, egc, fittings, clamps } = input; // Aggregate by AWG for conductors let breakdown = []; let required = 0; let equivalents = 0; // Conductors const condMap = new Map(); for (const c of conductors) { const cnt = condMap.get(c.awg) || 0; condMap.set(c.awg, cnt + c.count); } for (const [awg, count] of condMap) { const vol = (VOLUME_BY_AWG[awg] || 0) * count; required += vol; equivalents += count; breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol}); } // EGC (all count as one of largest EGC present) if (egc.count &gt; 0 &amp;&amp; egc.awg) { const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol}); } // Yokes for (const y of yokes) { const addEq = y.count * 2; const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq; required += vol; equivalents += addEq; breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol}); } // Largest insulated AWG for clamps/fittings const awgMax = largestInsulatedAWG(conductors, yokes); if (clamps &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1; required += vol; equivalents += 1; breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol}); } if (fittings &gt; 0 &amp;&amp; awgMax) { const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings; required += vol; equivalents += fittings; breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol}); } const result = { required, box: boxVol, margin: (typeof boxVol === 'number') ? (boxVol - required) : null, ok: (typeof boxVol === 'number') ? (boxVol &gt;= required) : null, equiv: equivalents, breakdown }; renderResults(result); } function formatIn3(n) { return `${n.toFixed(2)} in³`; } function readBoxVolOrNull(){ const v = parseFloatSafe(els.boxVolume.value); return isNaN(v) ? null : v; } function renderResults({required, box, margin, ok, equiv, breakdown}) { // Required $('#requiredVolume').textContent = formatIn3(required || 0); // Box and margin if (typeof box === 'number') { $('#boxVolumeOut').textContent = formatIn3(box); const mEl = $('#marginOut'); if (typeof margin === 'number') { const pct = (box &gt; 0) ? (margin / box * 100) : 0; mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`; mEl.className = 'value ' + (margin &gt;= 0 ? 'value-ok' : 'value-bad'); } else { mEl.textContent = '—'; mEl.className = 'value'; } } else { $('#boxVolumeOut').textContent = '—'; $('#marginOut').textContent = '—'; $('#marginOut').className = 'value'; } // Equivalents $('#equivOut').textContent = String(equiv || 0); // Status const status = $('#statusBadge'); if (ok === null) { status.className = 'status-badge'; status.textContent = 'Waiting for inputs'; } else if (ok) { status.className = 'status-badge status-ok'; status.textContent = 'Compliant ✓'; } else { status.className = 'status-badge status-fail'; status.textContent = 'Not compliant ✕'; } // Breakdown const list = $('#breakdownList'); list.innerHTML = ''; if (!breakdown || breakdown.length === 0) { const li = document.createElement('li'); li.innerHTML = '&lt;span class="muted"&gt;No items yet&lt;/span&gt;&lt;span&gt;—&lt;/span&gt;'; list.appendChild(li); } else { for (const item of breakdown) { const li = document.createElement('li'); const left = document.createElement('span'); const right = document.createElement('span'); left.textContent = item.label; right.textContent = formatIn3(item.vol); li.appendChild(left); li.appendChild(right); list.appendChild(li); } } } // Event wiring function onBlurRecalc(e) { const target = e.target; if (target.matches('input, select')) { // Validate specific fields if (target === els.boxVolume) validateBoxVolume(); if (target === els.egcCount || target === els.egcAwg) validateEgc(); if (target === els.fittingCount) validateFittings(); if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row')); compute(); } } function onClick(e){ const t = e.target; // Quick pick chips if (t.matches('.chip[data-volume]')) { els.boxVolume.value = t.getAttribute('data-volume'); validateBoxVolume(); compute(); } // Add/Remove rows if (t === els.addConductorGroup) { createConductorRow({awg:'', count:''}); // Move focus into new row count const rows =</pre>
</div>
<div style="margin:10px 0">
  <div><strong>Formula (extracted text)</strong></div>
  
  <pre class="auditspine-mono">Given the NEC volume allowance function V(AWG) from Table 314.16(B): 18→1.50, 16→1.75, 14→2.00, 12→2.25, 10→2.50, 8→3.00, 6→5.00 (cubic inches) Total required volume: $V_{req} \;=\; \sum_{i} n_i \cdot V(\mathrm{AWG}_i)\;+\; \mathbf{1}_{\mathrm{EGC}&gt;0}\cdot V(\mathrm{AWG}_{\mathrm{EGC,max}})\;+\; 2\!\!\sum_{j} y_j \cdot V(\mathrm{AWG}_{y_j})\;+\; \mathbf{1}_{\mathrm{clamp}}\cdot V(\mathrm{AWG}_{\max})\;+\; f \cdot V(\mathrm{AWG}_{\max})$ where: - $n_i$ = insulated conductors of size $\mathrm{AWG}_i$ that enter and terminate/splice (pass-through counts as 1). - $\mathrm{EGC,max}$ = largest equipment grounding conductor AWG (counted once if any EGCs are present). - $y_j$ = number of device yokes connected to conductors of $\mathrm{AWG}_{y_j}$ (each counts as 2 conductors). - $\mathrm{AWG}_{\max}$ = largest insulated conductor AWG present in the box (used for clamp and fitting allowances). - $f$ = number of internal support fittings.</pre>
</div>
      <div style="margin-top:12px"><strong>Variables and units</strong></div>
      <ul style="margin:8px 0 0 18px">
        <li><em>No variables provided in audit spec.</em></li>
      </ul>
    </div>
  </details>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Sources (authoritative):</strong>
    <ul style="margin:8px 0 0 18px">
      <li><strong>Engineering</strong> — calcdomain.com · Accessed 2026-01-19<br><a href="https://calcdomain.com/engineering" target="_blank" rel="nofollow noopener">https://calcdomain.com/engineering</a></li>
<li><strong>Electrical (US NEC)</strong> — calcdomain.com · Accessed 2026-01-19<br><a href="https://calcdomain.com/subcategories/electrical" target="_blank" rel="nofollow noopener">https://calcdomain.com/subcategories/electrical</a></li>
<li><strong>Official NFPA code page</strong> — nfpa.org · Accessed 2026-01-19<br><a href="https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70" target="_blank" rel="nofollow noopener">https://www.nfpa.org/codes-and-standards/all-codes-and-standards/list-of-codes-and-standards/detail?code=70</a></li>
<li><strong>ECM: Box Fill Calculations</strong> — ecmweb.com · Accessed 2026-01-19<br><a href="https://www.ecmweb.com/content/article/20886012/box-fill-calculations" target="_blank" rel="nofollow noopener">https://www.ecmweb.com/content/article/20886012/box-fill-calculations</a></li>
<li><strong>JADE Learning: NEC 314.16</strong> — jadelearning.com · Accessed 2026-01-19<br><a href="https://www.jadelearning.com/blog/nec-2017-article-314-16/" target="_blank" rel="nofollow noopener">https://www.jadelearning.com/blog/nec-2017-article-314-16/</a></li>
    </ul>
  </div>

  <div class="auditspine-changelog" style="margin-top:12px">
    <strong>Changelog</strong><br>
    <div style="margin-top:6px">
      <strong>Version:</strong> 0.1.0-draft<br>
      <strong>Last code update:</strong> 2026-01-19
    </div>
    <div style="margin-top:10px">
  <strong>0.1.0-draft</strong> · 2026-01-19
  <ul style="margin:6px 0 0 18px">
    <li>Initial audit spec draft generated from HTML extraction (review required).</li>
<li>Verify formulas match the calculator engine and convert any text-only formulas to LaTeX.</li>
<li>Confirm sources are authoritative and relevant to the calculator methodology.</li>
  </ul>
</div>
  </div>

  <div class="auditspine-note" style="margin-top:12px">
    <strong>Verified by Ugo Candido on 2026-01-19</strong><br>
    <a href="https://calcdomain.com/ugocandido" target="_blank" rel="noopener">Profile</a> ·
    <a href="https://www.linkedin.com/in/ugocandido92821/" target="_blank" rel="noopener">LinkedIn</a>
  </div>
</section>
<!-- AUDIT_SPINE_END -->
</article>
</div>
</div>
</main>
<!-- Standard Footer --> 
<script defer="">
    (function(){
      'use strict';

      // Volume allowances per NEC Table 314.16(B) in cubic inches
      const VOLUME_BY_AWG = {
        18: 1.50,
        16: 1.75,
        14: 2.00,
        12: 2.25,
        10: 2.50,
        8: 3.00,
        6: 5.00
      };

      // State
      let conductorRowId = 0;
      let yokeRowId = 0;

      const $ = (sel, ctx=document) => ctx.querySelector(sel);
      const $$ = (sel, ctx=document) => Array.from(ctx.querySelectorAll(sel));

      const els = {
        boxVolume: $('#boxVolume'),
        boxVolumeError: $('#boxVolumeError'),
        quickPicks: $$('.chip[data-volume]'),
        statusBadge: $('#statusBadge'),
        requiredVolume: $('#requiredVolume'),
        boxVolumeOut: $('#boxVolumeOut'),
        marginOut: $('#marginOut'),
        equivOut: $('#equivOut'),
        breakdownList: $('#breakdownList'),
        conductorGroups: $('#conductorGroups'),
        addConductorGroup: $('#addConductorGroup'),
        egcCount: $('#egcCount'),
        egcCountError: $('#egcCountError'),
        egcAwg: $('#egcAwg'),
        egcAwgError: $('#egcAwgError'),
        yokeGroups: $('#yokeGroups'),
        addYokeGroup: $('#addYokeGroup'),
        internalClamps: $('#internalClamps'),
        fittingCount: $('#fittingCount'),
        fittingCountError: $('#fittingCountError'),
        resetForm: $('#resetForm'),

        // Tooltips
        tipBtns: $$('.help-btn'),
      };

      function createConductorRow(initial = {awg:'', count:''}) {
        const rowId = `cg-${conductorRowId++}`;
        const row = document.createElement('div');
        row.className = 'group-row';
        row.setAttribute('data-role', 'conductor-row');
        row.innerHTML = `
          <div>
            <label class="sr-only" for="${rowId}-awg">Conductor size (AWG)</label>
            <select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error">
              <option value="">AWG size</option>
              <option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
            </select>
          </div>
          <div>
            <label class="sr-only" for="${rowId}-count">Count of insulated conductors</label>
            <input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Count" aria-describedby="${rowId}-error">
          </div>
          <div style="display:flex; gap:.5rem; align-items:center">
            <button class="remove-btn" type="button" aria-label="Remove this conductor group">Remove</button>
          </div>
          <div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"></div>
        `;
        if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg;
        if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count;
        els.conductorGroups.appendChild(row);
      }

      function createYokeRow(initial = {awg:'', count:''}) {
        const rowId = `yg-${yokeRowId++}`;
        const row = document.createElement('div');
        row.className = 'group-row';
        row.setAttribute('data-role', 'yoke-row');
        row.innerHTML = `
          <div>
            <label class="sr-only" for="${rowId}-awg">Device yoke conductor size (AWG)</label>
            <select id="${rowId}-awg" class="form-control" aria-describedby="${rowId}-error">
              <option value="">AWG size</option>
              <option>18</option><option>16</option><option>14</option><option>12</option><option>10</option><option>8</option><option>6</option>
            </select>
          </div>
          <div>
            <label class="sr-only" for="${rowId}-count">Number of device yokes</label>
            <input id="${rowId}-count" class="form-control" type="number" inputmode="numeric" min="0" step="1" placeholder="Yokes" aria-describedby="${rowId}-error">
          </div>
          <div style="display:flex; gap:.5rem; align-items:center">
            <button class="remove-btn" type="button" aria-label="Remove this yoke group">Remove</button>
          </div>
          <div id="${rowId}-error" class="error-message" role="alert" aria-live="polite"></div>
        `;
        if (initial.awg) row.querySelector(`#${rowId}-awg`).value = initial.awg;
        if (initial.count !== '') row.querySelector(`#${rowId}-count`).value = initial.count;
        els.yokeGroups.appendChild(row);
      }

      // Validation helpers
      function setError(el, msg) {
        el.textContent = msg || '';
      }
      function markInvalid(input, invalid, describedById) {
        input.setAttribute('aria-invalid', invalid ? 'true' : 'false');
        if (describedById) input.setAttribute('aria-describedby', describedById);
      }
      function parseIntSafe(value) {
        if (value === '' || value === null || value === undefined) return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
      }
      function parseFloatSafe(value) {
        if (value === '' || value === null || value === undefined) return NaN;
        const n = Number(value);
        return Number.isFinite(n) ? n : NaN;
      }

      // Field-specific validation
      function validateBoxVolume() {
        const val = parseFloatSafe(els.boxVolume.value);
        if (isNaN(val)) {
          setError(els.boxVolumeError, 'Please enter the marked box volume in cubic inches.');
          markInvalid(els.boxVolume, true, 'boxVolumeError');
          return null;
        }
        if (val <= 0) {
          setError(els.boxVolumeError, 'Box volume must be greater than 0. Check the manufacturer marking.');
          markInvalid(els.boxVolume, true, 'boxVolumeError');
          return null;
        }
        setError(els.boxVolumeError, '');
        markInvalid(els.boxVolume, false, 'boxVolumeError');
        return val;
      }

      function validateEgc() {
        const count = parseIntSafe(els.egcCount.value);
        const awg = els.egcAwg.value;
        let ok = true;

        if (!isNaN(count) && count < 0) {
          setError(els.egcCountError, 'Count cannot be negative.');
          markInvalid(els.egcCount, true, 'egcCountError');
          ok = false;
        } else {
          setError(els.egcCountError, '');
          markInvalid(els.egcCount, false, 'egcCountError');
        }

        if (count > 0 && !awg) {
          setError(els.egcAwgError, 'Select the largest EGC size (AWG).');
          markInvalid(els.egcAwg, true, 'egcAwgError');
          ok = false;
        } else {
          setError(els.egcAwgError, '');
          markInvalid(els.egcAwg, false, 'egcAwgError');
        }

        return ok ? {count: isNaN(count) ? 0 : count, awg: awg || ''} : null;
      }

      function validateFittings() {
        const count = parseIntSafe(els.fittingCount.value);
        if (isNaN(count)) {
          setError(els.fittingCountError, '');
          markInvalid(els.fittingCount, false, 'fittingCountError');
          return 0;
        }
        if (count < 0) {
          setError(els.fittingCountError, 'Count cannot be negative.');
          markInvalid(els.fittingCount, true, 'fittingCountError');
          return null;
        }
        setError(els.fittingCountError, '');
        markInvalid(els.fittingCount, false, 'fittingCountError');
        return count;
      }

      function validateGroupRow(row) {
        const isConductor = row.getAttribute('data-role') === 'conductor-row';
        const idPrefix = row.querySelector('select').id.replace(/-awg$/, '');
        const sel = row.querySelector(`#${idPrefix}-awg`);
        const cntInput = row.querySelector(`#${idPrefix}-count`);
        const err = row.querySelector(`#${idPrefix}-error`);

        const count = parseIntSafe(cntInput.value);
        const awg = sel.value;
        let valid = true;

        if (!isNaN(count) && count < 0) {
          err.textContent = 'Count cannot be negative.';
          cntInput.setAttribute('aria-invalid','true');
          valid = false;
        } else {
          cntInput.setAttribute('aria-invalid','false');
        }

        if ((count || count === 0) && count > 0 && !awg) {
          err.textContent = 'Select an AWG size for this group.';
          sel.setAttribute('aria-invalid','true');
          valid = false;
        } else {
          sel.setAttribute('aria-invalid','false');
        }

        if ((count === 0 || isNaN(count)) && !awg) {
          err.textContent = '';
        } else if (valid) {
          err.textContent = '';
        }

        // For yokes, ensure integer counts
        if (row.getAttribute('data-role') === 'yoke-row' && !isNaN(count) && !Number.isInteger(count)) {
          err.textContent = 'Number of yokes must be a whole number.';
          cntInput.setAttribute('aria-invalid','true');
          valid = false;
        }

        return valid ? {
          count: isNaN(count) ? 0 : count,
          awg: awg || ''
        } : null;
      }

      function collectInputs() {
        // Box volume can be null (not provided); we still compute required
        const boxVol = (els.boxVolume.value.trim() === '') ? null : validateBoxVolume();

        // Conductors
        const conductors = [];
        for (const row of $$('#conductorGroups .group-row')) {
          const v = validateGroupRow(row);
          if (v === null) return null; // invalid
          if (v.count > 0 && v.awg) conductors.push(v);
        }

        // Yokes
        const yokes = [];
        for (const row of $$('#yokeGroups .group-row')) {
          const v = validateGroupRow(row);
          if (v === null) return null; // invalid
          if (v.count > 0 && v.awg) yokes.push(v);
        }

        // EGC
        const egc = validateEgc();
        if (egc === null) return null;

        // Fittings
        const fittings = validateFittings();
        if (fittings === null) return null;

        const clamps = els.internalClamps.checked;

        return { boxVol, conductors, yokes, egc, fittings, clamps };
      }

      function largestInsulatedAWG(conductors, yokes) {
        // Return the physically largest conductor (smallest AWG number)
        // We compare by numerical value, but NEC table is discrete for listed sizes only.
        const sizes = new Set();
        conductors.forEach(c => sizes.add(c.awg));
        yokes.forEach(y => sizes.add(y.awg));
        const arr = Array.from(sizes).map(Number).filter(Boolean);
        if (arr.length === 0) return null;
        // Larger conductor is smaller numeric AWG (e.g., 6 is larger than 12)
        return Math.min(...arr);
      }

      function compute() {
        const input = collectInputs();
        if (!input) {
          // Invalid fields; keep results minimal
          renderResults({required: 0, box: readBoxVolOrNull(), margin: null, ok: null, equiv: 0, breakdown: []});
          return;
        }

        const { boxVol, conductors, yokes, egc, fittings, clamps } = input;

        // Aggregate by AWG for conductors
        let breakdown = [];
        let required = 0;
        let equivalents = 0;

        // Conductors
        const condMap = new Map();
        for (const c of conductors) {
          const cnt = condMap.get(c.awg) || 0;
          condMap.set(c.awg, cnt + c.count);
        }
        for (const [awg, count] of condMap) {
          const vol = (VOLUME_BY_AWG[awg] || 0) * count;
          required += vol;
          equivalents += count;
          breakdown.push({label:`Insulated conductors ${awg} AWG × ${count}`, vol});
        }

        // EGC (all count as one of largest EGC present)
        if (egc.count > 0 && egc.awg) {
          const vol = (VOLUME_BY_AWG[egc.awg] || 0) * 1;
          required += vol;
          equivalents += 1;
          breakdown.push({label:`Equipment grounding conductors (all) counted as 1 of ${egc.awg} AWG`, vol});
        }

        // Yokes
        for (const y of yokes) {
          const addEq = y.count * 2;
          const vol = (VOLUME_BY_AWG[y.awg] || 0) * addEq;
          required += vol;
          equivalents += addEq;
          breakdown.push({label:`Device yokes ${y.awg} AWG × ${y.count} (2 conductors per yoke)`, vol});
        }

        // Largest insulated AWG for clamps/fittings
        const awgMax = largestInsulatedAWG(conductors, yokes);
        if (clamps && awgMax) {
          const vol = (VOLUME_BY_AWG[awgMax] || 0) * 1;
          required += vol;
          equivalents += 1;
          breakdown.push({label:`Internal clamps (1 × ${awgMax} AWG)`, vol});
        }
        if (fittings > 0 && awgMax) {
          const vol = (VOLUME_BY_AWG[awgMax] || 0) * fittings;
          required += vol;
          equivalents += fittings;
          breakdown.push({label:`Internal fittings × ${fittings} (${awgMax} AWG)`, vol});
        }

        const result = {
          required,
          box: boxVol,
          margin: (typeof boxVol === 'number') ? (boxVol - required) : null,
          ok: (typeof boxVol === 'number') ? (boxVol >= required) : null,
          equiv: equivalents,
          breakdown
        };

        renderResults(result);
      }

      function formatIn3(n) {
        return `${n.toFixed(2)} in³`;
      }

      function readBoxVolOrNull(){
        const v = parseFloatSafe(els.boxVolume.value);
        return isNaN(v) ? null : v;
      }

      function renderResults({required, box, margin, ok, equiv, breakdown}) {
        // Required
        $('#requiredVolume').textContent = formatIn3(required || 0);

        // Box and margin
        if (typeof box === 'number') {
          $('#boxVolumeOut').textContent = formatIn3(box);
          const mEl = $('#marginOut');
          if (typeof margin === 'number') {
            const pct = (box > 0) ? (margin / box * 100) : 0;
            mEl.textContent = `${formatIn3(margin)} (${pct.toFixed(1)}%)`;
            mEl.className = 'value ' + (margin >= 0 ? 'value-ok' : 'value-bad');
          } else {
            mEl.textContent = '—';
            mEl.className = 'value';
          }
        } else {
          $('#boxVolumeOut').textContent = '—';
          $('#marginOut').textContent = '—';
          $('#marginOut').className = 'value';
        }

        // Equivalents
        $('#equivOut').textContent = String(equiv || 0);

        // Status
        const status = $('#statusBadge');
        if (ok === null) {
          status.className = 'status-badge';
          status.textContent = 'Waiting for inputs';
        } else if (ok) {
          status.className = 'status-badge status-ok';
          status.textContent = 'Compliant ✓';
        } else {
          status.className = 'status-badge status-fail';
          status.textContent = 'Not compliant ✕';
        }

        // Breakdown
        const list = $('#breakdownList');
        list.innerHTML = '';
        if (!breakdown || breakdown.length === 0) {
          const li = document.createElement('li');
          li.innerHTML = '<span class="muted">No items yet</span><span>—</span>';
          list.appendChild(li);
        } else {
          for (const item of breakdown) {
            const li = document.createElement('li');
            const left = document.createElement('span');
            const right = document.createElement('span');
            left.textContent = item.label;
            right.textContent = formatIn3(item.vol);
            li.appendChild(left);
            li.appendChild(right);
            list.appendChild(li);
          }
        }
      }

      // Event wiring
      function onBlurRecalc(e) {
        const target = e.target;
        if (target.matches('input, select')) {
          // Validate specific fields
          if (target === els.boxVolume) validateBoxVolume();
          if (target === els.egcCount || target === els.egcAwg) validateEgc();
          if (target === els.fittingCount) validateFittings();
          if (target.closest('.group-row')) validateGroupRow(target.closest('.group-row'));
          compute();
        }
      }

      function onClick(e){
        const t = e.target;

        // Quick pick chips
        if (t.matches('.chip[data-volume]')) {
          els.boxVolume.value = t.getAttribute('data-volume');
          validateBoxVolume();
          compute();
        }

        // Add/Remove rows
        if (t === els.addConductorGroup) {
          createConductorRow({awg:'', count:''});
          // Move focus into new row count
          const rows = $$('#conductorGroups .group-row');
          const last = rows[rows.length-1];
          last.querySelector('select').focus();
        }
        if (t === els.addYokeGroup) {
          createYokeRow({awg:'', count:''});
          const rows = $$('#yokeGroups .group-row');
          const last = rows[rows.length-1];
          last.querySelector('select').focus();
        }
        if (t.matches('.group-row .remove-btn')) {
          const row = t.closest('.group-row');
          row.parentElement.removeChild(row);
          compute();
        }

        // Reset
        if (t === els.resetForm) {
          resetAll();
        }

        // Tooltips
        if (t.matches('.help-btn')) {
          const btn = t;
          const id = btn.getAttribute('aria-controls');
          const panel = document.getElementById(id);
          const expanded = btn.getAttribute('aria-expanded') === 'true';
          btn.setAttribute('aria-expanded', String(!expanded));
          panel.setAttribute('aria-hidden', String(expanded));
        }
      }

      function resetAll(){
        els.boxVolume.value = '';
        setError(els.boxVolumeError,'');
        markInvalid(els.boxVolume,false,'boxVolumeError');

        els.conductorGroups.innerHTML = '';
        createConductorRow({awg:'', count:''});

        els.egcCount.value = '';
        els.egcAwg.value = '';
        setError(els.egcCountError,''); setError(els.egcAwgError,'');
        els.egcCount.setAttribute('aria-invalid','false'); els.egcAwg.setAttribute('aria-invalid','false');

        els.yokeGroups.innerHTML = '';
        createYokeRow({awg:'', count:''});

        els.internalClamps.checked = false;
        els.fittingCount.value = '';
        setError(els.fittingCountError,'');
        els.fittingCount.setAttribute('aria-invalid','false');

        // Close tooltips
        els.tipBtns.forEach(btn=>{
          const id = btn.getAttribute('aria-controls');
          document.getElementById(id)?.setAttribute('aria-hidden','true');
          btn.setAttribute('aria-expanded','false');
        });

        renderResults({required:0, box:null, margin:null, ok:null, equiv:0, breakdown:[]});
      }

      // Initialize
      function init(){
        // Initial rows
        createConductorRow({awg:'', count:''});
        createYokeRow({awg:'', count:''});

        // Bind events
        document.addEventListener('blur', onBlurRecalc, true);
        document.addEventListener('input', (e)=>{
          if (e.target.matches('input, select')) compute();
        }, true);
        document.addEventListener('click', onClick);

        // Initial compute
        compute();
      }

      init();
    })();
  </script>

</body></html>